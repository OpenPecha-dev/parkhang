{"version":3,"file":"5.parkhang-dev.js","sources":["webpack://parkhang/./app/components/TextDetail/AddButton.css","webpack://parkhang/./app/components/TextDetail/AddButton.js","webpack://parkhang/./app/components/TextDetail/AnnotationControls.css","webpack://parkhang/./app/components/TextDetail/AnnotationControls.js","webpack://parkhang/./app/components/TextDetail/AnnotationControlsContainer.js","webpack://parkhang/./app/components/TextDetail/AnnotationControlsHeader.css","webpack://parkhang/./app/components/TextDetail/AnnotationControlsHeader.js","webpack://parkhang/./app/components/TextDetail/AnnotationControlsHeading.css","webpack://parkhang/./app/components/TextDetail/AnnotationControlsHeading.js","webpack://parkhang/./app/components/TextDetail/AnnotationDetail.css","webpack://parkhang/./app/components/TextDetail/AnnotationDetail.js","webpack://parkhang/./app/components/TextDetail/AnnotationDetailEdit.js","webpack://parkhang/./app/components/TextDetail/AnswerView.css","webpack://parkhang/./app/components/TextDetail/AnswerView.js","webpack://parkhang/./app/components/TextDetail/Button.css","webpack://parkhang/./app/components/TextDetail/HeaderMenu/Annotate.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/HighlightedString.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/Refresh.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/Search.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/SearchList.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/SearchStyle.css","webpack://parkhang/./app/components/TextDetail/HeaderMenu/Settings.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/Share.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/TableOfContent.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/WindowSplitter.js","webpack://parkhang/./app/components/TextDetail/Note.css","webpack://parkhang/./app/components/TextDetail/Note.js","webpack://parkhang/./app/components/TextDetail/NoteEditor.css","webpack://parkhang/./app/components/TextDetail/NoteEditor.js","webpack://parkhang/./app/components/TextDetail/QuestionEditor.css","webpack://parkhang/./app/components/TextDetail/QuestionEditor.js","webpack://parkhang/./app/components/TextDetail/QuestionView.css","webpack://parkhang/./app/components/TextDetail/QuestionView.js","webpack://parkhang/./app/components/TextDetail/QuestionsLoading.css","webpack://parkhang/./app/components/TextDetail/QuestionsLoading.js","webpack://parkhang/./app/components/TextDetail/SelectVersion.css","webpack://parkhang/./app/components/TextDetail/SelectVersion.js","webpack://parkhang/./app/components/TextDetail/SplitText.css","webpack://parkhang/./app/components/TextDetail/SplitText.js","webpack://parkhang/./app/components/TextDetail/TableOfContent/TableOfContent.js","webpack://parkhang/./app/components/TextDetail/Text.css","webpack://parkhang/./app/components/TextDetail/Text.js","webpack://parkhang/./app/components/TextDetail/TextDetail.css","webpack://parkhang/./app/components/TextDetail/TextDetail.js","webpack://parkhang/./app/components/TextDetail/TextDetailContainer.js","webpack://parkhang/./app/components/TextDetail/TextDetailHeading.js","webpack://parkhang/./app/components/TextDetail/TextDetailHeadingContainer.js","webpack://parkhang/./app/components/TextDetail/TextList.css","webpack://parkhang/./app/components/TextDetail/TextList.js","webpack://parkhang/./app/components/TextDetail/TextListContainer.js","webpack://parkhang/./app/components/TextDetail/index.js","webpack://parkhang/./app/components/TextDetail/textDetailHeading.css","webpack://parkhang/./app/images/PencilAltIcon.svg","webpack://parkhang/./app/images/check_circle.svg","webpack://parkhang/./app/images/note.svg","webpack://parkhang/./app/images/page_break_icon.svg","webpack://parkhang/./app/images/question_answer.svg","webpack://parkhang/./app/lib/shallowEqual.js","webpack://parkhang/./app/lib/text_splitters/positionSplitter.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"button\":\"AddButton---button\"};","import React from \"react\";\r\nimport styles from \"./AddButton.css\";\r\n\r\ntype Props = {\r\n    title?: string,\r\n    onClick?: () => void\r\n};\r\n\r\nconst AddButton = (props: Props) => {\r\n    return (\r\n        <div className={styles.button} title={props.title} onClick={props.onClick}>\r\n            +\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default AddButton;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"inlineWidth\":\"280px\",\"annotationControls\":\"AnnotationControls---annotationControls\",\"annotationContent\":\"AnnotationControls---annotationContent\",\"subTitle\":\"AnnotationControls---subTitle\",\"title\":\"AnnotationControls---title\",\"sectionHeading\":\"AnnotationControls---sectionHeading\",\"text\":\"AnnotationControls---text\",\"padding\":\"AnnotationControls---padding\",\"arrowTop\":\"AnnotationControls---arrowTop\",\"arrowLeft\":\"AnnotationControls---arrowLeft\",\"arrowRight\":\"AnnotationControls---arrowRight\",\"inline\":\"AnnotationControls---inline\",\"arrow\":\"AnnotationControls---arrow\",\"arrowDs\":\"AnnotationControls---arrowDs\",\"nothingSelected\":\"AnnotationControls---nothingSelected\",\"anonymousMessage\":\"AnnotationControls---anonymousMessage\",\"noNotes\":\"AnnotationControls---noNotes\",\"breakButtons\":\"AnnotationControls---breakButtons\"};","// @flow\r\nimport * as React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport AnnotationDetail from \"./AnnotationDetail\";\r\nimport AnnotationDetailEdit from \"./AnnotationDetailEdit\";\r\nimport styles from \"./AnnotationControls.css\";\r\nimport colours from \"css/colour.css\";\r\nimport User from \"lib/User\";\r\nimport Witness from \"lib/Witness\";\r\nimport Annotation, { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport AnnotationControlsHeading from \"./AnnotationControlsHeading\";\r\nimport NoteEditor from \"./NoteEditor\";\r\nimport QuestionView from \"./QuestionView\";\r\nimport QuestionEditor from \"./QuestionEditor\";\r\nimport QuestionsLoading from \"./QuestionsLoading\";\r\nimport { FormattedMessage } from \"react-intl\";\r\nimport Note from \"./Note\";\r\nimport Button from \"components/UI/Button\";\r\nimport PageBreakIcon from \"images/page_break_icon.svg\";\r\nimport { List } from \"react-virtualized/dist/es/List\";\r\nimport AnnotationControlsHeader from \"./AnnotationControlsHeader\";\r\nimport Question from \"lib/Question\";\r\n\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nexport const CONTROLS_MARGIN_LEFT = 10;\r\nconst FAKE_LOGIN = true;\r\nexport type QuestionData = {\r\n    loading: boolean,\r\n    questions: Question[],\r\n};\r\n\r\nexport type Props = {\r\n    inline: boolean,\r\n    user: User,\r\n    annotationsData: null,\r\n    activeAnnotation: null,\r\n    baseAnnotation: null,\r\n    availableAnnotations: Annotation[] | null,\r\n    temporaryAnnotation: null,\r\n    inline: null,\r\n    firstSelectedSegment: null,\r\n    splitTextRect: ClientRect | null,\r\n    selectedWitness: Witness,\r\n    selectedElementId: string | null,\r\n    selectedElementIds: string[] | null,\r\n    pechaImageClass: string,\r\n    notes: Annotation[],\r\n    temporaryNotes: Annotation[],\r\n    questions: Annotation[],\r\n    questionsData: { [annotationId: AnnotationUniqueId]: QuestionData },\r\n    temporaryQuestions: Annotation[],\r\n    questionQuote: React.Element<typeof React.Component> | null,\r\n    addNote: () => void,\r\n    editNote: (annotation: Annotation) => void,\r\n    saveAnnotation: (annotation: Annotation, content: string) => void,\r\n    cancelEditAnnotation: (annotation: Annotation) => void,\r\n    deleteAnnotation: (annotation: Annotation) => void,\r\n    addPageBreak: () => void,\r\n    addLineBreak: () => void,\r\n    addQuestion: () => void,\r\n    saveQuestion: (\r\n        question: Annotation,\r\n        title: string,\r\n        content: string\r\n    ) => void,\r\n    list: List | null,\r\n    closeAnnotation: () => void,\r\n};\r\n\r\ntype AnchorPoint = \"top\" | \"left\" | \"bottom\" | \"right\";\r\n\r\nconst anchorPoints = {\r\n    top: 1,\r\n    left: 2,\r\n    bottom: 3,\r\n    right: 4,\r\n};\r\n\r\nclass AnnotationControls extends React.Component<Props> {\r\n    controls: HTMLDivElement | null;\r\n    arrow: HTMLDivElement | null;\r\n    arrowDs: HTMLDivElement | null;\r\n    annotation: null;\r\n    constructor(props: Props) {\r\n        super(props);\r\n\r\n        this.controls = null;\r\n        this.arrow = null;\r\n        this.arrowDs = null;\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.updatePosition();\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        // Need to delay calling this because the browser\r\n        // may not have finished rendering when first called.\r\n        setTimeout(this.updatePosition.bind(this), 0);\r\n    }\r\n\r\n    updatePosition() {\r\n        const measurements = this.getMeasurements();\r\n        if (\r\n            !this.props.inline ||\r\n            !this.controls ||\r\n            !this.arrow ||\r\n            !measurements\r\n        ) {\r\n            return;\r\n        }\r\n        const controls = this.controls;\r\n        const height = controls.offsetHeight;\r\n        const width = controls.offsetWidth;\r\n        const arrow = this.arrow;\r\n        const bottomGap = measurements.bottomGap;\r\n        const offScreen = bottomGap < 0 || bottomGap > height;\r\n\r\n        let top = measurements.top;\r\n        const viewPortWidth = measurements.viewPortWidth || 0;\r\n\r\n        let selectedLeft = measurements.left;\r\n        let selectedRight = selectedLeft + measurements.width;\r\n\r\n        if (this.props.selectedElementIds) {\r\n            let lines = 1;\r\n            let prevSegmentLeft = 0;\r\n            let lastLineLeft = 0;\r\n            let lastLineRight = 0;\r\n            let lastLineBottom = 0;\r\n            for (let i = 0; i < this.props.selectedElementIds.length; i++) {\r\n                const segmentId = this.props.selectedElementIds[i];\r\n                const segment = document.getElementById(segmentId);\r\n                if (segment) {\r\n                    const segmentLeft = segment.offsetLeft;\r\n                    const segmentRight = segmentLeft + segment.offsetWidth;\r\n                    if (segmentLeft < prevSegmentLeft) {\r\n                        lines++;\r\n                        lastLineLeft = segmentLeft;\r\n                        lastLineRight = segmentRight;\r\n                        lastLineBottom =\r\n                            segment.offsetTop + segment.offsetHeight;\r\n                        selectedLeft = segmentLeft;\r\n                        selectedRight = segmentRight;\r\n                    } else if (segmentRight > lastLineRight) {\r\n                        lastLineRight = segmentRight;\r\n                        // selectedRight = segmentRight;\r\n                    }\r\n                    if (segmentLeft < selectedLeft) selectedLeft = segmentLeft;\r\n                    if (segmentRight > selectedRight)\r\n                        selectedRight = segmentRight;\r\n                    prevSegmentLeft = segmentLeft;\r\n                }\r\n            }\r\n        }\r\n        let selectedWidth = selectedRight - selectedLeft;\r\n\r\n        let anchorPoint = anchorPoints.bottom;\r\n        let moveToSide = false;\r\n        let moveRight = 0;\r\n        if (!offScreen && bottomGap < height) {\r\n            moveToSide = true;\r\n        }\r\n\r\n        if (moveToSide) {\r\n            arrow.className = styles.arrowLeft;\r\n            if (selectedLeft - width - arrow.offsetWidth < 0) {\r\n                anchorPoint = anchorPoints.right;\r\n            } else {\r\n                anchorPoint = anchorPoints.left;\r\n            }\r\n        } else {\r\n            let controlOverhang = width / 2 - selectedWidth / 2;\r\n            if (selectedLeft - controlOverhang < 0) {\r\n                moveRight = Math.abs(selectedLeft - controlOverhang);\r\n            }\r\n            if (selectedRight + controlOverhang > viewPortWidth) {\r\n                moveRight = viewPortWidth - (selectedRight + controlOverhang);\r\n            }\r\n        }\r\n\r\n        if (anchorPoint === anchorPoints.bottom) {\r\n            let arrowHeight = 0;\r\n            let arrowLeft = 0;\r\n            if (this.arrow) {\r\n                this.arrow.className = styles.arrowTop;\r\n                arrowLeft = width / 2 - this.arrow.offsetWidth / 2 - moveRight;\r\n                if (arrowLeft < 0) arrowLeft = 0;\r\n                this.arrow.style.left = arrowLeft + \"px\";\r\n                arrowHeight = this.arrow.offsetHeight;\r\n                this.arrow.style.top = 0 - arrowHeight + \"px\";\r\n            }\r\n            controls.style.top = top + measurements.height + arrowHeight + \"px\";\r\n            controls.style.left =\r\n                selectedLeft + selectedWidth / 2 - width / 2 + moveRight + \"px\";\r\n        } else if (moveToSide) {\r\n            arrow.className = styles.arrowRight;\r\n            let arrowHeight = arrow.offsetHeight;\r\n            let controlsTop =\r\n                measurements.top + measurements.height / 2 - arrowHeight / 2;\r\n            if (\r\n                measurements.top +\r\n                    measurements.height +\r\n                    bottomGap -\r\n                    controlsTop <\r\n                height\r\n            ) {\r\n                controlsTop =\r\n                    measurements.top + measurements.height + bottomGap - height;\r\n            }\r\n            if (anchorPoint === anchorPoints.left) {\r\n                // left side of selection\r\n                arrow.style.left = width - 2 + \"px\";\r\n                controls.style.left =\r\n                    selectedLeft - width - arrow.offsetWidth + \"px\";\r\n            } else {\r\n                // right-side of selection\r\n\r\n                arrow.className = styles.arrowLeft;\r\n                arrow.style.left = -arrow.offsetWidth + \"px\";\r\n                controls.style.left =\r\n                    selectedLeft + selectedWidth + arrow.offsetWidth + \"px\";\r\n\r\n                // controls.style.right = 0 + \"px\";\r\n            }\r\n            arrow.style.display = \"none\";\r\n            arrow.style.top =\r\n                measurements.top -\r\n                controlsTop +\r\n                measurements.height / 2 -\r\n                arrowHeight / 2 +\r\n                \"px\";\r\n\r\n            controls.style.top = controlsTop + \"px\";\r\n        } else {\r\n            controls.style.top = top + \"px\";\r\n        }\r\n    }\r\n\r\n    getMeasurements(): {\r\n        top: number,\r\n        textTop: number,\r\n        rowTop: number,\r\n        left: number,\r\n        width: number,\r\n        height: number,\r\n        topGap: number,\r\n        bottomGap: number,\r\n        viewPortWidth: number | null,\r\n    } | null {\r\n        if (!this.props.selectedElementIds) {\r\n            return null;\r\n        }\r\n\r\n        const lastSelectedElementId =\r\n            this.props.selectedElementIds[\r\n                this.props.selectedElementIds.length - 1\r\n            ];\r\n        const lastElement = document.getElementById(lastSelectedElementId);\r\n        const firstSelectedElementId = this.props.selectedElementIds[0];\r\n        const firstElement = document.getElementById(firstSelectedElementId);\r\n\r\n        const splitTextRect = this.props.splitTextRect;\r\n        let extraTop = 0;\r\n        let scrollTop = 0;\r\n\r\n        if (this.props.list) {\r\n            scrollTop = this.props.list.Grid.state.scrollTop;\r\n        }\r\n        if (this.props.pechaImageClass) {\r\n            const pechaImage = document.getElementsByClassName(\r\n                this.props.pechaImageClass\r\n            )[0];\r\n            extraTop = pechaImage.offsetHeight;\r\n        }\r\n        if (!lastElement) {\r\n            console.warn(\r\n                \"no valid element found in getMeasurements, elementId: %s\",\r\n                this.props.selectedElementId\r\n            );\r\n            return {\r\n                top: 0,\r\n                textTop: 0,\r\n                rowTop: 0,\r\n                left: 0,\r\n                width: 1,\r\n                height: 1,\r\n                topGap: 0,\r\n                bottomGap: 0,\r\n                viewPortWidth: 1,\r\n            };\r\n        }\r\n        const top = lastElement.offsetTop + extraTop;\r\n        const textTop = lastElement.offsetTop;\r\n        const left = lastElement.offsetLeft;\r\n        const width = lastElement.offsetWidth;\r\n        const height = lastElement.offsetHeight;\r\n        let rowTop = top;\r\n\r\n        let viewPortWidth = null;\r\n        let topGap = 0;\r\n        let bottomGap = 0;\r\n        if (lastElement && splitTextRect) {\r\n            const elRect = lastElement.getBoundingClientRect();\r\n\r\n            bottomGap =\r\n                splitTextRect.height + splitTextRect.top - elRect.bottom;\r\n            viewPortWidth = splitTextRect.width;\r\n        }\r\n        if (firstElement && splitTextRect) {\r\n            const elRect = firstElement.getBoundingClientRect();\r\n            topGap = splitTextRect.height - elRect.top;\r\n        }\r\n\r\n        return {\r\n            top: top,\r\n            textTop: textTop,\r\n            rowTop: rowTop,\r\n            left: left,\r\n            width: width,\r\n            height: height,\r\n            topGap: topGap,\r\n            bottomGap: bottomGap,\r\n            viewPortWidth: viewPortWidth,\r\n        };\r\n    }\r\n\r\n    render() {\r\n        const props = this.props;\r\n        let annotations = [];\r\n        let temporaryAnnotations = [];\r\n        let anonymousUserMessage = null;\r\n        let nothingSelected = null;\r\n        const isLoggedIn = props.user.isLoggedIn || FAKE_LOGIN;\r\n\r\n        let breakSelected = false;\r\n        if (\r\n            props.activeAnnotation &&\r\n            (props.activeAnnotation.isType(ANNOTATION_TYPES.pageBreak) ||\r\n                props.activeAnnotation.isType(ANNOTATION_TYPES.lineBreak))\r\n        ) {\r\n            breakSelected = true;\r\n        }\r\n        // the selected word/sentence is props.anotationsData\r\n\r\n        if (props.annotationsData) {\r\n            props.annotationsData.map((annotationData) => {\r\n                let isEditing = false;\r\n                let isActive = false;\r\n                if (annotationData.isTemporary) {\r\n                    isEditing = true;\r\n                    isActive = true;\r\n                } else if (\r\n                    !props.temporaryAnnotation &&\r\n                    annotationData.annotation.uniqueId ==\r\n                        props.activeAnnotation.uniqueId\r\n                ) {\r\n                    isActive = true;\r\n                }\r\n\r\n                if (isEditing) {\r\n                    let annotationDetail = (\r\n                        <AnnotationDetailEdit\r\n                            annotationData={annotationData}\r\n                            key={annotationData.annotation.uniqueId}\r\n                            isActive={isActive}\r\n                            saveAnnotationHandler={(content) => {\r\n                                props.saveAnnotation(\r\n                                    annotationData.annotation,\r\n                                    content\r\n                                );\r\n                            }}\r\n                            cancelAnnotationHandler={() => {\r\n                                props.cancelEditAnnotation(\r\n                                    annotationData.annotation\r\n                                );\r\n                            }}\r\n                            isLoggedIn={isLoggedIn}\r\n                            selectAnnotationHandler={() => {}}\r\n                            editAnnotationHandler={() => {}}\r\n                        />\r\n                    );\r\n                    temporaryAnnotations.push(annotationDetail);\r\n                } else {\r\n                    let annotationDetail = (\r\n                        <AnnotationDetail\r\n                            isWorkingSection={false}\r\n                            fontSize={props.fontSize}\r\n                            annotationData={annotationData}\r\n                            key={annotationData.annotation.uniqueId}\r\n                            isActive={isActive}\r\n                            selectAnnotationHandler={() => {\r\n                                if (isLoggedIn && !isEditing) {\r\n                                    props.didSelectAnnotation(\r\n                                        annotationData.annotation\r\n                                    );\r\n                                }\r\n                            }}\r\n                            editAnnotationHandler={() => {\r\n                                if (isLoggedIn && !isEditing) {\r\n                                    this.annotation = annotationData.annotation;\r\n\r\n                                    props.editAnnotation(\r\n                                        annotationData.annotation\r\n                                    );\r\n                                }\r\n                            }}\r\n                            isLoggedIn={isLoggedIn}\r\n                        />\r\n                    );\r\n                    annotations.push(annotationDetail);\r\n                }\r\n            }, this);\r\n            if (!props.user.isLoggedIn === !FAKE_LOGIN) {\r\n                // NOTE: FormattedMessage cannot take a child when using\r\n                // the values option, so need to wrap it in a div\r\n                console.log(!props.user.isLoggedIn === !FAKE_LOGIN);\r\n                anonymousUserMessage = (\r\n                    <div\r\n                        className={styles.anonymousMessage}\r\n                        style={{\r\n                            position: \"relative\",\r\n                            width: \"fit-content\",\r\n                            border: \"1px solid gray\",\r\n                            paddingInline: 10,\r\n                        }}\r\n                    >\r\n                        <FormattedMessage\r\n                            id=\"annotations.loginMessage\"\r\n                            values={{\r\n                                loginLink: (\r\n                                    <>\r\n                                        <FormattedMessage id=\"annotations.loginLink\" />\r\n                                    </>\r\n                                ),\r\n                            }}\r\n                        />\r\n                    </div>\r\n                );\r\n            }\r\n        } else {\r\n            nothingSelected = (\r\n                <div className={styles.nothingSelected}>Nothing Selected</div>\r\n            );\r\n        }\r\n\r\n        let pageBreaksButton = null;\r\n        let allowPageBreak = !this.props.selectedWitness.isWorking;\r\n        let lineBreaksButton = null;\r\n        let allowLineBreak = !this.props.selectedWitness.isWorking;\r\n        if (isLoggedIn && !this.props.selectedWitness.isWorking) {\r\n            let pageBreaks = [];\r\n            let lineBreaks = [];\r\n            if (this.props.availableAnnotations) {\r\n                pageBreaks = this.props.availableAnnotations.filter(\r\n                    (annotation: Annotation) =>\r\n                        annotation.type === ANNOTATION_TYPES.pageBreak &&\r\n                        annotation.creatorWitness.id ===\r\n                            this.props.selectedWitness.id\r\n                );\r\n                lineBreaks = this.props.availableAnnotations.filter(\r\n                    (annotation: Annotation) =>\r\n                        annotation.type === ANNOTATION_TYPES.lineBreak &&\r\n                        annotation.creatorWitness.id ===\r\n                            this.props.selectedWitness.id\r\n                );\r\n            }\r\n\r\n            if (pageBreaks.length > 0) {\r\n                pageBreaksButton = (\r\n                    <div className={styles.breakButtons}>\r\n                        <Button\r\n                            title=\"Page Break\"\r\n                            accessoryType=\"DELETE\"\r\n                            icon={<PageBreakIcon width={20} height={20} />}\r\n                            onClick={() => {\r\n                                this.props.deleteAnnotation(pageBreaks[0]);\r\n                            }}\r\n                            isActive={true}\r\n                            backgroundColor={colours.activeButton}\r\n                        />\r\n                    </div>\r\n                );\r\n                allowPageBreak = false;\r\n            }\r\n\r\n            if (lineBreaks.length > 0) {\r\n                lineBreaksButton = (\r\n                    <div className={styles.breakButtons}>\r\n                        <Button\r\n                            title=\"Line Break\"\r\n                            accessoryType=\"DELETE\"\r\n                            icon=\"&#182;\"\r\n                            onClick={() => {\r\n                                this.props.deleteAnnotation(lineBreaks[0]);\r\n                            }}\r\n                            isActive={true}\r\n                            backgroundColor={colours.activeButton}\r\n                        />\r\n                    </div>\r\n                );\r\n                allowLineBreak = false;\r\n            }\r\n\r\n            // Can't have line break and page break in same place.\r\n            if (!allowPageBreak) allowLineBreak = false;\r\n            if (!allowLineBreak) allowPageBreak = false;\r\n        }\r\n\r\n        let tempNotes = null;\r\n        let tempNoteIds = {};\r\n        if (props.temporaryNotes && props.temporaryNotes.length > 0) {\r\n            tempNotes = props.temporaryNotes.map((note: Annotation) => {\r\n                let key = \"NOTE_\" + note.uniqueId;\r\n                // The note is being edited\r\n                if (note.basedOn) {\r\n                    tempNoteIds[note.basedOn.uniqueId] = note.uniqueId;\r\n                }\r\n                return (\r\n                    <NoteEditor\r\n                        note={note}\r\n                        key={key}\r\n                        saveNote={props.saveAnnotation}\r\n                        cancel={() => props.cancelEditAnnotation(note)}\r\n                    />\r\n                );\r\n            });\r\n        }\r\n\r\n        let notes = null;\r\n        if (props.notes && props.notes.length > 0) {\r\n            // Filter out notes that are being edited\r\n            const validNotes = props.notes.filter(\r\n                (note: Annotation) => !tempNoteIds.hasOwnProperty(note.uniqueId)\r\n            );\r\n            notes = validNotes.map((note: Annotation) => {\r\n                let key = \"NOTE_\" + note.uniqueId;\r\n                return (\r\n                    <Note\r\n                        note={note}\r\n                        key={key}\r\n                        delete={this.props.deleteAnnotation}\r\n                        edit={this.props.editNote}\r\n                    />\r\n                );\r\n            });\r\n        }\r\n\r\n        let tempQuestions = null;\r\n        let tempQuestionIds = {};\r\n        if (\r\n            props.temporaryQuestions &&\r\n            props.temporaryQuestions.length > 0 &&\r\n            props.questionQuote\r\n        ) {\r\n            tempQuestions = props.temporaryQuestions.map(\r\n                (question: Annotation) => {\r\n                    tempQuestionIds[question.uniqueId] = question.uniqueId;\r\n                    let key = \"QUESTION_\" + question.uniqueId;\r\n\r\n                    return (\r\n                        <QuestionEditor\r\n                            question={question}\r\n                            questionQuote={props.questionQuote}\r\n                            defaultTitle={props.selectedWitness.text.name}\r\n                            key={key}\r\n                            saveQuestion={props.saveQuestion}\r\n                            cancel={() => props.cancelEditAnnotation(question)}\r\n                        />\r\n                    );\r\n                }\r\n            );\r\n        }\r\n\r\n        let questionLoadingIndicators = null;\r\n        let questionViews: Array<QuestionView> = [];\r\n        let questionsAreLoading = false;\r\n        if (props.questions && props.questions.length > 0) {\r\n            let questions: Question[] = [];\r\n            for (let i = 0; i < props.questions.length; i++) {\r\n                const question = props.questions[i];\r\n                let isValid = !tempQuestionIds.hasOwnProperty(\r\n                    question.uniqueId\r\n                );\r\n                if (isValid) {\r\n                    if (props.questionsData.hasOwnProperty(question.uniqueId)) {\r\n                        if (props.questionsData[question.uniqueId].loading) {\r\n                            questionsAreLoading = true;\r\n                        }\r\n                        questions = questions.concat(\r\n                            props.questionsData[question.uniqueId].questions\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            questionViews = questions.map((question: Question) => {\r\n                let key = \"QUESTION_\" + question.annotationUniqueId;\r\n                return (\r\n                    <QuestionView\r\n                        question={question}\r\n                        key={\"question_\" + question.annotationUniqueId}\r\n                    />\r\n                );\r\n            });\r\n        }\r\n        let questionHeading = null;\r\n        if (questionViews.length > 0) {\r\n            questionHeading = (\r\n                <h3 className={styles.sectionHeading}>Questions</h3>\r\n            );\r\n        }\r\n\r\n        let questionsLoading = null;\r\n        if (questionsAreLoading) {\r\n            questionsLoading = <QuestionsLoading />;\r\n        }\r\n\r\n        let allowQuestion =\r\n            props.questions.length === 0 &&\r\n            props.temporaryQuestions.length === 0;\r\n\r\n        let classes = [styles.annotationControls];\r\n        if (props.inline) {\r\n            classes.push(styles.inline);\r\n        }\r\n\r\n        let showHeader = true;\r\n        if (anonymousUserMessage || breakSelected) showHeader = false;\r\n\r\n        return (\r\n            <div\r\n                className={classnames(...classes)}\r\n                ref={(controls: HTMLDivElement | null) =>\r\n                    (this.controls = controls)\r\n                }\r\n            >\r\n                {showHeader && (\r\n                    <AnnotationControlsHeader\r\n                        addPageBreak={\r\n                            allowPageBreak ? props.addPageBreak : null\r\n                        }\r\n                        addLineBreak={\r\n                            allowLineBreak ? props.addLineBreak : null\r\n                        }\r\n                        addNote={\r\n                            isLoggedIn && !tempNotes\r\n                                ? () => props.addNote()\r\n                                : null\r\n                        }\r\n                        addQuestion={allowQuestion ? props.addQuestion : null}\r\n                        closeAnnotation={props.closeAnnotation}\r\n                        editAnnotationHandler={() => {\r\n                            let editBtn = document.getElementById(\"editBtn\");\r\n                            editBtn?.click();\r\n                        }}\r\n                        userLoggedIn={isLoggedIn}\r\n                    />\r\n                )}\r\n\r\n                <div className={styles.annotationContent}>\r\n                    {anonymousUserMessage}\r\n                    {nothingSelected}\r\n                    {!breakSelected && temporaryAnnotations}\r\n                    {!breakSelected && annotations}\r\n                    {pageBreaksButton}\r\n                    {lineBreaksButton}\r\n                    {tempNotes}\r\n                    {notes}\r\n                    {questionHeading}\r\n                    {tempQuestions}\r\n                    {questionsLoading}\r\n                    {questionViews}\r\n                </div>\r\n                <div\r\n                    className={styles.arrow}\r\n                    ref={(div) => (this.arrow = div)}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default AnnotationControls;\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect, useStore } from \"react-redux\";\r\nimport { batchActions } from \"redux-batched-actions\";\r\nimport AnnotationControls from \"./AnnotationControls\";\r\nimport type { Props as ControlsProps } from \"./AnnotationControls\";\r\nimport addTibetanShay from \"lib/addTibetanShay\";\r\nimport * as reducers from \"reducers\";\r\nimport type { AppState } from \"reducers\";\r\nimport * as actions from \"actions\";\r\nimport { BASE_ANNOTATION_ID } from \"lib/AnnotatedText\";\r\nimport Annotation, {\r\n    ANNOTATION_TYPES,\r\n    TemporaryAnnotation,\r\n} from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport AnnotatedText from \"lib/AnnotatedText\";\r\nimport User from \"lib/User\";\r\nimport Witness from \"lib/Witness\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport SplitText from \"lib/SplitText\";\r\nimport _ from \"lodash\";\r\nimport { changedActiveTextAnnotation } from \"actions\";\r\nimport ReactDOMServer from \"react-dom/server\";\r\nimport Question from \"lib/Question\";\r\nimport type { QuestionData } from \"./AnnotationControls\";\r\nimport { getTextFontSize } from \"reducers\";\r\n\r\nconst TEMPORARY_ANNOTATION_ID = -3;\r\nconst BASE_NAME = \"Working\";\r\n\r\ntype AnnotationData = {\r\n    name: string,\r\n    content: string,\r\n    id: AnnotationUniqueId,\r\n    isTemporary: boolean,\r\n    annotation: Annotation,\r\n    userCreated: boolean,\r\n};\r\nconst getAnnotationsData = (\r\n    annotations,\r\n    sources,\r\n    workingSourceName,\r\n    selectedText\r\n): AnnotationData[] => {\r\n    let annotationsData = [];\r\n    let baseSources = sources.filter(\r\n        (source) => source.isWorking || source.isBase\r\n    );\r\n    let baseSourceNames = baseSources.map((source) => source.name);\r\n    if (annotations) {\r\n        let annotationsById = {};\r\n        for (let i = 0; i < annotations.length; i++) {\r\n            let annotation = annotations[i];\r\n            let id = annotation.content + annotation.start;\r\n            if (annotation.isTemporary) {\r\n                annotationsById[TEMPORARY_ANNOTATION_ID] = {\r\n                    name: annotation.getSourceName(),\r\n                    content: annotation.content,\r\n                    id: annotation.uniqueId,\r\n                    isTemporary: true,\r\n                    annotation: annotation,\r\n                };\r\n                baseSourceNames = baseSourceNames.filter(\r\n                    (a) => a !== annotation.getSourceName()\r\n                );\r\n                id = TEMPORARY_ANNOTATION_ID;\r\n            } else if (annotationsById[id]) {\r\n                let existingAnnotation = annotationsById[id];\r\n                existingAnnotation.name +=\r\n                    \" \" + addTibetanShay(annotation.getSourceName());\r\n                baseSourceNames = baseSourceNames.filter(\r\n                    (a) => a !== annotation.getSourceName()\r\n                );\r\n            } else {\r\n                annotationsById[id] = {\r\n                    name: addTibetanShay(annotation.getSourceName()),\r\n                    content: annotation.content,\r\n                    id: annotation.uniqueId,\r\n                    userCreated: annotation.userCreated,\r\n                    annotation: annotation,\r\n                };\r\n                baseSourceNames = baseSourceNames.filter(\r\n                    (a) => a !== annotation.getSourceName()\r\n                );\r\n            }\r\n            if (\r\n                !annotation.userCreated &&\r\n                annotation.creatorWitness.isWorking\r\n            ) {\r\n                annotationsById[id].isWorking = true;\r\n            } else {\r\n                annotationsById[id].isWorking = false;\r\n            }\r\n        }\r\n        // Make sure Working source is first\r\n        baseSourceNames.unshift(workingSourceName);\r\n        let Base = baseSourceNames;\r\n        if (\r\n            selectedText?.name !==\r\n            \"བྱང་ཆུབ་སེམས་དཔའི་སྤྱོད་པ་ལ་འཇུག་པ་བཞུགས་སོ།\"\r\n        ) {\r\n            //Dominant only awailable for chojuk text\r\n            Base = baseSourceNames.filter((l) => l !== \"Dominant\");\r\n        }\r\n\r\n        annotationsData = Object.keys(annotationsById).reduce((arr, key) => {\r\n            const annotationData = annotationsById[key];\r\n\r\n            if (annotationData.isWorking) {\r\n                annotationData.name = Base.reduce(\r\n                    (prev, cur) => (prev += \" \" + addTibetanShay(cur, \";\")),\r\n                    \"\"\r\n                );\r\n            }\r\n            arr.push(annotationData);\r\n            return arr;\r\n        }, []);\r\n    }\r\n\r\n    return annotationsData;\r\n};\r\n\r\nconst getAvailableAnnotations = (\r\n    annotatedText: AnnotatedText,\r\n    activeAnnotation: Annotation,\r\n    temporaryAnnotation: TemporaryAnnotation | null,\r\n    annotationPositions: { [string]: Annotation[] }\r\n): Annotation[] => {\r\n    let availableAnnotations = [];\r\n    if (\r\n        !temporaryAnnotation ||\r\n        activeAnnotation.naturalId !== temporaryAnnotation.naturalId\r\n    ) {\r\n        availableAnnotations.push(activeAnnotation);\r\n    }\r\n    if (temporaryAnnotation) {\r\n        availableAnnotations.push(temporaryAnnotation);\r\n    }\r\n    let [start, length] =\r\n        annotatedText.getPositionOfAnnotation(activeAnnotation);\r\n\r\n    if (!start) {\r\n        return availableAnnotations;\r\n    }\r\n\r\n    let end = start + length;\r\n\r\n    let possibleAnnotations = [];\r\n\r\n    if (activeAnnotation.isInsertion) {\r\n        const insertionAnnotations = annotationPositions[\"i\" + start];\r\n        if (insertionAnnotations) {\r\n            possibleAnnotations =\r\n                possibleAnnotations.concat(insertionAnnotations);\r\n        }\r\n        const activeInsertionAnnotations = annotationPositions[String(start)];\r\n        if (activeInsertionAnnotations) {\r\n            possibleAnnotations = possibleAnnotations.concat(\r\n                activeInsertionAnnotations\r\n            );\r\n        }\r\n    } else {\r\n        // Only include annotations if they encompass the whole annotation\r\n        // i.e. not if activeAnnotation is a user annotation and combines\r\n        // annotated text with normal text.\r\n        let startAnnotations = annotationPositions[String(start)];\r\n        let endAnnotations = annotationPositions[String(end)];\r\n\r\n        if (startAnnotations) {\r\n            possibleAnnotations = startAnnotations;\r\n        }\r\n        if (endAnnotations) {\r\n            possibleAnnotations = possibleAnnotations.concat(endAnnotations);\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < possibleAnnotations.length; i++) {\r\n        const annotation = possibleAnnotations[i];\r\n        if (\r\n            annotation.start === activeAnnotation.start &&\r\n            annotation.length === activeAnnotation.length\r\n        ) {\r\n            // If an annotation is being edited, there will be a temporary annotation\r\n            // with the same natural id. If so, don't show the orignal version.\r\n            //\r\n            // We use natualId, as it normalises the id regardless of the original's\r\n            // save state. e.g. Upon editing a witness variant, a new annotation will be\r\n            // created. If the user is offline, that will not have been saved via the\r\n            // API yet. The user could then edit this new annotation, creating a temporary\r\n            // annotation based upon it. While this is being edited, the user could come\r\n            // back online and the save operation will succeed. This will mean the id of\r\n            // the temporary annotation will be different to the original edit, but naturalId\r\n            // will be the same.\r\n            if (\r\n                !temporaryAnnotation ||\r\n                annotation.naturalId !== temporaryAnnotation.naturalId\r\n            ) {\r\n                availableAnnotations.push(annotation);\r\n            }\r\n        } else if (!annotatedText.activeWitness.isWorking) {\r\n            if (\r\n                annotation.type === ANNOTATION_TYPES.pageBreak ||\r\n                annotation.type === ANNOTATION_TYPES.lineBreak\r\n            ) {\r\n                availableAnnotations.push(annotation);\r\n            }\r\n        }\r\n    }\r\n\r\n    availableAnnotations = _.uniqWith(\r\n        availableAnnotations,\r\n        (a, b) => a.id === b.id\r\n    );\r\n\r\n    return availableAnnotations;\r\n};\r\n\r\nconst getTemporaryAnnotation = (\r\n    state: AppState,\r\n    type: string,\r\n    user: User,\r\n    witness: Witness,\r\n    start: number,\r\n    length: number\r\n): TemporaryAnnotation | null => {\r\n    const annotations = reducers.getTemporaryAnnotations(\r\n        state,\r\n        witness.id,\r\n        start,\r\n        length,\r\n        type\r\n    );\r\n    if (annotations.length > 0) {\r\n        return annotations[0];\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\ntype StateProps = ControlsProps & {\r\n    questionsData: { [annotationId: AnnotationUniqueId]: Question[] },\r\n};\r\n\r\n// These are the props that are expected to be set and available in ownProps\r\ntype ContainerProps = {\r\n    annotationPositions: { [string]: Annotation[] },\r\n    annotatedText: AnnotatedText,\r\n    activeAnnotation: Annotation | null,\r\n    inline?: boolean,\r\n    firstSelectedSegment: TextSegment,\r\n    splitTextRect: ClientRect | null,\r\n    splitText: SplitText | null,\r\n};\r\n\r\nexport const mapStateToProps = (state: AppState, ownProps: ContainerProps) => {\r\n    const user = reducers.getUser(state);\r\n    const selectedText = reducers.getSelectedText(state);\r\n    const activeAnnotation = ownProps.activeAnnotation;\r\n    const inline = ownProps.inline;\r\n    let selectedWitness = reducers.getSelectedTextWitness(state);\r\n    if (!selectedWitness) {\r\n        if (selectedText) {\r\n            selectedWitness = reducers.getWorkingWitness(\r\n                state,\r\n                selectedText.id\r\n            );\r\n        }\r\n    }\r\n\r\n    if (!activeAnnotation || !selectedWitness) {\r\n        return {\r\n            annotationsData: null,\r\n            activeAnnotation: null,\r\n            baseAnnotation: null,\r\n            availableAnnotations: null,\r\n            user: user,\r\n            temporaryAnnotation: null,\r\n            inline: null,\r\n            firstSelectedSegment: null,\r\n            splitTextRect: null,\r\n            selectedWitness: null,\r\n        };\r\n    }\r\n\r\n    const temporaryVariant = getTemporaryAnnotation(\r\n        state,\r\n        ANNOTATION_TYPES.variant,\r\n        user,\r\n        selectedWitness,\r\n        activeAnnotation.start,\r\n        activeAnnotation.length\r\n    );\r\n\r\n    const annotations = getAvailableAnnotations(\r\n        ownProps.annotatedText,\r\n        activeAnnotation,\r\n        temporaryVariant,\r\n        ownProps.annotationPositions\r\n    );\r\n    const variants = annotations.filter(\r\n        (annotation: Annotation) => annotation.type === ANNOTATION_TYPES.variant\r\n    );\r\n    const sources = reducers.getSources(state);\r\n    const workingSourceName = reducers.getTranslation(\r\n        state,\r\n        \"annotation.workingEdition\",\r\n        BASE_NAME\r\n    );\r\n    let variantsData = getAnnotationsData(\r\n        variants,\r\n        sources,\r\n        workingSourceName,\r\n        selectedText\r\n    );\r\n\r\n    let baseAnnotation = null;\r\n    if (activeAnnotation.id == BASE_ANNOTATION_ID) {\r\n        baseAnnotation = activeAnnotation;\r\n    } else {\r\n        const [start, length] =\r\n            ownProps.annotatedText.getPositionOfAnnotation(activeAnnotation);\r\n        if (start === null || length === null) {\r\n            variantsData = null;\r\n        } else {\r\n            baseAnnotation = ownProps.annotatedText.getBaseAnnotation(\r\n                start,\r\n                length\r\n            );\r\n            const baseAnnotationData = getAnnotationsData(\r\n                [baseAnnotation],\r\n                sources,\r\n                workingSourceName\r\n            );\r\n            variantsData = [...baseAnnotationData, ...variantsData];\r\n        }\r\n    }\r\n\r\n    // make sure temporary annotation is first, then user created, then base annotation\r\n    if (variantsData) {\r\n        variantsData.sort((a, b) => {\r\n            if (a.isTemporary) {\r\n                return -1;\r\n            } else if (b.isTemporary) {\r\n                return 1;\r\n            } else if (a.userCreated) {\r\n                return -1;\r\n            } else if (b.userCreated) {\r\n                return 1;\r\n            } else if (a.annotation.id && b.annotation.id) {\r\n                return a.annotation.id - b.annotation.id;\r\n            } else {\r\n                return 1;\r\n            }\r\n        });\r\n    }\r\n\r\n    const notes: Array<Annotation> = annotations.filter(\r\n        (annotation: Annotation) => annotation.type === ANNOTATION_TYPES.note\r\n    );\r\n\r\n    const temporaryNotes = reducers.getTemporaryAnnotations(\r\n        state,\r\n        selectedWitness.id,\r\n        activeAnnotation.start,\r\n        activeAnnotation.length,\r\n        ANNOTATION_TYPES.note\r\n    );\r\n\r\n    const questionAnnotations: Array<Annotation> = annotations.filter(\r\n        (annotation: Annotation): boolean =>\r\n            annotation.type === ANNOTATION_TYPES.question\r\n    );\r\n    let questionsData = {};\r\n    if (questionAnnotations.length > 0) {\r\n        for (var i = 0; i < questionAnnotations.length; i++) {\r\n            const question = questionAnnotations[i];\r\n            questionsData[question.uniqueId] = {};\r\n            const isLoading = reducers.questionIsLoading(state, question);\r\n            questionsData[question.uniqueId][\"loading\"] = isLoading;\r\n            const questions = reducers.getQuestions(state, question.uniqueId);\r\n            questionsData[question.uniqueId][\"questions\"] = questions;\r\n        }\r\n    }\r\n\r\n    const temporaryQuestions = reducers.getTemporaryAnnotations(\r\n        state,\r\n        selectedWitness.id,\r\n        activeAnnotation.start,\r\n        activeAnnotation.length,\r\n        ANNOTATION_TYPES.question\r\n    );\r\n\r\n    let questionQuote = null;\r\n    if (temporaryQuestions.length > 0) {\r\n        const firstQuestion = temporaryQuestions[0];\r\n\r\n        let [start, end] =\r\n            ownProps.annotatedText.getPositionOfAnnotation(firstQuestion);\r\n        if (start) {\r\n            if (!end) {\r\n                end = start + 1;\r\n            }\r\n            const [startText, mainText, endText] =\r\n                ownProps.annotatedText.segmentedText.extractTextAroundPosition(\r\n                    start,\r\n                    end,\r\n                    [\"།\", \" \"]\r\n                );\r\n\r\n            const linkUrl = document.location.href;\r\n            questionQuote = (\r\n                <blockquote>\r\n                    {startText}\r\n                    <a href={linkUrl}>{mainText}</a>\r\n                    {endText}\r\n                </blockquote>\r\n            );\r\n        }\r\n    }\r\n    let fontSize = getTextFontSize(state);\r\n\r\n    return {\r\n        annotationsData: variantsData,\r\n        activeAnnotation: activeAnnotation,\r\n        baseAnnotation: baseAnnotation,\r\n        availableAnnotations: annotations,\r\n        user: user,\r\n        temporaryAnnotation: temporaryVariant,\r\n        inline: inline,\r\n        firstSelectedSegment: ownProps.firstSelectedSegment,\r\n        splitTextRect: ownProps.splitTextRect,\r\n        selectedWitness: selectedWitness,\r\n        notes: notes,\r\n        temporaryNotes: temporaryNotes,\r\n        questions: questionAnnotations,\r\n        temporaryQuestions: temporaryQuestions,\r\n        questionsData: questionsData,\r\n        questionQuote: questionQuote,\r\n        fontSize,\r\n    };\r\n};\r\n\r\nconst mergeProps = (stateProps: StateProps, dispatchProps, ownProps) => {\r\n    const { dispatch } = dispatchProps;\r\n\r\n    if (stateProps.questions.length > 0) {\r\n        for (var i = 0; i < stateProps.questions.length; i++) {\r\n            const question = stateProps.questions[i];\r\n            let loadQuestionData = true;\r\n            if (stateProps.questionsData.hasOwnProperty(question.uniqueId)) {\r\n                if (\r\n                    stateProps.questionsData[question.uniqueId].questions\r\n                        .length > 0 ||\r\n                    stateProps.questionsData[question.uniqueId].loading\r\n                ) {\r\n                    loadQuestionData = false;\r\n                }\r\n            }\r\n            if (loadQuestionData) {\r\n                dispatch(new actions.loadQuestion(question));\r\n            }\r\n        }\r\n    }\r\n\r\n    const addBreak = (\r\n        breakType: string,\r\n        selectBreak: boolean = false\r\n    ): (() => void) => {\r\n        return () => {\r\n            const location = ownProps.activeAnnotation;\r\n\r\n            const breakAnnotation = new Annotation(\r\n                null,\r\n                location.witness,\r\n                location.end + 1,\r\n                0,\r\n                null,\r\n                breakType,\r\n                stateProps.selectedWitness,\r\n                stateProps.user\r\n            );\r\n            let selectedWitnessData = reducers.dataFromWitness(\r\n                stateProps.selectedWitness\r\n            );\r\n\r\n            let actionsBatch = [];\r\n\r\n            actionsBatch.push(actions.createdAnnotation(breakAnnotation));\r\n            actionsBatch.push(\r\n                actions.appliedAnnotation(\r\n                    breakAnnotation.uniqueId,\r\n                    selectedWitnessData\r\n                )\r\n            );\r\n            if (selectBreak) {\r\n                actionsBatch.push(\r\n                    actions.changedActiveTextAnnotation(breakAnnotation)\r\n                );\r\n            } else {\r\n                actionsBatch.push(actions.changedActiveTextAnnotation(null));\r\n            }\r\n\r\n            dispatch(batchActions(actionsBatch));\r\n        };\r\n    };\r\n\r\n    const saveAnnotation = (\r\n        selectedAnnotation: TemporaryAnnotation,\r\n        content: string\r\n    ) => {\r\n        if (!selectedAnnotation.isTemporary) {\r\n            console.warn(\r\n                \"Tried to save a non-temporary annotation: %o\",\r\n                selectedAnnotation\r\n            );\r\n            return;\r\n        }\r\n\r\n        let selectedWitness = stateProps.selectedWitness;\r\n        let selectedWitnessData = reducers.dataFromWitness(selectedWitness);\r\n\r\n        const newAnnotation = new Annotation(\r\n            selectedAnnotation.id,\r\n            selectedAnnotation.witness,\r\n            selectedAnnotation.start,\r\n            selectedAnnotation.length,\r\n            content,\r\n            selectedAnnotation.type,\r\n            selectedAnnotation.creatorWitness,\r\n            stateProps.user,\r\n            selectedAnnotation.uniqueId,\r\n            selectedAnnotation.basedOn\r\n        );\r\n        newAnnotation.isSaved = selectedAnnotation.isSaved;\r\n        let actionsBatch = [];\r\n        let action = null;\r\n        if (newAnnotation.isSaved) {\r\n            action = actions.updatedAnnotation;\r\n        } else {\r\n            action = actions.createdAnnotation;\r\n        }\r\n        actionsBatch.push(action(newAnnotation));\r\n        actionsBatch.push(\r\n            actions.removedTemporaryAnnotation(selectedAnnotation)\r\n        );\r\n        // TODO: figure out what needs changing to handle note annotations\r\n        actionsBatch.push(\r\n            actions.appliedAnnotation(\r\n                newAnnotation.uniqueId,\r\n                selectedWitnessData\r\n            )\r\n        );\r\n        if (newAnnotation.type === ANNOTATION_TYPES.variant) {\r\n            actionsBatch.push(\r\n                actions.changedActiveTextAnnotation(newAnnotation)\r\n            );\r\n        }\r\n        dispatch(batchActions(actionsBatch));\r\n    };\r\n\r\n    return {\r\n        ...stateProps,\r\n        ...ownProps,\r\n        closeAnnotation: () => {\r\n            const activeAnnotation = stateProps.activeAnnotation;\r\n            if (activeAnnotation) {\r\n                const dismissTextAnnotation =\r\n                    actions.changedActiveTextAnnotation(null);\r\n                dispatch(dismissTextAnnotation);\r\n            }\r\n        },\r\n        didSelectAnnotation: (annotation: Annotation) => {\r\n            let selectedAnnotation: Annotation | null = null;\r\n            if (annotation.id == BASE_ANNOTATION_ID) {\r\n                selectedAnnotation = stateProps.baseAnnotation;\r\n            } else {\r\n                selectedAnnotation =\r\n                    _.find(\r\n                        stateProps.availableAnnotations,\r\n                        (value) => value.uniqueId == annotation.uniqueId\r\n                    ) || null;\r\n            }\r\n            let actionsBatch = [];\r\n            let selectedWitness = stateProps.selectedWitness;\r\n            // let selectedWitnessData = reducers.getWitnessData(\r\n            //     state,\r\n            //     selectedWitness.id\r\n            // );\r\n            let selectedWitnessData = reducers.dataFromWitness(selectedWitness);\r\n\r\n            if (annotation.uniqueId != stateProps.activeAnnotation.uniqueId) {\r\n                if (selectedWitness.isWorking) {\r\n                    if (annotation.id != BASE_ANNOTATION_ID) {\r\n                        actionsBatch.push(\r\n                            actions.appliedAnnotation(\r\n                                selectedAnnotation.uniqueId,\r\n                                selectedWitnessData\r\n                            )\r\n                        );\r\n                    }\r\n                    if (stateProps.activeAnnotation.id != BASE_ANNOTATION_ID) {\r\n                        actionsBatch.push(\r\n                            actions.removedAppliedAnnotation(\r\n                                stateProps.activeAnnotation.uniqueId,\r\n                                selectedWitnessData\r\n                            )\r\n                        );\r\n                    }\r\n                } else {\r\n                    if (\r\n                        stateProps.activeAnnotation.creatorWitness.id ===\r\n                        selectedWitness.id\r\n                    ) {\r\n                        // Replacing a default annotation\r\n\r\n                        // Currently selected annotation is a default\r\n                        // annotation. So need to remove that then\r\n                        // apply the newly selected annotation.\r\n\r\n                        actionsBatch.push(\r\n                            actions.removedDefaultAnnotation(\r\n                                stateProps.activeAnnotation.uniqueId,\r\n                                selectedWitnessData\r\n                            )\r\n                        );\r\n\r\n                        if (selectedAnnotation.id !== BASE_ANNOTATION_ID) {\r\n                            actionsBatch.push(\r\n                                actions.appliedAnnotation(\r\n                                    selectedAnnotation.uniqueId,\r\n                                    selectedWitnessData\r\n                                )\r\n                            );\r\n                        }\r\n                    } else {\r\n                        if (\r\n                            selectedAnnotation.creatorWitness.id ===\r\n                            selectedWitness.id\r\n                        ) {\r\n                            actionsBatch.push(\r\n                                actions.appliedDefaultAnnotation(\r\n                                    selectedAnnotation.uniqueId,\r\n                                    selectedWitnessData\r\n                                )\r\n                            );\r\n                        } else if (\r\n                            selectedAnnotation.id !== BASE_ANNOTATION_ID\r\n                        ) {\r\n                            actionsBatch.push(\r\n                                actions.appliedAnnotation(\r\n                                    selectedAnnotation.uniqueId,\r\n                                    selectedWitnessData\r\n                                )\r\n                            );\r\n                        }\r\n\r\n                        if (\r\n                            stateProps.activeAnnotation.id !==\r\n                            BASE_ANNOTATION_ID\r\n                        ) {\r\n                            actionsBatch.push(\r\n                                actions.removedAppliedAnnotation(\r\n                                    stateProps.activeAnnotation.uniqueId,\r\n                                    selectedWitnessData\r\n                                )\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                actionsBatch.push(\r\n                    actions.changedActiveTextAnnotation(selectedAnnotation)\r\n                );\r\n\r\n                dispatch(batchActions(actionsBatch));\r\n            }\r\n        },\r\n        editAnnotation: (selectedAnnotation: Annotation) => {\r\n            const basedOn =\r\n                selectedAnnotation.isWorkingAnnotation ||\r\n                selectedAnnotation.userCreated ||\r\n                selectedAnnotation.id === BASE_ANNOTATION_ID\r\n                    ? null\r\n                    : selectedAnnotation;\r\n            const temporaryAnnotation = new TemporaryAnnotation(\r\n                basedOn,\r\n                selectedAnnotation.witness,\r\n                selectedAnnotation.start,\r\n                selectedAnnotation.length,\r\n                selectedAnnotation.content,\r\n                selectedAnnotation.type,\r\n                stateProps.selectedWitness,\r\n                stateProps.user\r\n            );\r\n            if (selectedAnnotation.userCreated) {\r\n                // user annotations are updated\r\n                temporaryAnnotation.uniqueId = selectedAnnotation.uniqueId;\r\n                temporaryAnnotation.isSaved = selectedAnnotation.isSaved;\r\n            }\r\n\r\n            dispatch(\r\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\r\n            );\r\n        },\r\n        saveAnnotation: saveAnnotation,\r\n        cancelEditAnnotation: (selectedAnnotation: TemporaryAnnotation) => {\r\n            if (!selectedAnnotation.isTemporary) {\r\n                console.warn(\r\n                    \"Tried to call cancelEditAnnotation on a non-temporary annotation: %o\",\r\n                    selectedAnnotation\r\n                );\r\n                return;\r\n            }\r\n\r\n            const cancelAction =\r\n                actions.removedTemporaryAnnotation(selectedAnnotation);\r\n            dispatch(cancelAction);\r\n        },\r\n        deleteAnnotation: (annotation: Annotation) => {\r\n            let selectedWitness = stateProps.selectedWitness;\r\n            let selectedWitnessData = reducers.dataFromWitness(selectedWitness);\r\n            let actionsBatch = [];\r\n            if (annotation.userCreated) {\r\n                const deleteAction = actions.deletedAnnotation(\r\n                    annotation,\r\n                    selectedWitness\r\n                );\r\n                const removeAppliedAction = actions.removedAppliedAnnotation(\r\n                    annotation.uniqueId,\r\n                    selectedWitnessData\r\n                );\r\n                actionsBatch = [deleteAction, removeAppliedAction];\r\n            } else {\r\n                // Assume this is a default annotation that was\r\n                // automatically imported from external data\r\n                const removeDefaultAnnotation =\r\n                    actions.removedDefaultAnnotation(\r\n                        annotation.uniqueId,\r\n                        selectedWitnessData\r\n                    );\r\n                actionsBatch = [removeDefaultAnnotation];\r\n            }\r\n\r\n            if (stateProps.activeAnnotation.uniqueId === annotation.uniqueId) {\r\n                actionsBatch.push(actions.changedActiveTextAnnotation(null));\r\n            }\r\n\r\n            dispatch(batchActions(actionsBatch));\r\n        },\r\n        addNote: () => {\r\n            const activeAnnotation = ownProps.activeAnnotation;\r\n            const temporaryAnnotation = new TemporaryAnnotation(\r\n                null,\r\n                activeAnnotation.witness,\r\n                activeAnnotation.start,\r\n                activeAnnotation.length,\r\n                \"\",\r\n                ANNOTATION_TYPES.note,\r\n                stateProps.selectedWitness,\r\n                stateProps.user\r\n            );\r\n\r\n            dispatch(\r\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\r\n            );\r\n        },\r\n        editNote: (note: Annotation) => {\r\n            const temporaryAnnotation = new TemporaryAnnotation(\r\n                note,\r\n                note.witness,\r\n                note.start,\r\n                note.length,\r\n                note.content,\r\n                ANNOTATION_TYPES.note,\r\n                stateProps.selectedWitness,\r\n                stateProps.user\r\n            );\r\n\r\n            dispatch(\r\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\r\n            );\r\n        },\r\n        addPageBreak: addBreak(ANNOTATION_TYPES.pageBreak),\r\n        addLineBreak: addBreak(ANNOTATION_TYPES.lineBreak),\r\n        addQuestion: () => {\r\n            const activeAnnotation = ownProps.activeAnnotation;\r\n            const temporaryAnnotation = new TemporaryAnnotation(\r\n                null,\r\n                activeAnnotation.witness,\r\n                activeAnnotation.start,\r\n                activeAnnotation.length,\r\n                \"\",\r\n                ANNOTATION_TYPES.question,\r\n                stateProps.selectedWitness,\r\n                stateProps.user\r\n            );\r\n\r\n            dispatch(\r\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\r\n            );\r\n        },\r\n        saveQuestion: (\r\n            question: TemporaryAnnotation,\r\n            title: string,\r\n            content: string\r\n        ) => {\r\n            let [start, end] =\r\n                ownProps.annotatedText.getPositionOfAnnotation(question);\r\n\r\n            const questionQuoteText = ReactDOMServer.renderToStaticMarkup(\r\n                stateProps.questionQuote\r\n            );\r\n            let questionText = questionQuoteText + content;\r\n\r\n            saveAnnotation(question, content);\r\n            const createdQuestionAction = actions.createdQuestion(\r\n                question,\r\n                title,\r\n                questionText\r\n            );\r\n            dispatch(createdQuestionAction);\r\n        },\r\n    };\r\n};\r\n\r\nconst AnnotationControlsContainer = connect(\r\n    mapStateToProps,\r\n    null,\r\n    mergeProps\r\n)(AnnotationControls);\r\n\r\nexport default AnnotationControlsContainer;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"header\":\"AnnotationControlsHeader---header\",\"Anotation_closeBtn\":\"AnnotationControlsHeader---Anotation_closeBtn\",\"edit\":\"AnnotationControlsHeader---edit\"};","// @flow\r\nimport React from \"react\";\r\nimport Button from \"components/UI/Button\";\r\nimport styles from \"./AnnotationControlsHeader.css\";\r\nimport PageBreakIcon from \"images/page_break_icon.svg\";\r\nimport NoteIcon from \"images/note.svg\";\r\nimport QuestionIcon from \"images/question_answer.svg\";\r\nimport ApplyTooltip from \"../UI/ApplyTooltip\";\r\nimport PencilAltIcon from \"images/PencilAltIcon.svg\";\r\ntype Props = {\r\n    addPageBreak: null | (() => void),\r\n    addLineBreak: null | (() => void),\r\n    addNote: null | (() => void),\r\n    addQuestion: null | (() => void),\r\n    closeAnnotation: null | (() => void),\r\n    editAnnotationHandler: null | (() => void),\r\n    userLoggedIn: Boolean,\r\n};\r\nconst ICON_SIZE = 15;\r\nclass AnnotationControlsHeader extends React.Component<Props> {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    render() {\r\n        const allowPageBreak = this.props.addPageBreak != null;\r\n        const allowLineBreak = this.props.addLineBreak != null;\r\n        return (\r\n            <>\r\n                <div className={styles.header}>\r\n                    <Button\r\n                        noBezel={true}\r\n                        icon={\r\n                            <NoteIcon\r\n                                width={ICON_SIZE}\r\n                                height={ICON_SIZE}\r\n                                style={{ fill: \"#fff\" }}\r\n                            />\r\n                        }\r\n                        backgroundColor=\"transparent\"\r\n                        // accessoryType={this.props.addNote ? \"ADD\" : null}\r\n                        onClick={this.props.addNote}\r\n                        disabled={this.props.addNote ? false : true}\r\n                        align=\"center\"\r\n                        tooltipTitle=\"Note\"\r\n                    />\r\n                    <Button\r\n                        noBezel={true}\r\n                        icon={\r\n                            <QuestionIcon\r\n                                width={ICON_SIZE}\r\n                                height={ICON_SIZE}\r\n                                style={{ fill: \"#fff\" }}\r\n                            />\r\n                        }\r\n                        // accessoryType={this.props.addQuestion ? \"ADD\" : null}\r\n                        onClick={this.props.addQuestion}\r\n                        disabled={this.props.addQuestion ? false : true}\r\n                        align=\"left\"\r\n                        backgroundColor=\"transparent\"\r\n                        tooltipTitle=\"Question\"\r\n                    />\r\n                    <Button\r\n                        noBezel={true}\r\n                        color=\"#fff\"\r\n                        fontSize={`${ICON_SIZE}px`}\r\n                        icon=\"&#182;\"\r\n                        // accessoryType={allowLineBreak ? \"ADD\" : null}\r\n                        onClick={this.props.addLineBreak}\r\n                        disabled={!allowLineBreak}\r\n                        align=\"left\"\r\n                        backgroundColor=\"transparent\"\r\n                        tooltipTitle=\"LineBreak\"\r\n                    />\r\n                    <Button\r\n                        noBezel={true}\r\n                        icon={\r\n                            <PageBreakIcon\r\n                                width={ICON_SIZE}\r\n                                height={ICON_SIZE}\r\n                                style={{ fill: \"#fff\" }}\r\n                            />\r\n                        }\r\n                        // accessoryType={allowPageBreak ? \"ADD\" : null}\r\n                        onClick={this.props.addPageBreak}\r\n                        disabled={!allowPageBreak}\r\n                        align=\"left\"\r\n                        backgroundColor=\"transparent\"\r\n                        tooltipTitle=\"PageBreak\"\r\n                    />\r\n\r\n                    <Button\r\n                        onClick={this.props.editAnnotationHandler}\r\n                        // className={styles.edit}\r\n                        backgroundColor=\"transparent\"\r\n                        icon={\r\n                            <PencilAltIcon\r\n                                width={ICON_SIZE}\r\n                                height={ICON_SIZE}\r\n                                style={{ fill: \"#fff\" }}\r\n                            />\r\n                        }\r\n                        tooltipTitle=\"Edit\"\r\n                    ></Button>\r\n                </div>\r\n                {/* <div\r\n                    onClick={() => this.props.closeAnnotation()}\r\n                    className={styles.Anotation_closeBtn}\r\n                >\r\n                    x\r\n                </div> */}\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nexport default AnnotationControlsHeader;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"heading\":\"AnnotationControlsHeading---heading\",\"title\":\"AnnotationControlsHeading---title\",\"button\":\"AnnotationControlsHeading---button\"};","import React from \"react\";\r\nimport { FormattedMessage } from \"react-intl\";\r\nimport { injectIntl } from \"react-intl\";\r\nimport styles from \"./AnnotationControlsHeading.css\";\r\nimport AddButton from \"./AddButton\";\r\n\r\ntype Props = {\r\n    titleId: string,\r\n    buttonOnClick?: () => void,\r\n    buttonTitleId?: string,\r\n    intl: { formatMessage: ({ [id: string]: string }) => string }\r\n};\r\n\r\nclass AnnotationControlsHeading extends React.Component<Props> {\r\n    render() {\r\n        let button = null;\r\n        if (this.props.buttonOnClick) {\r\n            const title = this.props.buttonTitleId\r\n                ? this.props.intl.formatMessage({\r\n                      id: this.props.buttonTitleId\r\n                  })\r\n                : \"\";\r\n            button = (\r\n                <AddButton title={title} onClick={this.props.buttonOnClick} />\r\n            );\r\n        }\r\n        return (\r\n            <h3 className={styles.heading}>\r\n                <span className={styles.title}>\r\n                    <FormattedMessage id={this.props.titleId} />\r\n                </span>\r\n                {button && <div className={styles.button}>{button}</div>}\r\n            </h3>\r\n        );\r\n    }\r\n}\r\n\r\nexport default injectIntl(AnnotationControlsHeading);\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"annotationDetail\":\"AnnotationDetail---annotationDetail\",\"active\":\"AnnotationDetail---active\",\"annotationHeader\":\"AnnotationDetail---annotationHeader\",\"activeIcon\":\"AnnotationDetail---activeIcon\",\"editing\":\"AnnotationDetail---editing\",\"actionButtons\":\"AnnotationDetail---actionButtons\",\"edit\":\"AnnotationDetail---edit\",\"editImage\":\"AnnotationDetail---editImage\",\"save\":\"AnnotationDetail---save\",\"cancel\":\"AnnotationDetail---cancel\"};","// @flow\r\nimport React, { useState } from \"react\";\r\nimport classnames from \"classnames\";\r\nimport { FormattedMessage } from \"react-intl\";\r\nimport styles from \"./AnnotationDetail.css\";\r\nimport type { AnnotationData } from \"api\";\r\nimport CheckIcon from \"images/check_circle.svg\";\r\nimport colours from \"css/colour.css\";\r\nimport ApplyTooltip from \"../UI/ApplyTooltip\";\r\nexport type Props = {\r\n    annotationData: AnnotationData,\r\n    isActive: boolean,\r\n    selectAnnotationHandler: () => void,\r\n    isLoggedIn: boolean,\r\n    editAnnotationHandler: () => void,\r\n    fontSize: Number,\r\n    isWorkingSection: boolean,\r\n};\r\nconst MAXIMUM_TEXT_LENGTH = 250;\r\n\r\nconst AnnotationDetail = (props: Props) => {\r\n    const [imageUrl, setImageUrl] = useState(null);\r\n\r\n    function longest_str_in_array(arra) {\r\n        var max_str = arra[0].length;\r\n        var ans = arra[0].length;\r\n        for (var i = 0; i < arra.length; i++) {\r\n            var maxi = arra[i].length;\r\n            if (maxi > max_str) {\r\n                ans = arra[i].length;\r\n                max_str = maxi;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n    function mergeArray(arr) {\r\n        var textCount = arr.length;\r\n        var maxPerLine = 55;\r\n\r\n        for (\r\n            var i = 0;\r\n            i < Math.ceil(arr.join().length / maxPerLine) + 1;\r\n            i++\r\n        ) {\r\n            if (arr[i] && arr[i + 1] && arr[i].length < maxPerLine) {\r\n                arr[i] = arr[i] + \" \" + arr[i + 1];\r\n                arr.splice(i + 1, 1);\r\n                mergeArray(arr);\r\n            } else if (arr[i] && arr[i + 1] && arr[i].length > maxPerLine) {\r\n                // code to cut selected text should be here\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    let desc = (\r\n        <p>\r\n            &lt;\r\n            <FormattedMessage id=\"annotation.delete\" />\r\n            &gt;\r\n        </p>\r\n    );\r\n\r\n    let content = props.annotationData.content;\r\n\r\n    if (content.trim() !== \"\") {\r\n        if (content.length > MAXIMUM_TEXT_LENGTH) {\r\n            content = content.substr(0, MAXIMUM_TEXT_LENGTH) + \"…\";\r\n        }\r\n        // content variable is the selected trimmed context\r\n        desc = <p>{content}</p>;\r\n    }\r\n\r\n    let classes = [styles.annotationDetail];\r\n\r\n    if (props.isActive) {\r\n        classes.push(styles.active);\r\n    }\r\n\r\n    let className = classnames(...classes);\r\n    return (\r\n        <div className={className} onClick={props.selectAnnotationHandler}>\r\n            <div className={styles.annotationHeader}>\r\n                {props.isActive && (\r\n                    <div className={styles.activeIcon}>\r\n                        <CheckIcon\r\n                            style={{ fill: colours.activeButton }}\r\n                            width={15}\r\n                            height={15}\r\n                        />\r\n                    </div>\r\n                )}\r\n                <h3>{props.annotationData.name}</h3>\r\n                {props.isLoggedIn && props.isActive && (\r\n                    <button\r\n                        style={{ display: \"none\" }}\r\n                        className={styles.edit}\r\n                        onClick={props.editAnnotationHandler}\r\n                        id=\"editBtn\"\r\n                    ></button>\r\n                )}\r\n            </div>\r\n\r\n            {!props.isWorkingSection && desc}\r\n\r\n            {/* {props.isWorkingSection  && <ShareButton props={props}/>} */}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default AnnotationDetail;\r\n","// @flow\r\nimport React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport { FormattedMessage } from \"react-intl\";\r\nimport styles from \"./AnnotationDetail.css\";\r\nimport type { Props as AnnotationDetailProps } from \"./AnnotationDetail\";\r\n\r\nexport type Props = AnnotationDetailProps & {\r\n    saveAnnotationHandler: (text: string) => void,\r\n    cancelAnnotationHandler: () => void,\r\n};\r\n\r\nconst AnnotationDetailEdit = (props: Props) => {\r\n    let content = props.annotationData.content;\r\n    let classes = [styles.annotationDetail];\r\n    let textarea = null;\r\n\r\n    if (props.isActive) {\r\n        classes.push(styles.active);\r\n    }\r\n    let auto_grow = (element) => {\r\n        textarea.style.height = \"5px\";\r\n        textarea.style.height = textarea.scrollHeight + \"px\";\r\n    };\r\n    let className = classnames(...classes);\r\n    return (\r\n        <div className={className}>\r\n            <h3>{props.annotationData.name}</h3>\r\n\r\n            <div className={styles.editing}>\r\n                <textarea\r\n                    defaultValue={content}\r\n                    autoFocus={true}\r\n                    onInput={auto_grow}\r\n                    ref={(ta) => (textarea = ta)}\r\n                />\r\n                <div className={styles.actionButtons}>\r\n                    <div\r\n                        className={styles.save}\r\n                        onClick={() => {\r\n                            if (textarea) {\r\n                                props.saveAnnotationHandler(textarea.value);\r\n                            }\r\n                        }}\r\n                    >\r\n                        <FormattedMessage id=\"annotation.save\" />\r\n                    </div>\r\n                    <div\r\n                        className={styles.cancel}\r\n                        onClick={props.cancelAnnotationHandler}\r\n                    >\r\n                        <FormattedMessage id=\"annotation.cancel\" />\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default AnnotationDetailEdit;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"name\":\"AnswerView---name\",\"answer\":\"AnswerView---answer\"};","import React from \"react\";\r\nimport styles from \"./AnswerView.css\";\r\nimport controlStyles from \"./AnnotationControls.css\";\r\nimport buttonStyles from \"./Button.css\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport Answer from \"lib/Answer\";\r\nimport { FormattedMessage, FormattedDate } from \"react-intl\";\r\nimport classnames from \"classnames\";\r\n\r\ntype Props = {\r\n    answer: Answer\r\n};\r\n\r\nexport default class AnswerView extends React.Component<Props> {\r\n    render() {\r\n        return (\r\n            <div className={styles.answer}>\r\n                <p\r\n                    className={controlStyles.text}\r\n                    dangerouslySetInnerHTML={{\r\n                        __html: this.props.answer.content\r\n                    }}\r\n                />\r\n                <p className={controlStyles.subTitle}>\r\n                    <FormattedMessage id=\"question.answeredBy\" />{\" \"}\r\n                    {this.props.answer.name},{\" \"}\r\n                    <FormattedDate value={this.props.answer.created} />\r\n                </p>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"save\":\"Button---save\",\"cancel\":\"Button---cancel\",\"buttonContainer\":\"Button---buttonContainer\"};","import React from \"react\";\r\nimport EditIcon from \"@mui/icons-material/Edit\";\r\nimport { Tooltip } from \"@mui/material\";\r\nimport MuiToggleButton from \"@mui/material/ToggleButton\";\r\nimport { styled, createTheme, ThemeProvider } from \"@mui/material/styles\";\r\n\r\nconst ToggleButton = styled(MuiToggleButton)(({ selectedcolor }) => ({\r\n    \"&.Mui-selected, &.Mui-selected:hover\": {\r\n        color: \"white\",\r\n        backgroundColor: selectedcolor,\r\n    },\r\n}));\r\nconst theme = createTheme({\r\n    palette: {\r\n        text: {\r\n            primary: \"#00398e\",\r\n        },\r\n    },\r\n});\r\n\r\nfunction Annotate(props) {\r\n    return (\r\n        <ThemeProvider theme={theme}>\r\n            <ToggleButton\r\n                value=\"Annotate\"\r\n                selected={props.isAnnotating}\r\n                style={{\r\n                    padding: 0,\r\n                    marginRight: 10,\r\n                }}\r\n                selectedcolor=\"#053982\"\r\n                onClick={() => props.changeIsAnnotating(!props.isAnnotating)}\r\n            >\r\n                <Tooltip title=\"Annotate\">\r\n                    <EditIcon />\r\n                </Tooltip>\r\n            </ToggleButton>\r\n        </ThemeProvider>\r\n    );\r\n}\r\n\r\nexport default Annotate;\r\n","// @flow\r\nimport * as React from \"react\";\r\nimport GraphemeSplitter from \"grapheme-splitter\";\r\nimport reactStringReplace from \"react-string-replace\";\r\n\r\ntype Props = {\r\n    string: string,\r\n    highlightClass: string,\r\n    stringClass?: string,\r\n    searchTerm?: string\r\n};\r\n\r\nexport default class HighlightedString extends React.Component<Props> {\r\n    constructor(props: Props) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        const string = this.props.string;\r\n        let nameHtml = string;\r\n        let stringClass = this.props.stringClass || \"\";\r\n        if (this.props.searchTerm) {\r\n            const searchTerm = this.props.searchTerm;\r\n            const splitter = new GraphemeSplitter();\r\n            const graphemes = splitter.splitGraphemes(string);\r\n            const start = string.indexOf(searchTerm);\r\n            const end = start + searchTerm.length;\r\n            let position = 0;\r\n            let foundGraphemes = \"\";\r\n            if (start > -1) {\r\n                for (let i = 0; i < graphemes.length; i++) {\r\n                    let grapheme = graphemes[i];\r\n                    if (position >= start && position < end) {\r\n                        foundGraphemes += grapheme;\r\n                    }\r\n                    position += grapheme.length;\r\n                }\r\n            }\r\n            if (foundGraphemes.length > 0) {\r\n                nameHtml = reactStringReplace(\r\n                    string,\r\n                    foundGraphemes,\r\n                    (match, i) => (\r\n                        <span className={this.props.highlightClass} key={`highlight-${i}`}>\r\n                            {match}\r\n                        </span>\r\n                    )\r\n                );\r\n            }\r\n        }\r\n        return <span className={stringClass}>{nameHtml}</span>;\r\n    }\r\n}\r\n","import React, { useCallback, useEffect } from \"react\";\r\nimport RefreshIcon from \"@mui/icons-material/Refresh\";\r\nimport { Button } from \"@mui/material\";\r\nfunction Refresh({ isSecondWindowOpen }) {\r\n    const handleRefresh = useCallback(() => {\r\n        let updatelistBtn = document.getElementById(\"updateList\");\r\n        let updatelistBtn2 = document.getElementById(\"updateList2\");\r\n\r\n        if (updatelistBtn) updatelistBtn.click();\r\n        if (updatelistBtn2) updatelistBtn2.click();\r\n    }, [isSecondWindowOpen]);\r\n\r\n    useEffect(() => {\r\n        let timer = setTimeout(() => {\r\n            handleRefresh();\r\n        }, 500);\r\n        return () => clearTimeout(timer);\r\n    }, [isSecondWindowOpen]);\r\n\r\n    return (\r\n        <Button\r\n            variant=\"text\"\r\n            size=\"small\"\r\n            style={{ padding: 0, color: \"black\" }}\r\n            onClick={handleRefresh}\r\n        >\r\n            <RefreshIcon />\r\n        </Button>\r\n    );\r\n}\r\n\r\nexport default Refresh;\r\n","import React from \"react\";\r\nimport SearchIcon from \"@mui/icons-material/Search\";\r\nimport { Button } from \"@mui/material\";\r\n\r\nfunction Search({ handleWindowSearch }) {\r\n    return (\r\n        <Button\r\n            size=\"small\"\r\n            variant=\"text\"\r\n            onClick={handleWindowSearch}\r\n            style={{ padding: 0, color: \"black\" }}\r\n        >\r\n            <SearchIcon />\r\n        </Button>\r\n    );\r\n}\r\n\r\nexport default Search;\r\n","import React, { useRef } from \"react\";\r\nimport {\r\n    AutoSizer,\r\n    CellMeasurer,\r\n    CellMeasurerCache,\r\n    List,\r\n} from \"react-virtualized\";\r\nimport HighlightedString from \"./HighlightedString\";\r\nimport styles from \"./SearchStyle.css\";\r\n\r\nfunction SearchList(props) {\r\n    const { handleListItemClick, searchValue, results, selectedText } = props;\r\n    let listRef = useRef();\r\n    let cache = useRef(\r\n        new CellMeasurerCache({\r\n            fixedWidth: true,\r\n            defaultHeight: 100,\r\n        })\r\n    );\r\n    let rowRenderer = ({ key, index, parent, style }) => {\r\n        let result = results[index];\r\n        return (\r\n            <CellMeasurer\r\n                key={`listkeys2-${key}`}\r\n                cache={cache.current}\r\n                parent={parent}\r\n                columnIndex={0}\r\n                rowIndex={index}\r\n            >\r\n                <div style={style}>\r\n                    {results.length > 0 && (\r\n                        <div\r\n                            className={styles.searchListItem}\r\n                            onClick={() => handleListItemClick(result[0])}\r\n                        >\r\n                            <HighlightedString\r\n                                string={result[1]}\r\n                                highlightClass={styles.highlight}\r\n                                searchTerm={searchValue}\r\n                            />\r\n                        </div>\r\n                    )}\r\n                </div>\r\n            </CellMeasurer>\r\n        );\r\n    };\r\n\r\n    if (!results) return null;\r\n    return (\r\n        <>\r\n            <AutoSizer>\r\n                {({ height, width }) => (\r\n                    <List\r\n                        ref={listRef}\r\n                        height={height}\r\n                        rowCount={results?.length}\r\n                        rowHeight={cache.current.rowHeight}\r\n                        deferredMeasurementCache={cache.current}\r\n                        rowRenderer={rowRenderer}\r\n                        width={width}\r\n                        overscanRowCount={1}\r\n                    ></List>\r\n                )}\r\n            </AutoSizer>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default SearchList;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"highlight\":\"SearchStyle---highlight\",\"searchListItem\":\"SearchStyle---searchListItem\"};","import React, { useState } from \"react\";\r\nimport WrenchIcon from \"images/wrench.svg\";\r\nimport Slider from \"../../UI/Slider\";\r\nimport CheckIcon from \"@mui/icons-material/Check\";\r\n// import Slider from \"react-smooth-range-input\";\r\nimport {\r\n    Button,\r\n    MenuList,\r\n    MenuItem,\r\n    ClickAwayListener,\r\n    Grow,\r\n    Divider,\r\n    Typography,\r\n} from \"@mui/material\";\r\nfunction Settings(props) {\r\n    let [showOption, setShowOption] = useState(false);\r\n\r\n    const handleClick = () => {\r\n        setShowOption((prev) => !prev);\r\n    };\r\n    return (\r\n        <ClickAwayListener onClickAway={() => setShowOption(false)}>\r\n            <Button\r\n                onClick={handleClick}\r\n                size=\"small\"\r\n                variant=\"text\"\r\n                style={{ padding: 0, color: \"black\" }}\r\n            >\r\n                <WrenchIcon height={20} width={20} />\r\n\r\n                <Grow in={showOption}>\r\n                    <MenuList\r\n                        dense\r\n                        style={{\r\n                            position: \"absolute\",\r\n                            right: 0,\r\n                            zIndex: 2,\r\n                            top: 30,\r\n                            backgroundColor: \"#eee\",\r\n                        }}\r\n                    >\r\n                        <Slider\r\n                            max={20}\r\n                            min={7}\r\n                            initialvalue={props.textFontSize}\r\n                            changeSize={props.onChangedFontSize}\r\n                        />\r\n                        <Divider />\r\n                        <MenuItem onClick={() => props.onExport()}>\r\n                            <Typography variant=\"subtitle2\">\r\n                                Export Document\r\n                            </Typography>\r\n                        </MenuItem>\r\n                        <Divider />\r\n\r\n                        <MenuItem\r\n                            onClick={() =>\r\n                                props.onChangePanelLink(!props.isPanelLinked)\r\n                            }\r\n                        >\r\n                            {props.isPanelLinked && <CheckIcon />}\r\n                            <Typography variant=\"subtitle2\">\r\n                                link panels\r\n                            </Typography>\r\n                        </MenuItem>\r\n                    </MenuList>\r\n                </Grow>\r\n            </Button>\r\n        </ClickAwayListener>\r\n    );\r\n}\r\n\r\nexport default Settings;\r\n","import React, { useState, useRef } from \"react\";\r\nimport classnames from \"classnames\";\r\nimport ShareIcon from \"@mui/icons-material/Share\";\r\nimport {\r\n    Button,\r\n    Tooltip,\r\n    Fade,\r\n    ClickAwayListener,\r\n    Snackbar,\r\n    Alert,\r\n} from \"@mui/material\";\r\nimport ContentCopyIcon from \"@mui/icons-material/ContentCopy\";\r\nfunction Share(props) {\r\n    let [showShare, setShowShare] = useState(false);\r\n    let [open, setOpen] = useState(false);\r\n\r\n    const handleClose = (event, reason) => {\r\n        if (reason === \"clickaway\") {\r\n            return;\r\n        }\r\n\r\n        setOpen(false);\r\n    };\r\n    return (\r\n        <>\r\n            <ClickAwayListener onClickAway={() => setShowShare(false)}>\r\n                <Button\r\n                    size=\"small\"\r\n                    // ref={domNode3}\r\n                    variant=\"text\"\r\n                    style={{ padding: 0, color: \"black\" }}\r\n                    onClick={() => setShowShare((prev) => !prev)}\r\n                >\r\n                    <Tooltip title=\"Share\">\r\n                        <ShareIcon />\r\n                    </Tooltip>\r\n                    <ShareOption\r\n                        {...props}\r\n                        showShare={showShare}\r\n                        setOpen={setOpen}\r\n                    />\r\n                </Button>\r\n            </ClickAwayListener>\r\n            <Snackbar open={open} autoHideDuration={6000} onClose={handleClose}>\r\n                <Alert\r\n                    onClose={handleClose}\r\n                    severity=\"success\"\r\n                    sx={{ width: \"100%\" }}\r\n                >\r\n                    The Url Copied to Clipboard !\r\n                </Alert>\r\n            </Snackbar>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default Share;\r\n\r\nfunction ShareOption(props) {\r\n    const [coppied, setcoppied] = useState(false);\r\n    let textid = props.selectedText;\r\n    let textid2 = props.selectedText2;\r\n    let witnessid = props.selectedWitness;\r\n    let witnessid2 = props.selectedWitness2;\r\n    let url = \"\";\r\n    if (textid2 && witnessid2) {\r\n        url =\r\n            window.location.origin +\r\n            `/texts/${textid.id}/witnesses/${witnessid?.id}/texts2/${textid2.id}/witnesses2/${witnessid2.id}`;\r\n    } else {\r\n        url =\r\n            window.location.origin +\r\n            `/texts/${textid.id}/witnesses/${witnessid?.id}`;\r\n    }\r\n    const handleCopy = () => {\r\n        navigator.clipboard\r\n            .writeText(url)\r\n            .then(() => {\r\n                setcoppied(true);\r\n                setTimeout(() => {\r\n                    setcoppied(false);\r\n                }, 3000);\r\n            })\r\n            .catch((e) => console.log(e.message))\r\n            .finally(() => props.setOpen(true));\r\n    };\r\n\r\n    return (\r\n        <Fade in={props.showShare}>\r\n            <div\r\n                style={{\r\n                    position: \"absolute\",\r\n                    top: 30,\r\n                    background: \"white\",\r\n                    width: 240,\r\n                    right: 10,\r\n                    boxShadow: \"1px 1px 2px black\",\r\n                    zIndex: 9999,\r\n                    padding: 10,\r\n                    borderRadius: 10,\r\n                }}\r\n            >\r\n                <div style={{ textAlign: \"center\", marginBottom: 10 }}>\r\n                    {props.selectedText.name}\r\n                </div>\r\n                <div style={{ textAlign: \"center\", display: \"flex\", gap: 10 }}>\r\n                    <input type=\"text\" defaultValue={url} disabled={coppied} />\r\n                    <div\r\n                        onClick={handleCopy}\r\n                        style={{ color: coppied && \"green\" }}\r\n                    >\r\n                        <ContentCopyIcon />\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </Fade>\r\n    );\r\n}\r\n","import React, { useState, useEffect } from \"react\";\r\nimport { Button } from \"@mui/material\";\r\nimport MenuIcon from \"@mui/icons-material/Menu\";\r\nfunction TableOfContent(props) {\r\n    function handleClick() {\r\n        props.changeShowTableContent(!props.showTableContent);\r\n    }\r\n    return (\r\n        <React.Fragment key=\"right\">\r\n            <Button onClick={handleClick}>\r\n                <MenuIcon />\r\n            </Button>\r\n        </React.Fragment>\r\n    );\r\n}\r\n\r\nexport default TableOfContent;\r\n","import React from \"react\";\r\nimport VerticalSplitIcon from \"@mui/icons-material/VerticalSplit\";\r\nimport { styled, createTheme, ThemeProvider } from \"@mui/material/styles\";\r\nimport MuiToggleButton from \"@mui/material/ToggleButton\";\r\nimport { Tooltip } from \"@mui/material\";\r\n\r\nconst ToggleButton = styled(MuiToggleButton)(({ selectedcolor }) => ({\r\n    \"&.Mui-selected, &.Mui-selected:hover\": {\r\n        color: \"white\",\r\n        backgroundColor: selectedcolor,\r\n    },\r\n}));\r\nconst theme = createTheme({\r\n    palette: {\r\n        text: {\r\n            primary: \"#00398e\",\r\n        },\r\n    },\r\n});\r\n\r\nfunction WindowSplitter(props) {\r\n    let { isSecondWindowOpen, onChangeWindowOpen } = props;\r\n    return (\r\n        <ThemeProvider theme={theme}>\r\n            <ToggleButton\r\n                value=\"secondWindow\"\r\n                selected={isSecondWindowOpen}\r\n                onClick={() => {\r\n                    onChangeWindowOpen(!isSecondWindowOpen, 139);\r\n                }}\r\n                style={{\r\n                    padding: 0,\r\n                }}\r\n                selectedcolor=\"#053982\"\r\n            >\r\n                <Tooltip title=\"split panel\">\r\n                    <VerticalSplitIcon />\r\n                </Tooltip>\r\n            </ToggleButton>\r\n        </ThemeProvider>\r\n    );\r\n}\r\n\r\nexport default WindowSplitter;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"note\":\"Note---note\",\"header\":\"Note---header\",\"info\":\"Note---info\",\"content\":\"Note---content\",\"delete\":\"Note---delete\"};","import React from \"react\";\r\nimport styles from \"./Note.css\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport FormattedDate from \"react-intl\";\r\n\r\ntype Props = {\r\n    note: Annotation,\r\n    delete?: (note: Annotation) => void,\r\n    edit?: (note: Annotation) => void\r\n};\r\n\r\nexport default class Note extends React.Component<Props> {\r\n    delete() {\r\n        if (this.props.delete) {\r\n            this.props.delete(this.props.note);\r\n        }\r\n    }\r\n\r\n    edit() {\r\n        if (this.props.edit) {\r\n            this.props.edit(this.props.note);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className={styles.note}>\r\n                <div className={styles.header}>\r\n                    <h4 className={styles.info}>\r\n                        {this.props.note.creatorUser.name}\r\n                    </h4>\r\n                    {this.props.delete && (\r\n                        <div\r\n                            className={styles.delete}\r\n                            onClick={this.delete.bind(this)}\r\n                        >\r\n                            &times;\r\n                        </div>\r\n                    )}\r\n                </div>\r\n                <div className={styles.content} onClick={this.edit.bind(this)}>\r\n                    {this.props.note.content}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"editorContainer\":\"NoteEditor---editorContainer\",\"textEditor\":\"NoteEditor---textEditor\"};","//@flow\r\nimport React from \"react\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport styles from \"./NoteEditor.css\";\r\nimport buttonStyles from \"./Button.css\";\r\nimport { FormattedMessage } from \"react-intl\";\r\n\r\ntype Props = {\r\n    note: Annotation,\r\n    saveNote: (note: Annotation, content: string) => void,\r\n    cancel: () => void\r\n};\r\n\r\ntype State = {\r\n    content: string\r\n};\r\n\r\nexport default class NoteEditor extends React.Component<Props, State> {\r\n    textarea: HTMLTextAreaElement | null;\r\n\r\n    constructor(props: Props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            content: props.note.content\r\n        };\r\n    }\r\n\r\n    save() {\r\n        const content = this.textarea ? this.textarea.value : \"\";\r\n        this.props.saveNote(this.props.note, content);\r\n    }\r\n\r\n    cancel() {\r\n        this.props.cancel();\r\n    }\r\n\r\n    handleChange(e: Event) {\r\n        const content =\r\n            e.target instanceof HTMLTextAreaElement ? e.target.value : \"\";\r\n        this.setState((prevState, props) => {\r\n            return {\r\n                content: content\r\n            };\r\n        });\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className={styles.editorContainer}>\r\n                <textarea\r\n                    className={styles.textEditor}\r\n                    ref={(textarea: HTMLTextAreaElement | null) =>\r\n                        (this.textarea = textarea)\r\n                    }\r\n                    value={this.state.content}\r\n                    onChange={this.handleChange.bind(this)}\r\n                />\r\n                <div className={buttonStyles.buttonContainer}>\r\n                    <div\r\n                        className={buttonStyles.save}\r\n                        onClick={this.save.bind(this)}\r\n                    >\r\n                        <FormattedMessage id=\"annotation.save\" />\r\n                    </div>\r\n                    <div\r\n                        className={buttonStyles.cancel}\r\n                        onClick={this.cancel.bind(this)}\r\n                    >\r\n                        <FormattedMessage id=\"annotation.cancel\" />\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"editorContainer\":\"QuestionEditor---editorContainer\",\"textEditor\":\"QuestionEditor---textEditor\"};","import React from \"react\";\r\nimport styles from \"./QuestionEditor.css\";\r\nimport buttonStyles from \"./Button.css\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport { FormattedMessage } from \"react-intl\";\r\n\r\ntype Props = {\r\n    question: Annotation,\r\n    questionQuote: React.Element<typeof React.Component>,\r\n    defaultTitle: string,\r\n    saveQuestion: (\r\n        question: Annotation,\r\n        title: string,\r\n        content: string\r\n    ) => void,\r\n    cancel: () => void\r\n};\r\n\r\ntype State = {\r\n    content: string\r\n};\r\n\r\nexport default class QuestionEditor extends React.Component<Props> {\r\n    textarea: HTMLTextAreaElement | null;\r\n\r\n    constructor(props: Props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            content: props.question.content\r\n        };\r\n    }\r\n\r\n    save() {\r\n        const content = this.textarea ? this.textarea.value : \"\";\r\n\r\n        this.props.saveQuestion(\r\n            this.props.question,\r\n            this.props.defaultTitle,\r\n            content\r\n        );\r\n    }\r\n\r\n    cancel() {\r\n        this.props.cancel();\r\n    }\r\n\r\n    handleChange(e: Event) {\r\n        const content =\r\n            e.target instanceof HTMLTextAreaElement ? e.target.value : \"\";\r\n        this.setState((prevState, props) => {\r\n            return {\r\n                content: content\r\n            };\r\n        });\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className={styles.editorContainer}>\r\n                <div>{this.props.questionQuote}</div>\r\n                <textarea\r\n                    className={styles.textEditor}\r\n                    ref={(textarea: HTMLTextAreaElement | null) =>\r\n                        (this.textarea = textarea)\r\n                    }\r\n                    value={this.state.content}\r\n                    onChange={this.handleChange.bind(this)}\r\n                />\r\n                <div className={buttonStyles.buttonContainer}>\r\n                    <div\r\n                        className={buttonStyles.save}\r\n                        onClick={this.save.bind(this)}\r\n                    >\r\n                        <FormattedMessage id=\"annotation.save\" />\r\n                    </div>\r\n                    <div\r\n                        className={buttonStyles.cancel}\r\n                        onClick={this.cancel.bind(this)}\r\n                    >\r\n                        <FormattedMessage id=\"annotation.cancel\" />\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"question\":\"QuestionView---question\",\"threadLink\":\"QuestionView---threadLink\"};","import React from \"react\";\r\nimport styles from \"./QuestionView.css\";\r\nimport controlStyles from \"./AnnotationControls.css\";\r\nimport buttonStyles from \"./Button.css\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport Question from \"lib/Question\";\r\nimport AnswerView from \"./AnswerView\";\r\nimport { FormattedMessage, FormattedDate } from \"react-intl\";\r\nimport classnames from \"classnames\";\r\nimport { QUESTION_URL } from \"app_constants\";\r\n\r\ntype Props = {\r\n    question: Question\r\n};\r\n\r\nexport default class QuestionView extends React.Component<Props> {\r\n    render() {\r\n        const topicUrl = QUESTION_URL + this.props.question.topicId;\r\n        let answerViews = [];\r\n        let answers = this.props.question.answers;\r\n        console.log(answers);\r\n        for (let i = 0; i < answers.length; i++) {\r\n            const answer = answers[i];\r\n            answerViews.push(\r\n                <AnswerView answer={answer} key={\"answer_\" + answer.created} />\r\n            );\r\n        }\r\n        const name =\r\n            this.props.question.name.length > 0\r\n                ? this.props.question.name\r\n                : this.props.question.username;\r\n\r\n        return (\r\n            <div className={classnames(styles.question, controlStyles.padding)}>\r\n                <span\r\n                    className={classnames(\r\n                        styles.threadLink,\r\n                        controlStyles.text\r\n                    )}\r\n                >\r\n                    <a href={topicUrl} target=\"_blank\">\r\n                        <FormattedMessage id=\"question.viewThread\" />\r\n                    </a>\r\n                </span>\r\n                <p\r\n                    className={controlStyles.text}\r\n                    dangerouslySetInnerHTML={{\r\n                        __html: this.props.question.content\r\n                    }}\r\n                />\r\n                <p className={controlStyles.subTitle}>\r\n                    {name},{\" \"}\r\n                    <FormattedDate value={this.props.question.created} />\r\n                </p>\r\n                {answerViews}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"loading\":\"QuestionsLoading---loading\"};","import React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport styles from \"./QuestionsLoading.css\";\r\nimport controlStyles from \"./AnnotationControls.css\";\r\nimport buttonStyles from \"./Button.css\";\r\nimport { FormattedMessage } from \"react-intl\";\r\nimport Loader from \"react-loader\";\r\n\r\nexport default class QuestionsLoading extends React.Component<Props> {\r\n    render() {\r\n        return (\r\n            <div className={classnames(styles.loading, controlStyles.text)}>\r\n                <Loader\r\n                    loaded={false}\r\n                    scale={0.25}\r\n                    position=\"relative\"\r\n                    top=\"50%\"\r\n                    left=\"50%\"\r\n                    lines={9}\r\n                    width={8}\r\n                    length={8}\r\n                    radius={14}\r\n                />\r\n                Loading questions...\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"selectVersion\":\"SelectVersion---selectVersion\",\"selectEmpty\":\"SelectVersion---selectEmpty\",\"selectOptions\":\"SelectVersion---selectOptions\",\"styled-select\":\"SelectVersion---styled-select\"};","// @flow\r\nimport React, { useState, useEffect, memo } from \"react\";\r\nimport _ from \"lodash\";\r\nimport classnames from \"classnames\";\r\nimport { FormattedMessage, injectIntl } from \"react-intl\";\r\nimport styles from \"./SelectVersion.css\";\r\nimport Witness from \"lib/Witness\";\r\nimport { NativeSelect } from \"@mui/material\";\r\nimport { withStyles } from \"@mui/styles\";\r\nexport type Props = {\r\n    witnesses: Witness[],\r\n    activeWitness: Witness | null,\r\n    onSelectedWitness: (witness: Witness) => void,\r\n    user: {},\r\n};\r\n\r\nconst SelectVersion = (props: Props) => {\r\n    let witnesses = [];\r\n    let tabName = \"\";\r\n    let r = \"\";\r\n    const [temp, setTemp] = useState(1);\r\n    let classes = [];\r\n    if (props.witnesses && props.activeWitness) {\r\n        r = props.witnesses.findIndex((l) => l.id === props.activeWitness.id);\r\n        witnesses = props.witnesses.map((witness) => witness);\r\n        witnesses.sort((a, b) => {\r\n            if (a.isWorking) {\r\n                return -1;\r\n            }\r\n            if (b.isWorking) {\r\n                return 1;\r\n            }\r\n            if (a.isBase) {\r\n                return -1;\r\n            }\r\n            if (b.isBase) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n        witnesses = witnesses.sort((a, b) => a.id - b.id);\r\n    }\r\n\r\n    useEffect(() => {\r\n        if (!_.isEmpty(witnesses) && temp >= 0) {\r\n            props.onSelectedWitness(witnesses[temp]);\r\n        }\r\n    }, [temp]);\r\n    if (witnesses.length === 0) return null;\r\n\r\n    return (\r\n        <NativeSelect\r\n            onChange={(e) => setTemp(e.target.value)}\r\n            className={styles.selectVersion}\r\n            value={r}\r\n            label=\"Version\"\r\n            classes={{\r\n                root: styles.selectEmpty,\r\n                select: styles.selectOptions,\r\n            }}\r\n        >\r\n            {witnesses.map((witness, key) => {\r\n                if (witness.id === props.activeWitness.id)\r\n                    classes.push(styles.selected);\r\n                tabName = witness.source.name;\r\n\r\n                if (witness.isWorking) {\r\n                    tabName =\r\n                        props.intl.locale === \"en\"\r\n                            ? props.user?.name === \"User\"\r\n                                ? \"Working\"\r\n                                : \"My Edition\"\r\n                            : \"མཉམ་འབྲེལ་པར་མ།\";\r\n                }\r\n\r\n                return (\r\n                    <option\r\n                        key={`versionSelect-${key}`}\r\n                        value={key}\r\n                        className={classnames(classes)}\r\n                        styles={{ textAlign: \"center\" }}\r\n                    >\r\n                        {tabName}\r\n                    </option>\r\n                );\r\n            })}\r\n        </NativeSelect>\r\n    );\r\n};\r\n\r\nexport default memo(injectIntl(SelectVersion));\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"inlineWidth\":\"280px\",\"annotationControls\":\"SplitText---annotationControls\",\"annotationContent\":\"SplitText---annotationContent\",\"subTitle\":\"SplitText---subTitle\",\"title\":\"SplitText---title\",\"sectionHeading\":\"SplitText---sectionHeading\",\"text\":\"SplitText---text\",\"padding\":\"SplitText---padding\",\"arrowTop\":\"SplitText---arrowTop\",\"arrowLeft\":\"SplitText---arrowLeft\",\"arrowRight\":\"SplitText---arrowRight\",\"inline\":\"SplitText---inline\",\"arrow\":\"SplitText---arrow\",\"arrowDs\":\"SplitText---arrowDs\",\"nothingSelected\":\"SplitText---nothingSelected\",\"anonymousMessage\":\"SplitText---anonymousMessage\",\"noNotes\":\"SplitText---noNotes\",\"breakButtons\":\"SplitText---breakButtons\",\"splitText\":\"SplitText---splitText\",\"splitTextRowContent\":\"SplitText---splitTextRowContent\",\"splitTextRow\":\"SplitText---splitTextRow\",\"pechaImage\":\"SplitText---pechaImage\",\"controlsPlaceholder\":\"SplitText---controlsPlaceholder\",\"hide\":\"SplitText---hide\",\"pageNumber\":\"SplitText---pageNumber\",\"hightlighter\":\"SplitText---hightlighter\",\"pulse\":\"SplitText---pulse\"};","// @flow\r\nimport * as React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { AutoSizer } from \"react-virtualized/dist/es/AutoSizer\";\r\nimport { List } from \"react-virtualized/dist/es/List\";\r\nimport {\r\n    CellMeasurer,\r\n    CellMeasurerCache,\r\n} from \"react-virtualized/dist/es/CellMeasurer\";\r\nimport \"react-virtualized/styles.css\";\r\nimport Text, {\r\n    idForSegment,\r\n    idForDeletedSegment,\r\n    idForInsertion,\r\n    idForPageBreak,\r\n    idForLineBreak,\r\n} from \"./Text\";\r\nimport SplitText from \"lib/SplitText\";\r\nimport SegmentedText from \"lib/SegmentedText\";\r\nimport shallowEqual from \"lib/shallowEqual\";\r\nimport { CONTROLS_MARGIN_LEFT } from \"./AnnotationControls\";\r\nimport AnnotationControlsContainer from \"./AnnotationControlsContainer\";\r\nimport styles from \"./SplitText.css\";\r\nimport annotationControlsStyles from \"./AnnotationControls.css\";\r\nimport controlStyles from \"./AnnotationControls.css\";\r\nimport _ from \"lodash\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport Annotation, { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport Witness from \"lib/Witness\";\r\nimport GraphemeSplitter from \"grapheme-splitter\";\r\nimport { ClickAwayListener } from \"@mui/material\";\r\n\r\nconst MIN_SPACE_RIGHT =\r\n    parseInt(controlStyles.inlineWidth) + CONTROLS_MARGIN_LEFT;\r\n\r\nconst IMAGE_URL_PREFIX = \"//iiif.bdrc.io/\";\r\nconst IMAGE_URL_SUFFIX = \"/full/full/0/default.jpg\";\r\nconst IMAGE_START_PRE_KEY = \"bdrcimg_pre\";\r\nconst IMAGE_START_NUMBER_KEY = \"bdrcimg_number\";\r\nconst IMAGE_START_SUFFIX_KEY = \"bdrcimg_suffix\";\r\n\r\nlet _searchResultsCache: {\r\n    [splitTextUniqueId: string]: {\r\n        [searchTerm: string]: {\r\n            [index: number]: { [position: number]: [number, number] },\r\n        },\r\n    },\r\n} = {};\r\n\r\nexport type Props = {\r\n    textListVisible: boolean,\r\n    editMenuVisible: Boolean,\r\n    imagesBaseUrl: string,\r\n    splitText: SplitText,\r\n    didSelectSegmentIds: (segmentIds: string[]) => void,\r\n    limitWidth: boolean,\r\n    activeAnnotation: Annotation | null,\r\n    selectedAnnotatedSegments: Array<TextSegment | number>,\r\n    showImages: boolean,\r\n    annotationPositions: { [string]: Annotation[] },\r\n    annotations: Annotation[],\r\n    activeAnnotations: { [AnnotationUniqueId]: Annotation } | null,\r\n    selectedSegmentId: (segmentId: string) => void,\r\n    selectedWitness: Witness | null,\r\n    selectedSearchResult: {\r\n        textId: number,\r\n        start: number,\r\n        length: number,\r\n    } | null,\r\n    searchValue: string | null,\r\n    fontSize: number,\r\n    isSecondWindowOpen: Boolean,\r\n    changeScrollToId: () => void,\r\n    changeSyncIdOnClick: () => void,\r\n    closeAnnotation: () => void,\r\n    imageData: {},\r\n    isPanelLinked: Boolean,\r\n    isPanelVisible: Boolean,\r\n    textAlignment: {},\r\n    textAlignmentById: {},\r\n    selectedWindow: Boolean,\r\n    scrollToId: Number,\r\n    selectedTargetRange: [],\r\n    selectedSourceRange: [],\r\n    searchResults: [],\r\n    showTableContent: Boolean,\r\n    syncIdOnSearch: String,\r\n};\r\n\r\nexport default class SplitTextComponent extends React.PureComponent<Props> {\r\n    isSecondWindowOpen: Boolean;\r\n    list: List | null;\r\n    splitText: HTMLDivElement | null;\r\n    cache: CellMeasurerCache;\r\n    rowRenderer: (params: {\r\n        key: string,\r\n        index: number,\r\n        parent: {},\r\n        style: {},\r\n    }) => React.Element<CellMeasurer>;\r\n    resizeHandler: () => void;\r\n    selectionHandler: (e: Event) => void;\r\n    textListVisible: boolean;\r\n    editMenuVisible: Boolean;\r\n    activeSelection: Selection | null;\r\n    selectedNodes: Node[] | null;\r\n    // Whether the mouse button is down\r\n    _mouseDown: boolean;\r\n    _activeWitness: Witness | null;\r\n    _didSetInitialScrollPosition: boolean;\r\n    _filteredSelectedAnnotatedSegments: TextSegment[];\r\n    _modifyingSelection: boolean;\r\n    selectedTextIndex: number | null;\r\n    splitTextRect: ClientRect | null;\r\n    firstSelectedSegment: TextSegment | null;\r\n    selectedElementId: string | null;\r\n    selectedElementIds: string[] | null;\r\n    imageWidth: number | null;\r\n    imageHeight: number | null;\r\n    calculatedImageHeight: number | null;\r\n    changeScrollToId: () => void;\r\n    changeSyncIdOnClick: () => void;\r\n    wheelScrolling: () => void;\r\n    closeAnnotation: () => void;\r\n    textlines: Node[] | null;\r\n    jump: number;\r\n    isPanelLinked: Boolean;\r\n    splitTextRef;\r\n    textAlignmentById;\r\n    scrollEvent: () => void;\r\n    selectedWindow;\r\n    debouncedScroll;\r\n    targetId;\r\n    condition;\r\n    constructor(props: Props) {\r\n        super(props);\r\n        this.textAlignmentById = [];\r\n        this.childRef = React.createRef(\"0\");\r\n        this.list = null;\r\n        this.splitText = null;\r\n        this.cache = new CellMeasurerCache({\r\n            fixedWidth: true,\r\n        });\r\n        this.splitTextRef = React.createRef(null);\r\n        this.rowRenderer = this.rowRenderer.bind(this);\r\n        this.textListVisible = props.textListVisible;\r\n        this.editMenuVisible = props.editMenuVisible;\r\n        this.isPanelLinked = props.isPanelLinked;\r\n        this.activeSelection = null;\r\n        this.selectedNodes = null;\r\n        this._mouseDown = false;\r\n        this._activeWitness = null;\r\n        this._didSetInitialScrollPosition = false;\r\n        this._modifyingSelection = false;\r\n        this.imageHeight = null;\r\n        this.imageWidth = null;\r\n        this.calculatedImageHeight = null;\r\n        this.processProps(props);\r\n        this.changeScrollToId = props.changeScrollToId;\r\n        this.changeSyncIdOnClick = props.changeSyncIdOnClick;\r\n        this.closeAnnotation = props.closeAnnotation;\r\n        this.scrollJump = props.scrollJump;\r\n        this.textAlignmentById = [];\r\n        this.scrollEvent = this.scrollEvent.bind(this);\r\n        this.selectedWindow = props.selectedWindow;\r\n        this.condition = false;\r\n    }\r\n\r\n    scrollEvent(e) {\r\n        if (this.selectedWindow === 2) return null;\r\n        if (this.selectedWindow === 1 && this.isPanelLinked && this.condition) {\r\n            let list = [];\r\n            this.textAlignmentById.map((l) => {\r\n                let number = document.getElementById(\"s_\" + l.start);\r\n                if (number) {\r\n                    let position = number.getBoundingClientRect();\r\n                    if (position.top > 102) {\r\n                        list.push({\r\n                            id: l.id,\r\n                            start: l.start,\r\n                            target: l.TStart,\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n            if (!_.isEmpty(list)) {\r\n                if (this.selectedWindow === 1) {\r\n                    this.debouncedScroll(list);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    updateList(\r\n        resetCache: boolean = true,\r\n        resetRows: number | number[] | null = null\r\n    ) {\r\n        if (\r\n            // !this.props.showImages &&\r\n            !this.calculatedImageHeight &&\r\n            this.imageHeight &&\r\n            this.imageWidth\r\n        ) {\r\n            this.calculatedImageHeight = this.calculateImageHeight();\r\n        }\r\n        if (this.list) {\r\n            const list = this.list;\r\n            if (resetCache) {\r\n                if (resetRows !== null) {\r\n                    if (!Array.isArray(resetRows)) {\r\n                        this.cache.clear(resetRows);\r\n                    } else if (Array.isArray(resetRows)) {\r\n                        for (let i = 0; i < resetRows.length; i++) {\r\n                            let resetRow = resetRows[i];\r\n                            this.cache.clear(resetRow);\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.cache.clearAll();\r\n                    list.measureAllRows();\r\n                    list.recomputeRowHeights(0);\r\n                }\r\n            }\r\n            list.forceUpdateGrid();\r\n        }\r\n    }\r\n\r\n    mouseDown() {\r\n        this._mouseDown = true;\r\n    }\r\n\r\n    mouseUp() {\r\n        this._mouseDown = false;\r\n        if (this.activeSelection) {\r\n            let segmentIds = this.processSelection(this.activeSelection);\r\n            if (!segmentIds) {\r\n                segmentIds = [];\r\n            }\r\n            this.props.didSelectSegmentIds(segmentIds);\r\n            this.activeSelection = null;\r\n        }\r\n    }\r\n    handleSelection(e: Event) {\r\n        if (!this._modifyingSelection) {\r\n            this.activeSelection = document.getSelection();\r\n            if (!this._mouseDown) {\r\n                // sometimes, this gets called after the mouseDown event handler\r\n                this.mouseUp();\r\n            }\r\n        } else {\r\n            e.stopPropagation();\r\n            // Need to set this here. If set at callsite, the event will not\r\n            // have time to propagate.\r\n            this._modifyingSelection = false;\r\n        }\r\n    }\r\n\r\n    processSelection(selection: Selection): string[] | null {\r\n        if (\r\n            selection.rangeCount === 0 ||\r\n            selection.isCollapsed ||\r\n            selection.type === \"Caret\"\r\n        ) {\r\n            this.selectedNodes = null;\r\n            return null;\r\n        }\r\n\r\n        const range = selection.getRangeAt(0);\r\n        const start = range.startContainer;\r\n        const startSpan = this.getNodeSegmentSpan(start);\r\n        if (!(startSpan && startSpan.parentNode)) {\r\n            // If the selection is not a text segment, ignore.\r\n            // Assuming if the first node is a non-segment, they\r\n            // all are.\r\n            return null;\r\n        }\r\n\r\n        let nodes = this.getRangeNodes(range, startSpan.parentNode);\r\n        // Check if the selection starts after the end of a node, and\r\n        // if so remove that node.\r\n        if (nodes.length > 0) {\r\n            let firstNode = nodes[0];\r\n            if (range.startOffset === firstNode.textContent.length) {\r\n                nodes.shift();\r\n            }\r\n        }\r\n\r\n        const end = range.endContainer;\r\n        const endSpan = this.getNodeSegmentSpan(end);\r\n        if (!(endSpan && endSpan.parentNode)) {\r\n            return null;\r\n        }\r\n        if (endSpan && startSpan.parentNode !== endSpan.parentNode) {\r\n            // Selection is spanning Texts.\r\n            // We assume a selection can only run across a maximum\r\n            // of two Texts.\r\n            nodes = nodes.concat(this.getRangeNodes(range, endSpan.parentNode));\r\n        } else {\r\n            // Check if the selection ends before the start of a node, and\r\n            // if so remove that node.\r\n            if (range.endOffset === 0) {\r\n                nodes.pop();\r\n            }\r\n        }\r\n        this.selectedNodes = nodes;\r\n        let nodeIds = [];\r\n        nodes.reduce((accumulator: string[], current: Node) => {\r\n            if (current instanceof Element) {\r\n                accumulator.push(current.id);\r\n            }\r\n            return accumulator;\r\n        }, nodeIds);\r\n        return nodeIds;\r\n    }\r\n\r\n    getNodeSegmentSpan(node: Node): Element | null {\r\n        let currentNode = node;\r\n        let span = null;\r\n        const test = /^(i|s|ds)_/;\r\n        while (!span && currentNode.parentNode) {\r\n            if (currentNode instanceof Element && test.test(currentNode.id)) {\r\n                span = currentNode;\r\n            }\r\n            currentNode = currentNode.parentNode;\r\n        }\r\n\r\n        return span;\r\n    }\r\n\r\n    getRangeNodes(range: Range, parentNode: Node): Node[] {\r\n        let rangeSpans = [];\r\n        for (let i = 0, len = parentNode.childNodes.length; i < len; i++) {\r\n            const node = parentNode.childNodes[i];\r\n            // TODO: add polyfill for i.e.?\r\n            // e.g. https://gist.github.com/jonathansampson/6d09bd6d2e8c22c53868aec42e66b0f9\r\n            if (range.intersectsNode(node)) {\r\n                rangeSpans.push(node);\r\n            }\r\n        }\r\n        return rangeSpans;\r\n    }\r\n\r\n    getControlsMeasurements(props: Props): {\r\n        selectedTextIndex: number,\r\n        firstSelectedSegment: TextSegment,\r\n        selectedElementId: string,\r\n        splitTextRect: ClientRect,\r\n        selectedElementIds: string[],\r\n    } | null {\r\n        if (!this.splitText) {\r\n            return null;\r\n        }\r\n        let splitTextComponent = this.splitText;\r\n        let selectedTextIndex = null;\r\n        let firstSelectedSegment = null;\r\n        let selectedElementId = null;\r\n        let splitTextRect = null;\r\n        let segmentIdFunction: null | ((segment: TextSegment) => string) = null;\r\n        let selectedElementIds = [];\r\n        let startPos = 0;\r\n        if (props.activeAnnotation) {\r\n            let activeAnnotation = props.activeAnnotation;\r\n            [startPos] =\r\n                props.splitText.annotatedText.getPositionOfAnnotation(\r\n                    activeAnnotation\r\n                );\r\n            if (startPos === null) {\r\n                console.warn(\"No startPos in getControlsMeasurements\");\r\n                return null;\r\n            }\r\n            if (activeAnnotation.type === ANNOTATION_TYPES.pageBreak) {\r\n                startPos -= 1;\r\n            }\r\n            if (activeAnnotation.type === ANNOTATION_TYPES.lineBreak) {\r\n                startPos -= 1;\r\n            }\r\n\r\n            // Index of text containing end of annotation\r\n            let positionEnd = startPos + activeAnnotation.length;\r\n            if (activeAnnotation.length > 0) positionEnd -= 1;\r\n            selectedTextIndex =\r\n                props.splitText.getTextIndexOfPosition(positionEnd);\r\n            splitTextRect = splitTextComponent.getBoundingClientRect();\r\n        }\r\n        let selectedAnnotatedSegments = [];\r\n        if (\r\n            props.selectedAnnotatedSegments &&\r\n            props.selectedAnnotatedSegments.length > 0\r\n        ) {\r\n            selectedAnnotatedSegments = props.selectedAnnotatedSegments;\r\n            for (let i = 0; i < selectedAnnotatedSegments.length; i++) {\r\n                let segment = selectedAnnotatedSegments[i];\r\n                if (\r\n                    firstSelectedSegment === null &&\r\n                    segment instanceof TextSegment\r\n                ) {\r\n                    firstSelectedSegment = segment;\r\n                    break;\r\n                }\r\n            }\r\n            if (firstSelectedSegment) {\r\n                if (\r\n                    firstSelectedSegment.length === 0 &&\r\n                    props.activeAnnotation &&\r\n                    props.activeAnnotation.isInsertion\r\n                ) {\r\n                    selectedElementId = idForInsertion(firstSelectedSegment);\r\n                    segmentIdFunction = idForInsertion;\r\n                } else {\r\n                    selectedElementId = idForSegment(firstSelectedSegment);\r\n                    segmentIdFunction = idForSegment;\r\n                }\r\n            }\r\n        } else if (props.activeAnnotation) {\r\n            if (props.activeAnnotation.isDeletion) {\r\n                let segment = new TextSegment(startPos, \"\");\r\n                selectedElementId = idForDeletedSegment(segment);\r\n                segmentIdFunction = idForDeletedSegment;\r\n                firstSelectedSegment = segment;\r\n                selectedAnnotatedSegments = [firstSelectedSegment];\r\n            } else if (props.activeAnnotation.isInsertion) {\r\n                const [start] =\r\n                    props.splitText.annotatedText.getPositionOfAnnotation(\r\n                        props.activeAnnotation\r\n                    );\r\n                if (start) {\r\n                    let segment = new TextSegment(start, \"\");\r\n                    selectedElementId = idForInsertion(segment);\r\n                    segmentIdFunction = idForInsertion;\r\n                    firstSelectedSegment = segment;\r\n                    selectedAnnotatedSegments = [firstSelectedSegment];\r\n                }\r\n            } else if (\r\n                props.activeAnnotation.type === ANNOTATION_TYPES.pageBreak\r\n            ) {\r\n                let segment = new TextSegment(startPos + 1, \"\");\r\n                let prevSegment = new TextSegment(startPos, \"\");\r\n                selectedElementId = idForPageBreak(prevSegment);\r\n                firstSelectedSegment = segment;\r\n                selectedAnnotatedSegments = [segment];\r\n                selectedElementIds = [selectedElementId];\r\n            } else if (\r\n                props.activeAnnotation.type === ANNOTATION_TYPES.lineBreak\r\n            ) {\r\n                let segment = new TextSegment(startPos + 1, \"\");\r\n                let prevSegment = new TextSegment(startPos, \"\");\r\n                selectedElementId = idForLineBreak(prevSegment);\r\n                firstSelectedSegment = segment;\r\n                selectedAnnotatedSegments = [segment];\r\n                selectedElementIds = [selectedElementId];\r\n            }\r\n        }\r\n        if (segmentIdFunction) {\r\n            for (let i = 0; i < selectedAnnotatedSegments.length; i++) {\r\n                let segment = selectedAnnotatedSegments[i];\r\n                if (segment instanceof TextSegment) {\r\n                    const segmentId = segmentIdFunction(segment);\r\n                    selectedElementIds.push(segmentId);\r\n                }\r\n            }\r\n        }\r\n        if (\r\n            selectedTextIndex != null &&\r\n            firstSelectedSegment &&\r\n            selectedElementId &&\r\n            splitTextRect\r\n        ) {\r\n            return {\r\n                selectedTextIndex: selectedTextIndex,\r\n                firstSelectedSegment: firstSelectedSegment,\r\n                selectedElementId: selectedElementId,\r\n                splitTextRect: splitTextRect,\r\n                selectedElementIds: selectedElementIds,\r\n            };\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    shouldResetListCache(oldProps: Props, newProps: Props) {\r\n        let shouldReset = false;\r\n        if (\r\n            oldProps.showImages !== newProps.showImages ||\r\n            this.pageBreaksChanged(oldProps, newProps)\r\n        ) {\r\n            shouldReset = true;\r\n        }\r\n\r\n        return shouldReset;\r\n    }\r\n\r\n    pageBreaksChanged(oldProps: Props, newProps: Props) {\r\n        const oldTextBreaks = oldProps.splitText.getTextsFinalPositions();\r\n        const newTextBreaks = newProps.splitText.getTextsFinalPositions();\r\n\r\n        if (oldTextBreaks.length !== newTextBreaks.length) return true;\r\n\r\n        return JSON.stringify(oldTextBreaks) !== JSON.stringify(newTextBreaks);\r\n    }\r\n\r\n    lineBreaksChanges(oldProps: Props, newProps: Props) {\r\n        let oldActiveAnnotation = oldProps.activeAnnotation;\r\n        let newActiveAnnotation = newProps.activeAnnotation;\r\n        let hasChanged = false;\r\n\r\n        if (\r\n            oldActiveAnnotation &&\r\n            oldActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) &&\r\n            newProps.activeAnnotations &&\r\n            !newProps.activeAnnotations.hasOwnProperty(\r\n                oldActiveAnnotation.uniqueId\r\n            )\r\n        ) {\r\n            hasChanged = true;\r\n        }\r\n\r\n        if (\r\n            newActiveAnnotation &&\r\n            newActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) &&\r\n            oldProps.activeAnnotations &&\r\n            !oldProps.activeAnnotations.hasOwnProperty(\r\n                newActiveAnnotation.uniqueId\r\n            )\r\n        ) {\r\n            hasChanged = true;\r\n        }\r\n\r\n        return hasChanged;\r\n    }\r\n\r\n    selectedListRow(props: Props): number | null {\r\n        let row = null;\r\n        if (props.activeAnnotation) {\r\n            row = props.splitText.getTextIndexOfPosition(\r\n                props.activeAnnotation.start\r\n            );\r\n        }\r\n        return row;\r\n    }\r\n\r\n    processProps(props: Props) {\r\n        let changedWitness = false;\r\n        if (\r\n            !this.props.selectedWitness ||\r\n            (props.selectedWitness &&\r\n                props.selectedWitness.id !== this.props.selectedWitness.id)\r\n        ) {\r\n            changedWitness = true;\r\n            this._didSetInitialScrollPosition = false;\r\n        }\r\n\r\n        if (\r\n            props.selectedSearchResult &&\r\n            (!this.props.selectedSearchResult ||\r\n                props.selectedSearchResult.start !==\r\n                    this.props.selectedSearchResult.start ||\r\n                props.selectedSearchResult.textId !==\r\n                    this.props.selectedSearchResult.textId)\r\n        ) {\r\n            console.log(\"resetting scroll position from search result\");\r\n            this._didSetInitialScrollPosition = false;\r\n        }\r\n\r\n        // TODO: check if new selectedSearchResult and if so\r\n        // set this._didSetInitialScrollPosition = false\r\n\r\n        // make sure there's no numbers in selectedAnnotatedSegments\r\n        // as we want to pass it to Text which only expects TextSegments\r\n        this._filteredSelectedAnnotatedSegments =\r\n            props.selectedAnnotatedSegments.reduce(\r\n                (acc, current: TextSegment | number) => {\r\n                    if (current instanceof TextSegment) acc.push(current);\r\n                    return acc;\r\n                },\r\n                []\r\n            );\r\n\r\n        const controlsMeasurements = this.getControlsMeasurements(props);\r\n        if (controlsMeasurements) {\r\n            this.selectedTextIndex = controlsMeasurements.selectedTextIndex;\r\n            this.firstSelectedSegment =\r\n                controlsMeasurements.firstSelectedSegment;\r\n            this.splitTextRect = controlsMeasurements.splitTextRect;\r\n            this.selectedElementId = controlsMeasurements.selectedElementId;\r\n            this.selectedElementIds = controlsMeasurements.selectedElementIds;\r\n        }\r\n\r\n        if (\r\n            props.textListVisible !== this.textListVisible ||\r\n            props.editMenuVisible !== this.editMenuVisible\r\n        ) {\r\n            setTimeout(() => {\r\n                this.textListVisible = props.textListVisible;\r\n                this.editMenuVisible = props.editMenuVisible;\r\n                this.updateList(true);\r\n            }, 500);\r\n        } else {\r\n            if (changedWitness) {\r\n                this.updateList(true);\r\n            } else if (this.pageBreaksChanged(this.props, props)) {\r\n                let selectedRows = null;\r\n                let currentSelectedRow = this.selectedListRow(this.props);\r\n                let newSelectedRow = this.selectedListRow(props);\r\n                if (currentSelectedRow && newSelectedRow) {\r\n                    let firstChangedRow =\r\n                        currentSelectedRow > newSelectedRow\r\n                            ? newSelectedRow\r\n                            : currentSelectedRow;\r\n\r\n                    let splitRowTexts = this.props.splitText.texts;\r\n                    selectedRows = [];\r\n                    for (\r\n                        let i = firstChangedRow, len = splitRowTexts.length;\r\n                        i < len;\r\n                        i++\r\n                    ) {\r\n                        selectedRows.push(i);\r\n                    }\r\n                }\r\n                this.updateList(true, selectedRows);\r\n            } else if (this.lineBreaksChanges(this.props, props)) {\r\n                let selectedRow = this.selectedListRow(props);\r\n                if (!selectedRow)\r\n                    selectedRow = this.selectedListRow(this.props);\r\n                let splitRowTexts = this.props.splitText.texts;\r\n                let selectedRows = [];\r\n                if (selectedRow !== null) {\r\n                    for (\r\n                        let i = selectedRow, len = splitRowTexts.length;\r\n                        i < len;\r\n                        i++\r\n                    ) {\r\n                        selectedRows.push(i);\r\n                    }\r\n                    this.updateList(true, selectedRows);\r\n                }\r\n            } else if (this.props.fontSize !== props.fontSize) {\r\n                this.updateList(true);\r\n            } else if (\r\n                this.props.activeAnnotation &&\r\n                props.activeAnnotation &&\r\n                this.annotationsInSameLocation(\r\n                    this.props.activeAnnotation,\r\n                    props.activeAnnotation\r\n                )\r\n            ) {\r\n                this.updateList(true, this.selectedListRow(props));\r\n            } else {\r\n                this.updateList(this.shouldResetListCache(this.props, props));\r\n            }\r\n        }\r\n    }\r\n\r\n    annotationsInSameLocation(anno1: Annotation, anno2: Annotation): boolean {\r\n        if (anno1.start === anno2.start && anno1.length === anno2.length) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    UNSAFE_componentWillReceiveProps(props: Props) {\r\n        this.processProps(props);\r\n    }\r\n\r\n    componentDidMount() {\r\n        let list = this.list;\r\n        this.resizeHandler = _.throttle(() => {\r\n            this.calculatedImageHeight = null;\r\n            this.updateList();\r\n        }, 600).bind(this);\r\n        this.debouncedScroll = _.debounce((list) => {\r\n            this.changeScrollToId({ id: list[0].start, from: 1 });\r\n        }, 1000);\r\n\r\n        window.addEventListener(\"resize\", this.resizeHandler);\r\n\r\n        this.selectionHandler = _.debounce((e) => {\r\n            this.handleSelection(e);\r\n        }, 200).bind(this);\r\n\r\n        document.addEventListener(\"selectionchange\", this.selectionHandler);\r\n        document.addEventListener(\"mousedown\", this.mouseDown.bind(this), true);\r\n        document.addEventListener(\"mouseup\", this.mouseUp.bind(this), true);\r\n        this.processProps(this.props);\r\n        this.componentDidUpdate();\r\n        this.timer = setTimeout(() => {\r\n            this.resizeHandler();\r\n        }, 2000);\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        let Alignment = this.props.textAlignment;\r\n        this.condition =\r\n            Alignment?.source?.witness === this.props.selectedWitness.id;\r\n        let scrollToId = this.props.scrollToId;\r\n        let list = this.list;\r\n        // if (prevProps?.isSecondWindowOpen !== this.props?.isSecondWindowOpen) {\r\n        //     setTimeout(() => {\r\n        //         for (let i = 0; i < 2; i++) {\r\n        //             this.updateList(true);\r\n        //         }\r\n        //     }, 1000);\r\n        // }\r\n        let con =\r\n            prevProps?.searchResults !== this.props?.searchResults ||\r\n            prevProps?.syncIdOnSearch !== this.props?.syncIdOnSearch;\r\n\r\n        if (con && this.props.searchResults) {\r\n            let SearchSyncId = this.props.syncIdOnSearch || null;\r\n            if (SearchSyncId) {\r\n                let selectedTextIndex =\r\n                    this.props.splitText.getTextIndexOfPosition(SearchSyncId);\r\n                setTimeout(() => {\r\n                    list.scrollToRow(selectedTextIndex);\r\n                    setTimeout(() => {\r\n                        list.scrollToPosition(list.props.scrollTop - 300);\r\n                    }, 0);\r\n                }, 100);\r\n            }\r\n        }\r\n        this.textAlignmentById = this.props.textAlignmentById;\r\n        this.isPanelLinked = this.props.isPanelLinked;\r\n        this.selectedWindow = this.props.selectedWindow;\r\n        this.targetId = this.props.scrollToId;\r\n\r\n        if (this.selectedNodes && this.selectedNodes.length > 0) {\r\n            const selectedNodes = this.selectedNodes;\r\n            const selectedSegments = this.props.selectedAnnotatedSegments;\r\n            setTimeout(() => {\r\n                let selRange = document.createRange();\r\n                let startNode = selectedNodes[0];\r\n                let endNode = selectedNodes[selectedNodes.length - 1];\r\n                let lastSegment = selectedSegments[selectedSegments.length - 1];\r\n                if (lastSegment instanceof TextSegment) {\r\n                    let lastElement = document.getElementById(\r\n                        idForSegment(lastSegment)\r\n                    );\r\n                    if (lastElement) endNode = lastElement;\r\n                }\r\n\r\n                if (\r\n                    startNode instanceof Element &&\r\n                    endNode instanceof Element\r\n                ) {\r\n                    startNode = document.getElementById(startNode.id);\r\n                    endNode = document.getElementById(endNode.id);\r\n                    if (startNode && endNode) {\r\n                        selRange.setStart(startNode, 0);\r\n                        selRange.setEnd(endNode, endNode.childNodes.length);\r\n                        let sel = document.getSelection();\r\n                        if (sel) {\r\n                            this._modifyingSelection = true;\r\n                            sel.removeAllRanges();\r\n                            sel.addRange(selRange);\r\n                            this.selectedNodes = null;\r\n                        }\r\n                    }\r\n                }\r\n            }, 0);\r\n        }\r\n\r\n        if (!this._didSetInitialScrollPosition && this.list) {\r\n            const list = this.list;\r\n            if (\r\n                this.props.activeAnnotation ||\r\n                this.props.selectedSearchResult\r\n            ) {\r\n                let selectedTextIndex = this.getSelectedTextIndex();\r\n                setTimeout(() => {\r\n                    list.scrollToRow(selectedTextIndex);\r\n                    // scrollToRow often positions the annotation at the\r\n                    // bottom of the screen, so scroll up a bit\r\n                    setTimeout(() => {\r\n                        list.scrollToPosition(list.props.scrollTop - 300);\r\n                    }, 0);\r\n                }, 100);\r\n            }\r\n            this._didSetInitialScrollPosition = true;\r\n        }\r\n\r\n        if (\r\n            // this.selectedWindow === 2 &&\r\n            scrollToId.from == 2 &&\r\n            this.isPanelLinked &&\r\n            this.condition &&\r\n            scrollToId.id !== null\r\n        ) {\r\n            let list = this.list;\r\n            this.textAlignmentById = this.props.textAlignmentById || [];\r\n            this.splitText.style.scrollBehavior = \"smooth\";\r\n            if (Alignment && this.isPanelLinked) {\r\n                let req = this.textAlignmentById.find(\r\n                    (l) => l.TStart === scrollToId.id\r\n                );\r\n\r\n                let start = req?.start;\r\n                if (start !== null) {\r\n                    let selectedTextIndex =\r\n                        this.props.splitText.getTextIndexOfPosition(start);\r\n                    setTimeout(() => {\r\n                        list.scrollToRow(selectedTextIndex);\r\n\r\n                        setTimeout(() => {\r\n                            list.scrollToPosition(list.props.scrollTop - 300);\r\n                        }, 0);\r\n                    }, 100);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    componentWillUnmount() {\r\n        document.removeEventListener(\"mousedown\", this);\r\n        document.removeEventListener(\"mouseup\", this);\r\n        window.removeEventListener(\"resize\", this.resizeHandler);\r\n\r\n        document.removeEventListener(\"selectionchange\", this.selectionHandler);\r\n        clearTimeout(this.timer);\r\n    }\r\n\r\n    calculateImageHeight() {\r\n        let height = null;\r\n        if (this.imageHeight && this.imageWidth) {\r\n            const ratio = this.imageWidth / this.imageHeight;\r\n            const pechaImageClass = styles.pechaImage;\r\n            const pechaImageContainers =\r\n                document.getElementsByClassName(pechaImageClass);\r\n            if (pechaImageContainers.length > 0) {\r\n                let container = pechaImageContainers[0];\r\n                height = container.offsetWidth / ratio;\r\n            }\r\n        }\r\n        return height;\r\n    }\r\n\r\n    getSelectedTextIndex(): number {\r\n        let selectedTextIndex = 0;\r\n        let startPos = null;\r\n        if (this.props.activeAnnotation) {\r\n            [startPos] =\r\n                this.props.splitText.annotatedText.getPositionOfAnnotation(\r\n                    this.props.activeAnnotation\r\n                );\r\n        } else if (this.props.selectedSearchResult) {\r\n            let segment =\r\n                this.props.splitText.annotatedText.segmentAtOriginalPosition(\r\n                    this.props.selectedSearchResult.start\r\n                );\r\n            if (segment instanceof TextSegment) {\r\n                startPos = segment.start;\r\n            } else if (typeof segment === \"number\") {\r\n                startPos = segment;\r\n            }\r\n        }\r\n        if (startPos) {\r\n            selectedTextIndex =\r\n                this.props.splitText.getTextIndexOfPosition(startPos);\r\n        }\r\n        return selectedTextIndex;\r\n    }\r\n\r\n    getBaseAnnotation(annotation: Annotation): Annotation {\r\n        let [start] =\r\n            this.props.splitText.annotatedText.getPositionOfAnnotation(\r\n                annotation\r\n            );\r\n        if (start === null) start = 0;\r\n        return this.props.splitText.annotatedText.getBaseAnnotation(\r\n            start,\r\n            annotation.content.length\r\n        );\r\n    }\r\n\r\n    render() {\r\n        const props = this.props;\r\n        const rowRenderer = this.rowRenderer;\r\n        const cache = this.cache;\r\n        const key = props.selectedWitness ? props.selectedWitness.id : 0;\r\n\r\n        return (\r\n            <div\r\n                className={styles.splitText}\r\n                ref={(div) => (this.splitText = div)}\r\n                key={key}\r\n                style={{\r\n                    cursor: !this.props.isAnnotating ? \"pointer\" : \"text\",\r\n                }}\r\n            >\r\n                <button\r\n                    id=\"updateList\"\r\n                    style={{ display: \"none\" }}\r\n                    onClick={this.resizeHandler}\r\n                ></button>\r\n                <AutoSizer>\r\n                    {({ height, width }) => (\r\n                        <List\r\n                            ref={(list) => (this.list = list)}\r\n                            height={height}\r\n                            rowCount={props.splitText.texts.length}\r\n                            rowHeight={cache.rowHeight}\r\n                            rowRenderer={rowRenderer}\r\n                            width={width}\r\n                            overscanRowCount={1}\r\n                            deferredMeasurementCache={cache}\r\n                            onScroll={this.scrollEvent}\r\n                            scrollToAlignment=\"start\"\r\n                        ></List>\r\n                    )}\r\n                </AutoSizer>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    getImageUrl(pageIndex: number): string {\r\n        if (\r\n            !this.props.selectedWitness ||\r\n            !this.props.selectedWitness.properties\r\n        )\r\n            return \"\";\r\n        let witnessProperties = this.props.selectedWitness.properties;\r\n        let prefix = witnessProperties[IMAGE_START_PRE_KEY];\r\n        let start = witnessProperties[IMAGE_START_NUMBER_KEY];\r\n        let suffix = witnessProperties[IMAGE_START_SUFFIX_KEY];\r\n        let id = Number(start) + pageIndex;\r\n        return IMAGE_URL_PREFIX + prefix + id + \".\" + suffix + IMAGE_URL_SUFFIX;\r\n    }\r\n\r\n    getStringPositions(\r\n        text: SegmentedText,\r\n        string: string,\r\n        index: number\r\n    ): { [position: number]: [number, number] } {\r\n        const uniqueId = this.props.splitText.annotatedText.getUniqueId();\r\n\r\n        if (!_searchResultsCache.hasOwnProperty(uniqueId)) {\r\n            _searchResultsCache = {\r\n                [uniqueId]: {},\r\n            };\r\n        }\r\n\r\n        if (!_searchResultsCache[uniqueId].hasOwnProperty(string)) {\r\n            _searchResultsCache[uniqueId] = {\r\n                [string]: {},\r\n            };\r\n        }\r\n\r\n        if (_searchResultsCache[uniqueId][string].hasOwnProperty(index)) {\r\n            return _searchResultsCache[uniqueId][string][index];\r\n        }\r\n\r\n        const splitter = new GraphemeSplitter();\r\n        const content = text.getText();\r\n        const firstSegment = text.segments[0];\r\n        const startingPosition = firstSegment?.start;\r\n        let positions = [];\r\n        let position = content.indexOf(string);\r\n        while (position !== -1) {\r\n            positions.push(position);\r\n            position = content.indexOf(string, position + 1);\r\n        }\r\n\r\n        // Position needs to be position in complete text\r\n        let verifiedPositions: { [position: number]: [number, number] } = {};\r\n        if (positions.length > 0) {\r\n            const graphemes = splitter.splitGraphemes(content);\r\n            let position = 0;\r\n            let activePosition = null;\r\n            for (let i = 0; i < graphemes.length; i++) {\r\n                const grapheme = graphemes[i];\r\n                const graphemeEnd = position + (grapheme.length - 1);\r\n                if (activePosition !== null) {\r\n                    let expectedEnd = activePosition + (string.length - 1);\r\n                    if (graphemeEnd >= expectedEnd) {\r\n                        verifiedPositions[activePosition + startingPosition] = [\r\n                            activePosition + startingPosition,\r\n                            graphemeEnd + startingPosition,\r\n                        ];\r\n                        activePosition = null;\r\n                    }\r\n                } else if (positions.indexOf(position) !== -1) {\r\n                    if (string.length === grapheme.length) {\r\n                        verifiedPositions[position + startingPosition] = [\r\n                            position + startingPosition,\r\n                            graphemeEnd + startingPosition,\r\n                        ];\r\n                    } else if (string.length > grapheme.length) {\r\n                        activePosition = position;\r\n                    }\r\n                } else {\r\n                    activePosition = null;\r\n                }\r\n\r\n                position += grapheme.length;\r\n            }\r\n        }\r\n\r\n        _searchResultsCache[uniqueId][string][index] = verifiedPositions;\r\n\r\n        return verifiedPositions;\r\n    }\r\n\r\n    rowRenderer({\r\n        key,\r\n        index,\r\n        parent,\r\n        style,\r\n    }: {\r\n        key: string,\r\n        index: number,\r\n        parent: {},\r\n        style: {},\r\n    }): React.Element<CellMeasurer> {\r\n        const props = this.props;\r\n        const cache = this.cache;\r\n        const component = this;\r\n        const pechaImageClass = props.showImages ? styles.pechaImage : null;\r\n\r\n        let imageUrl = \"\";\r\n        if (\r\n            props.selectedWitness &&\r\n            props.selectedWitness.properties &&\r\n            props.selectedWitness.properties.hasOwnProperty(IMAGE_START_PRE_KEY)\r\n        ) {\r\n            imageUrl = this.getImageUrl(index);\r\n        }\r\n\r\n        let searchStringPositions = {};\r\n        let searchValue = this.props.searchValue;\r\n        if (searchValue && searchValue.length > 0 && props.splitText) {\r\n            searchStringPositions = this.getStringPositions(\r\n                props.splitText.texts[index],\r\n                searchValue,\r\n                index\r\n            );\r\n        }\r\n\r\n        let pechaStyles = {};\r\n        if (props.showImages && pechaImageClass && this.calculatedImageHeight) {\r\n            pechaStyles[\"height\"] = this.calculatedImageHeight + \"px\";\r\n        }\r\n        let newStyle = {\r\n            ...style,\r\n            height: style.height + 10,\r\n        };\r\n        return (\r\n            <CellMeasurer\r\n                columnIndex={0}\r\n                key={key}\r\n                parent={parent}\r\n                rowIndex={index}\r\n                cache={cache}\r\n            >\r\n                <div\r\n                    key={key}\r\n                    style={newStyle}\r\n                    className={styles.splitTextRow}\r\n                    ref={this.splitTextRef}\r\n                    id={`index_${index}`}\r\n                >\r\n                    <div className={styles.splitTextRowContent}>\r\n                        {/* {props.showImages && (\r\n                            <div\r\n                                className={pechaImageClass}\r\n                                style={pechaStyles}\r\n                            >\r\n                                <img\r\n                                    alt=\"Text related Image\"\r\n                                    src={imageUrl}\r\n                                    width=\"100%\"\r\n                                    height=\"100%\"\r\n                                    onLoad={(e) => {\r\n                                        if (\r\n                                            component.imageWidth === null &&\r\n                                            e.target\r\n                                        ) {\r\n                                            component.imageWidth =\r\n                                                e.target.naturalWidth;\r\n                                            component.imageHeight =\r\n                                                e.target.naturalHeight;\r\n                                            component.calculatedImageHeight =\r\n                                                null;\r\n                                            window.setTimeout(\r\n                                                component.updateList.bind(\r\n                                                    component\r\n                                                ),\r\n                                                0\r\n                                            );\r\n                                        }\r\n                                    }}\r\n                                />\r\n                            </div>\r\n                        )} */}\r\n                        <Text\r\n                            ref={this.childRef}\r\n                            segmentedText={props.splitText.texts[index]}\r\n                            annotations={props.annotations}\r\n                            activeAnnotations={props.activeAnnotations}\r\n                            activeAnnotation={props.activeAnnotation}\r\n                            row={index}\r\n                            selectedSegmentId={props.selectedSegmentId}\r\n                            annotationPositions={props.annotationPositions}\r\n                            selectedAnnotatedSegments={\r\n                                this._filteredSelectedAnnotatedSegments\r\n                            }\r\n                            getBaseAnnotation={this.getBaseAnnotation.bind(\r\n                                this\r\n                            )}\r\n                            activeWitness={this.props.selectedWitness}\r\n                            searchValue={searchValue}\r\n                            selectedSearchResult={\r\n                                this.props.selectedSearchResult\r\n                            }\r\n                            searchStringPositions={searchStringPositions}\r\n                            fontSize={props.fontSize}\r\n                            changeSyncIdOnClick={this.props.changeSyncIdOnClick}\r\n                            changeScrollToId={this.props.changeScrollToId}\r\n                            isPanelLinked={this.props.isPanelLinked}\r\n                            isAnnotating={this.props.isAnnotating}\r\n                            textAlignmentById={this.props.textAlignmentById}\r\n                            selectedSourceRange={this.props.selectedSourceRange}\r\n                            selectedTargetRange={this.props.selectedTargetRange}\r\n                            changeSelectedRange={this.props.changeSelectedRange}\r\n                            condition={this.condition}\r\n                        />\r\n                    </div>\r\n                    {this.props.isAnnotating &&\r\n                        this.selectedTextIndex === index &&\r\n                        this.props.activeAnnotation && (\r\n                            <AnnotationControlsContainer\r\n                                annotationPositions={props.annotationPositions}\r\n                                annotatedText={props.splitText.annotatedText}\r\n                                activeAnnotation={props.activeAnnotation}\r\n                                inline={true}\r\n                                firstSelectedSegment={this.firstSelectedSegment}\r\n                                splitTextRect={this.splitTextRect}\r\n                                selectedElementId={this.selectedElementId}\r\n                                pechaImageClass={pechaImageClass}\r\n                                splitText={props.splitText}\r\n                                selectedElementIds={this.selectedElementIds}\r\n                                list={this.list}\r\n                            />\r\n                        )}\r\n                </div>\r\n            </CellMeasurer>\r\n        );\r\n    }\r\n}\r\n","import React from \"react\";\r\nimport { Box, Typography } from \"@mui/material\";\r\nfunction TableOfContent() {\r\n    return (\r\n        <>\r\n            <Typography textTransform={\"uppercase\"}>\r\n                Table Of Content\r\n            </Typography>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default TableOfContent;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"paddingSide\":\"20px\",\"maxWidth\":\"600px\",\"text\":\"Text---text\",\"syncIdClass\":\"Text---syncIdClass\",\"textFirstRow\":\"Text---textFirstRow\",\"textLine\":\"Text---textLine\",\"textline\":\"Text---textline\",\"limitWidth\":\"Text---limitWidth\",\"textContainer\":\"Text---textContainer\",\"annotation\":\"Text---annotation\",\"selectedAnnotation\":\"Text---selectedAnnotation\",\"removedByAnnotation\":\"Text---removedByAnnotation\",\"insertion\":\"Text---insertion\",\"highlight\":\"Text---highlight\",\"activeHighlight\":\"Text---activeHighlight\",\"lineBreak\":\"Text---lineBreak\",\"pageBreak\":\"Text---pageBreak\",\"selectedRange\":\"Text---selectedRange\"};","// @flow\r\nimport React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport styles from \"./Text.css\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport {\r\n    INSERTION_KEY,\r\n    DELETION_KEY,\r\n    PAGE_BREAK_KEY,\r\n    LINE_BREAK_KEY,\r\n} from \"lib/AnnotatedText\";\r\nimport _ from \"lodash\";\r\nimport SegmentedText from \"lib/SegmentedText\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport Witness from \"lib/Witness\";\r\nimport { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport GraphemeSplitter from \"grapheme-splitter\";\r\nexport function idForSegment(segment: TextSegment): string {\r\n    return \"s_\" + segment.start;\r\n}\r\n\r\nexport function idForDeletedSegment(segment: TextSegment): string {\r\n    return \"ds_\" + segment.start;\r\n}\r\n\r\nexport function idForInsertion(segment: TextSegment): string {\r\n    return \"i_\" + segment.start;\r\n}\r\n\r\nexport function idForPageBreak(segment: TextSegment): string {\r\n    return \"p_\" + (segment.end + 1);\r\n}\r\n\r\nexport function idForLineBreak(segment: TextSegment): string {\r\n    return \"l_\" + (segment.end + 1);\r\n}\r\n\r\nfunction isOverflown(element) {\r\n    console.log(element.style.overflow);\r\n    return (\r\n        element.scrollHeight > element.clientHeight ||\r\n        element.scrollWidth > element.clientWidth\r\n    );\r\n}\r\n\r\nexport type Props = {\r\n    segmentedText: SegmentedText,\r\n    annotationPositions: { [string]: Annotation[] },\r\n    selectedSegmentId: (id: string) => void,\r\n    activeAnnotations: { [AnnotationUniqueId]: Annotation } | null,\r\n    getBaseAnnotation: (annotation: Annotation) => Annotation,\r\n    selectedAnnotatedSegments: TextSegment[],\r\n    row: number,\r\n    activeAnnotation: Annotation | null,\r\n    searchValue: string | null,\r\n    selectedSearchResult: {\r\n        textId: number,\r\n        start: number,\r\n        length: number,\r\n    } | null,\r\n    searchStringPositions: { [position: number]: [number, number] },\r\n    fontSize?: number,\r\n    activeWitness: Witness,\r\n    changeSyncIdOnClick: () => void,\r\n    changeScrollToId: () => void,\r\n    isPanelLinked: Boolean,\r\n    textAlignmentById: {},\r\n    selectedSourceRange: [],\r\n    selectedTargetRange: [],\r\n};\r\n\r\nexport type State = {\r\n    segmentedText: SegmentedText,\r\n};\r\n\r\nimport ReactDOMServer from \"react-dom/server\";\r\nimport PageBreakIcon from \"images/page_break_icon.svg\";\r\nconst PARA_SYMBOL = String.fromCharCode(182);\r\nconst pageBreakIconString = ReactDOMServer.renderToStaticMarkup(\r\n    <PageBreakIcon />\r\n);\r\nexport default class Text extends React.Component<Props, State> {\r\n    _renderedSegments: TextSegment[] | null;\r\n    _renderedHtml: { __html: string } | null;\r\n    textAlignmentById;\r\n    rangeSelect;\r\n    constructor(props: Props) {\r\n        super(props);\r\n        this.textAlignmentById = [];\r\n        this.state = {\r\n            segmentedText: props.segmentedText,\r\n        };\r\n        this.textAlignmentById = this.props.textAlignmentById;\r\n        this._renderedSegments = null;\r\n        this._renderedHtml = null;\r\n        this.rangeSelect = [];\r\n    }\r\n    UNSAFE_componentWillReceiveProps(nextProps: Props) {\r\n        this.setState((prevState: State, props: Props) => {\r\n            return {\r\n                ...prevState,\r\n                segmentedText: nextProps.segmentedText,\r\n            };\r\n        });\r\n    }\r\n\r\n    annotationsForSegment(segment: TextSegment): Annotation[] {\r\n        let annotations: Annotation[] = [];\r\n        const foundAnnotations =\r\n            this.props.annotationPositions[String(segment.start)];\r\n        if (foundAnnotations) {\r\n            annotations = foundAnnotations;\r\n        }\r\n        const insertions =\r\n            this.props.annotationPositions[INSERTION_KEY + segment.start] || [];\r\n        const deletions =\r\n            this.props.annotationPositions[DELETION_KEY + segment.start] || [];\r\n        const pageBreaks =\r\n            this.props.annotationPositions[\r\n                PAGE_BREAK_KEY + (segment.end + 1)\r\n            ] || [];\r\n        const lineBreaks =\r\n            this.props.annotationPositions[\r\n                LINE_BREAK_KEY + (segment.end + 1)\r\n            ] || [];\r\n\r\n        return annotations.concat(\r\n            insertions,\r\n            deletions,\r\n            pageBreaks,\r\n            lineBreaks\r\n        );\r\n    }\r\n\r\n    segmentsContainSegment(segments: TextSegment[], segment: TextSegment) {\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let listSegment = segments[i];\r\n            if (\r\n                listSegment.start === segment.start &&\r\n                listSegment.text === segment.text\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    selectedElement(element: Element) {\r\n        let sourceRangeSelection = [];\r\n        let targetRangeSelection = [];\r\n        const selection = document.getSelection();\r\n\r\n        if (\r\n            element?.id.includes(\"s_\") &&\r\n            this.props.isPanelLinked &&\r\n            this.props.condition\r\n        ) {\r\n            var clickId = parseInt(element.id.replace(\"s_\", \"\"));\r\n            this.props.changeSyncIdOnClick(clickId);\r\n            this.props.changeScrollToId({ id: null, from: null });\r\n\r\n            let id = parseInt(element.id.replace(\"s_\", \"\"));\r\n            let rangeUnique = this.textAlignmentById.find(\r\n                (l) => id >= l.start && id < l.end\r\n            );\r\n            if (rangeUnique) {\r\n                for (let i = rangeUnique.start; i < rangeUnique.end; i++) {\r\n                    sourceRangeSelection.push(i);\r\n                }\r\n                for (let i = rangeUnique.TStart; i < rangeUnique.TEnd; i++) {\r\n                    targetRangeSelection.push(i);\r\n                }\r\n                this.props.changeSelectedRange({\r\n                    source: sourceRangeSelection,\r\n                    target: targetRangeSelection,\r\n                });\r\n            }\r\n        }\r\n\r\n        if (selection && selection.type === \"Range\") {\r\n            return;\r\n        }\r\n        this.props.selectedSegmentId(element.id);\r\n\r\n        if (!element.id) {\r\n            this.props.changeSelectedRange({ source: [], target: [] });\r\n        }\r\n    }\r\n\r\n    generateHtml(renderProps: Props, renderState: State): { __html: string } {\r\n        let segments = renderState.segmentedText.segments;\r\n\r\n        let textLineClass = styles.textLine;\r\n        let segmentHTML = '<p class=\"' + textLineClass + '\">';\r\n        if (segments.length === 0) return { __html: segmentHTML };\r\n\r\n        const insertionClass = styles.insertion;\r\n        const endPosition = segments[segments.length - 1].end + 1;\r\n        if (renderProps.annotationPositions[INSERTION_KEY + endPosition]) {\r\n            const endSegment = new TextSegment(endPosition, \"\");\r\n            segments.push(endSegment);\r\n        }\r\n        if (renderProps.annotationPositions[PAGE_BREAK_KEY + endPosition]) {\r\n            const endSegment = new TextSegment(endPosition, \"\");\r\n            segments.push(endSegment);\r\n        }\r\n        if (renderProps.annotationPositions[LINE_BREAK_KEY + endPosition]) {\r\n            const endSegment = new TextSegment(endPosition, \"\");\r\n            segments.push(endSegment);\r\n        }\r\n\r\n        let activeAnnotations = renderProps.activeAnnotations || {};\r\n\r\n        let highlightClass = styles.highlight;\r\n        let activeHighlightClass = styles.activeHighlight;\r\n        let activeSearchResultEnd = null;\r\n        let processedInactiveInsertions = {};\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let segment = segments[i];\r\n            let classAttribute = \"\";\r\n            let classes = [];\r\n            let annotations = this.annotationsForSegment(segment);\r\n            let deletionText = null;\r\n            let selectedCurrentDeletion = false;\r\n            let selectedCurrentPageBreak = false;\r\n            let selectedCurrentLineBreak = false;\r\n            let lineBreakAnnotation = false;\r\n            let pageBreakAnnotation = null;\r\n\r\n            if (annotations) {\r\n                let activeInsertions = [];\r\n                let inactiveInsertions = [];\r\n                let remainingAnnotations = [];\r\n                let activeDeletions = [];\r\n\r\n                for (let j = 0, len = annotations.length; j < len; j++) {\r\n                    let annotation = annotations[j];\r\n                    if (annotation.isInsertion) {\r\n                        if (annotation.uniqueId in activeAnnotations) {\r\n                            activeInsertions.push(annotation);\r\n                        } else {\r\n                            // Only first inactive insertion at a position will\r\n                            // be shown, so only process first one.\r\n                            // TODO: need to check if there is an active insertion\r\n                            // at the same place. If so, ignore inactive insertion\r\n                            // as they should be shown in the popover.\r\n                            const annotationKey = annotation.start;\r\n                            if (\r\n                                !processedInactiveInsertions.hasOwnProperty(\r\n                                    annotationKey\r\n                                )\r\n                            ) {\r\n                                inactiveInsertions.push(annotation);\r\n                                processedInactiveInsertions[annotationKey] =\r\n                                    annotation;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (annotation.isDeletion) {\r\n                            if (annotation.uniqueId in activeAnnotations) {\r\n                                activeDeletions.push(annotation);\r\n                            }\r\n                        } else if (\r\n                            annotation.type === ANNOTATION_TYPES.pageBreak &&\r\n                            !renderProps.activeWitness.isWorking\r\n                        ) {\r\n                            pageBreakAnnotation = annotation;\r\n                        } else if (\r\n                            annotation.type === ANNOTATION_TYPES.lineBreak &&\r\n                            !renderProps.activeWitness.isWorking\r\n                        ) {\r\n                            lineBreakAnnotation = annotation;\r\n                        } else {\r\n                            remainingAnnotations.push(annotation);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (\r\n                    activeInsertions.length === 0 &&\r\n                    inactiveInsertions.length > 0\r\n                ) {\r\n                    const insertion = inactiveInsertions[0];\r\n                    const insertionId = idForInsertion(segment);\r\n                    let insertionClasses = insertionClass;\r\n                    if (\r\n                        renderProps.activeAnnotation &&\r\n                        renderProps.activeAnnotation.isInsertion &&\r\n                        renderProps.activeAnnotation.start === insertion.start\r\n                    ) {\r\n                        insertionClasses += \" \" + styles.selectedAnnotation;\r\n                    }\r\n\r\n                    segmentHTML +=\r\n                        \"<span id=\" +\r\n                        insertionId +\r\n                        \" key=\" +\r\n                        insertionId +\r\n                        ' class=\"' +\r\n                        insertionClasses +\r\n                        '\">' +\r\n                        insertion.content +\r\n                        \"</span>\";\r\n                }\r\n\r\n                if (activeDeletions.length > 0) {\r\n                    const activeDeletion = activeDeletions[0];\r\n                    const baseAnnotation =\r\n                        renderProps.getBaseAnnotation(activeDeletion);\r\n                    deletionText = baseAnnotation.content;\r\n                    if (\r\n                        renderProps.activeAnnotation &&\r\n                        renderProps.activeAnnotation.isDeletion &&\r\n                        renderProps.activeAnnotation.start ===\r\n                            activeDeletion.start &&\r\n                        renderProps.activeAnnotation.length ===\r\n                            activeDeletion.length &&\r\n                        segment.length === 0\r\n                    ) {\r\n                        selectedCurrentDeletion = true;\r\n                    }\r\n                }\r\n\r\n                if (pageBreakAnnotation) {\r\n                    if (\r\n                        renderProps.activeAnnotation &&\r\n                        renderProps.activeAnnotation.uniqueId ===\r\n                            pageBreakAnnotation.uniqueId\r\n                    ) {\r\n                        selectedCurrentPageBreak = true;\r\n                    }\r\n                }\r\n\r\n                if (lineBreakAnnotation) {\r\n                    if (\r\n                        renderProps.activeAnnotation &&\r\n                        renderProps.activeAnnotation.uniqueId ===\r\n                            lineBreakAnnotation.uniqueId\r\n                    ) {\r\n                        selectedCurrentLineBreak = true;\r\n                    }\r\n                }\r\n\r\n                if (\r\n                    remainingAnnotations.length > 0 ||\r\n                    activeInsertions.length > 0\r\n                ) {\r\n                    classes.push(styles.annotation);\r\n                }\r\n            }\r\n\r\n            // It's an insertion at the end of the text, which should have just been added to the html.\r\n            // So break as we don't want anymore segment html adding.\r\n            if (segment.start === endPosition) {\r\n                break;\r\n            }\r\n\r\n            let id = null;\r\n            if (segment.length === 0) {\r\n                id = idForDeletedSegment(segment);\r\n                classes.push(styles.removedByAnnotation);\r\n                if (deletionText) {\r\n                    segment = new TextSegment(segment.start, deletionText);\r\n                }\r\n            } else {\r\n                id = idForSegment(segment);\r\n            }\r\n\r\n            if (\r\n                this.segmentsContainSegment(\r\n                    renderProps.selectedAnnotatedSegments,\r\n                    segment\r\n                ) ||\r\n                selectedCurrentDeletion\r\n            ) {\r\n                classes.push(styles.selectedAnnotation);\r\n            }\r\n\r\n            if (renderProps.selectedSourceRange.includes(segment.start)) {\r\n                classes.push(styles.selectedRange);\r\n            }\r\n\r\n            if (classes.length > 0) {\r\n                let className = classnames(...classes);\r\n                classAttribute = 'class=\"' + className + '\"';\r\n            }\r\n\r\n            let segmentContent = segment.text;\r\n\r\n            // Add search result highlight if required.\r\n            if (renderProps.searchStringPositions) {\r\n                let segmentStart = segment.start;\r\n                let position = segmentStart;\r\n                segmentContent = \"\";\r\n\r\n                let highlight = highlightClass;\r\n                if (\r\n                    renderProps.selectedSearchResult &&\r\n                    renderProps.selectedSearchResult.start <= position &&\r\n                    renderProps.selectedSearchResult.start +\r\n                        renderProps.selectedSearchResult.length >\r\n                        position\r\n                ) {\r\n                    highlight = activeHighlightClass;\r\n                }\r\n\r\n                for (let j = 0; j < segment.text.length; j++) {\r\n                    let char = segment.text.charAt(j);\r\n                    position = segmentStart + j;\r\n                    if (activeSearchResultEnd) {\r\n                        let [start, end] = activeSearchResultEnd;\r\n                        if (j === 0) {\r\n                            segmentContent +=\r\n                                '<span class=\"' + highlight + '\">';\r\n                        }\r\n                        if (position === end) {\r\n                            segmentContent += char + \"</span>\";\r\n                            activeSearchResultEnd = null;\r\n                        } else if (j === segment.text.length - 1) {\r\n                            segmentContent += char + \"</span>\";\r\n                        } else {\r\n                            segmentContent += char;\r\n                        }\r\n                    } else if (position in renderProps.searchStringPositions) {\r\n                        let [start, end] =\r\n                            renderProps.searchStringPositions[position];\r\n                        segmentContent +=\r\n                            '<span class=\"' + highlight + '\">' + char;\r\n                        if (j === segment.text.length - 1 || position === end) {\r\n                            segmentContent += \"</span>\";\r\n                        }\r\n                        if (position < end) {\r\n                            activeSearchResultEnd = [start, end];\r\n                        }\r\n                    } else {\r\n                        segmentContent += char;\r\n                    }\r\n                }\r\n            }\r\n            // if (this.props.textAlignmentById !== null) {\r\n            //     let r = this.props.textAlignmentById.find(\r\n            //         (d) => d.start === segment.start\r\n            //     );\r\n            //     if (r) {\r\n            //         segmentHTML +=\r\n            //             \"<span id='alignment_\" +\r\n            //             segment.start +\r\n            //             \"'>\" +\r\n            //             `<sup class=` +\r\n            //             styles.syncIdClass +\r\n            //             `>${r.id}</sup>` +\r\n            //             \"</span>\";\r\n            //     }\r\n            // }\r\n            segmentHTML +=\r\n                \"<span id=\" +\r\n                id +\r\n                \" key=\" +\r\n                id +\r\n                \" \" +\r\n                classAttribute +\r\n                \">\" +\r\n                segmentContent +\r\n                \"</span>\";\r\n\r\n            if (pageBreakAnnotation) {\r\n                let pageBreakClasses = [styles.pageBreak];\r\n                if (selectedCurrentPageBreak) {\r\n                    pageBreakClasses.push(styles.selectedAnnotation);\r\n                }\r\n                const pageBreakClassAttribute =\r\n                    ' class=\"' + pageBreakClasses.join(\" \") + '\" ';\r\n                segmentHTML +=\r\n                    \"<span id=\" +\r\n                    idForPageBreak(segment) +\r\n                    \" key=\" +\r\n                    idForPageBreak(segment) +\r\n                    pageBreakClassAttribute +\r\n                    \">\" +\r\n                    pageBreakIconString +\r\n                    \"</span>\";\r\n            }\r\n            if (lineBreakAnnotation) {\r\n                let lineBreakClasses = [styles.lineBreak];\r\n                if (selectedCurrentLineBreak) {\r\n                    lineBreakClasses.push(styles.selectedAnnotation);\r\n                }\r\n                const lineBreakClassAttribute =\r\n                    ' class=\"' + lineBreakClasses.join(\" \") + '\" ';\r\n                segmentHTML +=\r\n                    \"<span id=\" +\r\n                    idForLineBreak(segment) +\r\n                    \" key=\" +\r\n                    idForLineBreak(segment) +\r\n                    lineBreakClassAttribute +\r\n                    \">\" +\r\n                    PARA_SYMBOL +\r\n                    \"</span>\";\r\n\r\n                segmentHTML += '</p><p class=\"' + textLineClass + '\">';\r\n            }\r\n        }\r\n\r\n        this._renderedSegments = segments;\r\n\r\n        segmentHTML += \"</p>\";\r\n        const html = {\r\n            __html: segmentHTML,\r\n        };\r\n        return html;\r\n    }\r\n    shouldComponentUpdate(nextProps: Props, nextState: State) {\r\n        const renderedHtml = this.generateHtml(nextProps, nextState);\r\n\r\n        if (this.props.fontSize !== nextProps.fontSize) {\r\n            return true;\r\n        } else if (\r\n            this._renderedHtml &&\r\n            renderedHtml.__html === this._renderedHtml.__html\r\n        ) {\r\n            return false;\r\n        } else {\r\n            this._renderedHtml = renderedHtml;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    render() {\r\n        let classes = [styles.text];\r\n        if (this.props.row === 0) {\r\n            classes.push(styles.textFirstRow);\r\n        }\r\n        // Generate HTML manually as it is much faster when\r\n        // creating large numbers of elements, such as these spans.\r\n        const html = this._renderedHtml\r\n            ? this._renderedHtml\r\n            : this.generateHtml(this.props, this.state);\r\n        if (!this._renderedHtml) {\r\n            this._renderedHtml = html;\r\n        }\r\n        return (\r\n            <div className={styles.textContainer}>\r\n                <div\r\n                    className={classnames(...classes)}\r\n                    dangerouslySetInnerHTML={html}\r\n                    style={{\r\n                        fontSize: this.props.fontSize,\r\n                    }}\r\n                    onClick={(e) => {\r\n                        this.selectedElement(e.target);\r\n                    }}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"textDetail\":\"TextDetail---textDetail\",\"textContainer\":\"TextDetail---textContainer\",\"tableContent\":\"TextDetail---tableContent\"};","// @flow\r\nimport React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport imageStyle from \"../Editors/MediaComponent/Image.css\";\r\n\r\nimport SplitTextComponent from \"components/TextDetail/SplitText\";\r\n\r\nimport Loader from \"react-loader\";\r\nimport AnnotationControlsContainer from \"./AnnotationControlsContainer\";\r\nimport SplitText from \"lib/SplitText\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport Witness from \"lib/Witness\";\r\nimport AnnotatedText from \"lib/AnnotatedText\";\r\nimport lengthSplitter from \"lib/text_splitters/lengthSplitter\";\r\nimport positionSplitter from \"lib/text_splitters/positionSplitter\";\r\nimport headerStyles from \"components/Header/Header.css\";\r\nimport styles from \"./TextDetail.css\";\r\nimport utilStyles from \"css/util.css\";\r\nimport type { TextData } from \"api\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport TextDetailHeadingContainer from \"./TextDetailHeadingContainer\";\r\nimport { Box, Slide } from \"@mui/material\";\r\nimport _ from \"lodash\";\r\nimport TableOfContent from \"./TableOfContent/TableOfContent\";\r\n\r\nexport type Props = {\r\n    paginated: boolean,\r\n    pageImagesVisible: boolean,\r\n    text: TextData | null,\r\n    loading: boolean,\r\n    pageBreaks: number[],\r\n    annotatedText: AnnotatedText,\r\n    annotations: Annotation[],\r\n    activeAnnotations: Annotation[],\r\n    activeAnnotation: Annotation | null,\r\n    didSelectSegmentIds: (segmentIds: string[]) => void,\r\n    selectedSegmentId: (segmentId: string) => void,\r\n    annotationPositions: { [string]: Annotation[] },\r\n    selectedAnnotatedSegments: Array<TextSegment | number>,\r\n    textListVisible: boolean,\r\n    imagesBaseUrl: string,\r\n    selectedWitness: Witness | null,\r\n    selectedSearchResult: {\r\n        textId: number,\r\n        start: number,\r\n        length: number,\r\n    } | null,\r\n    searchValue: string | null,\r\n    fontSize: number,\r\n    isSecondWindowOpen: Boolean,\r\n    imageData: {},\r\n    isPanelLinked: boolean,\r\n    isPanelVisible: Boolean,\r\n    changeSyncIdOnClick: () => void,\r\n    changeScrollToId: () => void,\r\n    changeSelectedImage: () => void,\r\n    closeAnnotation: () => void,\r\n    textAlignmentById: {},\r\n    selectedWindow: Number,\r\n    changeSelectedWindow: () => void,\r\n    changeSelectedRange: [],\r\n    scrollToId: {},\r\n    selectedSourceRange: [],\r\n    selectedTargetRange: [],\r\n    searchResults: [],\r\n    changeShowTableContent: () => void,\r\n    showTableContent: Boolean,\r\n    syncIdOnSearch: String,\r\n};\r\n\r\nlet textDetailId = 0;\r\n\r\nclass TextDetail extends React.Component<Props> {\r\n    key: number;\r\n    ref;\r\n    selectedWindow;\r\n    constructor() {\r\n        super();\r\n        this.key = textDetailId++;\r\n        this.ref = React.createRef();\r\n        this.selectedWindow = null;\r\n    }\r\n\r\n    mouseEnter() {\r\n        if (this.selectedWindow === 2) this.props.changeSelectedWindow(1);\r\n    }\r\n    componentDidMount() {\r\n        this.ref.current.addEventListener(\r\n            \"mouseenter\",\r\n            this.mouseEnter.bind(this)\r\n        );\r\n    }\r\n    componentDidUpdate() {\r\n        this.selectedWindow = this.props.selectedWindow;\r\n    }\r\n    render() {\r\n        let text = {\r\n            name: \"\",\r\n        };\r\n        if (this.props.text) {\r\n            text = this.props.text;\r\n        }\r\n        let inlineControls = false;\r\n        let textComponent = null;\r\n        let splitText = null;\r\n        if (\r\n            !this.props.annotatedText ||\r\n            !this.props.text ||\r\n            this.props.loading\r\n        ) {\r\n            textComponent = <div key={this.key} />;\r\n        } else {\r\n            let limitWidth = false;\r\n            let splitter;\r\n            if (this.props.paginated) {\r\n                splitter = positionSplitter(this.props.pageBreaks);\r\n            } else {\r\n                splitter = lengthSplitter(1000, /^།[\\s]+(?!།[\\s]+)/, 2, 5);\r\n            }\r\n\r\n            splitText = new SplitText(this.props.annotatedText, splitter);\r\n\r\n            inlineControls = true;\r\n            textComponent = (\r\n                <SplitTextComponent\r\n                    splitText={splitText}\r\n                    annotations={this.props.annotations}\r\n                    activeAnnotations={this.props.activeAnnotations}\r\n                    activeAnnotation={this.props.activeAnnotation}\r\n                    limitWidth={limitWidth}\r\n                    didSelectSegmentIds={this.props.didSelectSegmentIds}\r\n                    selectedSegmentId={this.props.selectedSegmentId}\r\n                    annotationPositions={this.props.annotationPositions}\r\n                    selectedAnnotatedSegments={\r\n                        this.props.selectedAnnotatedSegments\r\n                    }\r\n                    textListVisible={this.props.textListVisible}\r\n                    showImages={this.props.pageImagesVisible}\r\n                    imagesBaseUrl={this.props.imagesBaseUrl}\r\n                    selectedWitness={this.props.selectedWitness}\r\n                    key={this.key}\r\n                    selectedSearchResult={this.props.selectedSearchResult}\r\n                    searchValue={this.props.searchValue}\r\n                    fontSize={this.props.fontSize}\r\n                    isSecondWindowOpen={this.props.isSecondWindowOpen}\r\n                    changeScrollToId={this.props.changeScrollToId}\r\n                    changeSyncIdOnClick={this.props.changeSyncIdOnClick}\r\n                    imageData={this.props.imageData}\r\n                    isPanelLinked={this.props.isPanelLinked}\r\n                    selectedImage={this.props.selectedImage}\r\n                    changeSelectedImage={this.props.changeSelectedImage}\r\n                    isAnnotating={this.props.isAnnotating}\r\n                    closeAnnotation={this.props.closeAnnotation}\r\n                    textAlignment={this.props.textAlignment}\r\n                    textAlignmentById={this.props.textAlignmentById}\r\n                    isPanelVisible={this.props.isPanelVisible}\r\n                    scrollToId={this.props.scrollToId}\r\n                    selectedWindow={this.props.selectedWindow}\r\n                    selectedSourceRange={this.props.selectedSourceRange}\r\n                    selectedTargetRange={this.props.selectedTargetRange}\r\n                    changeSelectedRange={this.props.changeSelectedRange}\r\n                    searchResults={this.props.searchResults}\r\n                    showTableContent={this.props.showTableContent}\r\n                    selectedText={this.props.text}\r\n                    syncIdOnSearch={this.props.syncIdOnSearch}\r\n                ></SplitTextComponent>\r\n            );\r\n        }\r\n        let textComponents = [textComponent];\r\n        return (\r\n            <Box\r\n                style={{\r\n                    height: \"100%\",\r\n                    flex: 1,\r\n                }}\r\n                className={classnames(\r\n                    styles.textDetail,\r\n                    utilStyles.flex,\r\n                    utilStyles.flexColumn\r\n                )}\r\n                key={this.key}\r\n                ref={this.ref}\r\n            >\r\n                <TextDetailHeadingContainer />\r\n                <Loader loaded={!this.props.loading} zIndex={5} />\r\n                <Box\r\n                    style={{\r\n                        display: \"flex\",\r\n                        height: \"100%\",\r\n                        width: \"100%\",\r\n                        position: \"relative\",\r\n                    }}\r\n                >\r\n                    <Box\r\n                        style={{ flex: 1 }}\r\n                        className={classnames(\r\n                            styles.textContainer,\r\n                            utilStyles.flex\r\n                        )}\r\n                    >\r\n                        {!this.props.loading ? textComponents : <div />}\r\n                    </Box>\r\n                    <Slide\r\n                        direction=\"left\"\r\n                        in={this.props.showTableContent}\r\n                        container={this.ref.current}\r\n                    >\r\n                        <Box\r\n                            sx={{\r\n                                position: \"absolute\",\r\n                                height: \"100%\",\r\n                                minWidth: \"50%\",\r\n                                right: 0,\r\n                                background: \"#eee\",\r\n                                borderLeft: \"1px solid gray\",\r\n                                padding: 2,\r\n                            }}\r\n                        >\r\n                            <TableOfContent />\r\n                        </Box>\r\n                    </Slide>\r\n                </Box>\r\n            </Box>\r\n        );\r\n    }\r\n}\r\n\r\nexport default TextDetail;\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport Annotation, { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport Source, { WORKING_VERSION_SOURCE_NAME } from \"lib/Source\";\r\nimport Witness from \"lib/Witness\";\r\nimport Text from \"lib/Text\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport type { AppState } from \"reducers\";\r\nimport type { AnnotationData, TextData } from \"api\";\r\nimport {\r\n    WORKING_VERSION_ANNOTATION_ID,\r\n    INSERTION_KEY,\r\n    DELETION_KEY,\r\n    PAGE_BREAK_KEY,\r\n    LINE_BREAK_KEY,\r\n} from \"lib/AnnotatedText\";\r\nimport TextDetail from \"components/TextDetail\";\r\nimport {\r\n    changedActiveAnnotation,\r\n    changedActiveTextAnnotation,\r\n    changedWitnessScrollPosition,\r\n} from \"actions\";\r\nimport {\r\n    showPageImages,\r\n    getAnnotationsForWitnessId,\r\n    getActiveAnnotationsForWitnessId,\r\n    getActiveAnnotation,\r\n    getActiveTextAnnotation,\r\n    getBaseWitness,\r\n    getWorkingWitness,\r\n    getSelectedText,\r\n    annotationFromData,\r\n    getAnnotationData,\r\n    getUser,\r\n    getTextListVisible,\r\n    getSelectedTextWitnessId,\r\n    getTextWitnesses,\r\n    getWitness,\r\n    hasLoadedWitnessAnnotations,\r\n    getRemovedDefaultAnnotationsForWitnessId,\r\n    hasLoadedWitnessAppliedAnnotations,\r\n    getScrollPosition,\r\n    getSelectedSearchResult,\r\n    getSearchValue,\r\n    getTextFontSize,\r\n    isSecondWindowOpen,\r\n    getImageData,\r\n    getSelectedImage,\r\n    isImagePortrait,\r\n    isPanelVisible,\r\n    getSelectedSourceRange,\r\n    getSelectedTargetRange,\r\n    getSearchResults,\r\n    getShowTableContent,\r\n} from \"reducers\";\r\nimport * as reducers from \"reducers\";\r\nimport _ from \"lodash\";\r\n\r\nimport AnnotatedText from \"lib/AnnotatedText\";\r\nimport segmentTibetanText from \"lib/segmentTibetanText\";\r\nimport SegmentedText from \"lib/SegmentedText\";\r\nimport * as actions from \"actions\";\r\nimport * as constants from \"app_constants\";\r\nimport * as TextStore from \"state_helpers/TextStore\";\r\n\r\nconst DISMISS_CONTROLS_ON_CLICK = false;\r\n\r\nfunction getInsertionKey(annotation) {\r\n    return [annotation.start, annotation.length].join(\"-\");\r\n}\r\n\r\nlet _posAnnotatedText;\r\nlet _posAnnotations;\r\nlet _positions;\r\nlet _posVersion;\r\nconst getAnnotationPositions = (\r\n    annotatedText: AnnotatedText,\r\n    annotations: Annotation[]\r\n): { [string]: Annotation[] } => {\r\n    if (\r\n        annotatedText === _posAnnotatedText &&\r\n        annotations === _posAnnotations &&\r\n        annotatedText.version === _posVersion\r\n    ) {\r\n        return _positions;\r\n    }\r\n\r\n    let positions = {};\r\n    let activeInsertions = {};\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n        let annotation = annotations[i];\r\n        let [startPos, length] =\r\n            annotatedText.getPositionOfAnnotation(annotation);\r\n        if (startPos == null) {\r\n            continue;\r\n        }\r\n        if (length === 0) {\r\n            if (annotation.isInsertion) {\r\n                // group with any active insertions at the same position\r\n                const activeKey = getInsertionKey(annotation);\r\n                const activeInsertionPositions = activeInsertions[activeKey];\r\n                if (activeInsertionPositions) {\r\n                    activeInsertionPositions.map((pos) =>\r\n                        positions[pos].push(annotation)\r\n                    );\r\n                    continue;\r\n                }\r\n                startPos = INSERTION_KEY + startPos;\r\n            }\r\n            if (annotation.isDeletion && annotation.length > 0) {\r\n                // active deletion\r\n                startPos = DELETION_KEY + startPos;\r\n            }\r\n            if (annotation.type === ANNOTATION_TYPES.pageBreak) {\r\n                startPos = PAGE_BREAK_KEY + startPos;\r\n            }\r\n            if (annotation.type === ANNOTATION_TYPES.lineBreak) {\r\n                startPos = LINE_BREAK_KEY + startPos;\r\n            }\r\n            if (positions[startPos] === undefined) {\r\n                positions[startPos] = [];\r\n            }\r\n            if (positions[startPos].indexOf(annotation) === -1) {\r\n                positions[startPos].push(annotation);\r\n            }\r\n        } else {\r\n            let annotationPositions = [];\r\n            for (let j = startPos; j < startPos + length; j++) {\r\n                if (positions[j] === undefined) {\r\n                    positions[j] = [];\r\n                }\r\n                if (positions[j].indexOf(annotation) === -1) {\r\n                    positions[j].push(annotation);\r\n                }\r\n                annotationPositions.push(j);\r\n            }\r\n            // Store the positions this annotation is displayed at.\r\n            // This can then be used later to group with inactive insertions\r\n            if (annotation.isInsertion) {\r\n                const key = getInsertionKey(annotation);\r\n                activeInsertions[key] = annotationPositions;\r\n            }\r\n        }\r\n    }\r\n\r\n    _posAnnotatedText = annotatedText;\r\n    _posAnnotations = annotations;\r\n    _positions = positions;\r\n    _posVersion = annotatedText.version;\r\n    return positions;\r\n};\r\n\r\nlet _selectedWitness = null;\r\n\r\nconst mapStateToProps = (state) => {\r\n    const user = getUser(state);\r\n    const loading =\r\n        state.data.loadingWitnesses || state.data.loadingAnnotations;\r\n    const textListVisible = getTextListVisible(state);\r\n    const isPanelLinked = reducers.isPanelLinked(state);\r\n    const textAlignmentById = reducers.getTextAlignmentById(state);\r\n\r\n    if (loading) {\r\n        return {\r\n            text: null,\r\n            witnesses: null,\r\n            baseWitness: null,\r\n            annotations: null,\r\n            loading: loading,\r\n            paginated: null,\r\n            pageImagesVisible: false,\r\n            annotatedText: null,\r\n            selectedAnnotatedSegments: null,\r\n            annotationPositions: null,\r\n            activeAnnotations: null,\r\n            activeAnnotation: null,\r\n            user: user,\r\n            textListVisible,\r\n            fontSize: constants.DEFAULT_TEXT_FONT_SIZE,\r\n            isSecondWindowOpen: isSecondWindowOpen(state),\r\n            isPanelLinked,\r\n            textAlignmentById,\r\n        };\r\n    }\r\n\r\n    const selectedText = getSelectedText(state);\r\n    let witnesses = {};\r\n    let workingWitness;\r\n    let baseWitness;\r\n    if (selectedText) {\r\n        workingWitness = getWorkingWitness(state, selectedText.id);\r\n        baseWitness = getBaseWitness(state, selectedText.id);\r\n    }\r\n    let selectedSearchResult = getSelectedSearchResult(state);\r\n    let annotationPositions = {};\r\n    let annotations = [];\r\n    let annotatedText = null;\r\n    let activeAnnotation = getActiveTextAnnotation(state);\r\n    let selectedAnnotatedSegments = [];\r\n    let appliedAnnotations = {};\r\n    let pageBreaks = [];\r\n    let imagesBaseUrl = \"\";\r\n    let selectedWitness;\r\n    let searchValue = getSearchValue(state);\r\n    // Whether to show the text's page images\r\n    let paginated = false;\r\n    let pageImagesVisible = false;\r\n    let fontSize = getTextFontSize(state);\r\n    if (\r\n        workingWitness &&\r\n        selectedText &&\r\n        state.data.witnessAnnotationsById.hasOwnProperty(workingWitness.id)\r\n    ) {\r\n        witnesses = getTextWitnesses(state, selectedText.id);\r\n        let selectedWitnessId = getSelectedTextWitnessId(\r\n            state,\r\n            selectedText.id\r\n        );\r\n        if (selectedWitnessId) {\r\n            selectedWitness = getWitness(state, selectedWitnessId);\r\n        }\r\n\r\n        if (!selectedWitness) {\r\n            selectedWitness = workingWitness;\r\n            selectedWitnessId = workingWitness.id;\r\n        }\r\n\r\n        if (selectedWitness.id !== workingWitness.id) {\r\n            paginated = true;\r\n            pageImagesVisible = showPageImages(state);\r\n        }\r\n\r\n        annotatedText = TextStore.getWitnessText(state, selectedWitness.id);\r\n\r\n        [appliedAnnotations, annotations] = TextStore.getWitnessAnnotations(\r\n            state,\r\n            selectedWitness,\r\n            workingWitness\r\n        );\r\n\r\n        if (annotatedText) {\r\n            annotationPositions = getAnnotationPositions(\r\n                annotatedText,\r\n                (Object.values(annotations): any)\r\n            );\r\n        }\r\n\r\n        // Get the segments that are part of the current active annotation.\r\n        // These are used by Text to highlight the currently selected segment.\r\n        if (activeAnnotation && annotatedText) {\r\n            // If we've just switched witnesses, make sure we select the\r\n            // correct part of the text by getting a new annotation.\r\n            if (\r\n                !_selectedWitness ||\r\n                _selectedWitness.id !== selectedWitness.id\r\n            ) {\r\n                activeAnnotation = annotatedText.getAnnotation(\r\n                    activeAnnotation.start,\r\n                    activeAnnotation.length\r\n                );\r\n            }\r\n            if (activeAnnotation) {\r\n                selectedAnnotatedSegments =\r\n                    annotatedText.segmentsForAnnotation(activeAnnotation);\r\n            }\r\n        }\r\n\r\n        if (selectedWitness && baseWitness && annotatedText) {\r\n            let witnessPageBreaks =\r\n                annotatedText.getAnnotationsOfType(\r\n                    ANNOTATION_TYPES.pageBreak\r\n                ) || {};\r\n            // console.log(witnessPageBreaks);\r\n            let basePageBreaks = null;\r\n            if (selectedWitness.id !== baseWitness.id) {\r\n                basePageBreaks = getAnnotationsForWitnessId(\r\n                    state,\r\n                    workingWitness.id,\r\n                    ANNOTATION_TYPES.pageBreak,\r\n                    baseWitness.id\r\n                );\r\n            }\r\n\r\n            pageBreaks = getPageBreaks(witnessPageBreaks, basePageBreaks);\r\n            for (let i = 0, len = pageBreaks.length; i < len; i++) {\r\n                let position = pageBreaks[i];\r\n                let segment = annotatedText.segmentAtOriginalPosition(position);\r\n                if (segment instanceof TextSegment) {\r\n                    pageBreaks[i] = segment.start;\r\n                } else if (segment instanceof Number) {\r\n                    pageBreaks[i] = segment;\r\n                }\r\n            }\r\n\r\n            if (paginated) {\r\n                imagesBaseUrl =\r\n                    \"/static/images/texts/\" +\r\n                    selectedText.name +\r\n                    \"/\" +\r\n                    selectedWitness.source.name +\r\n                    \"/\";\r\n            }\r\n        }\r\n    }\r\n    _selectedWitness = selectedWitness;\r\n    const scrollToId = reducers.getScrollToId(state);\r\n    const textAlignment = reducers.getTextAlignment(state);\r\n\r\n    const syncIdOnClick = reducers.getSyncIdOnClick(state);\r\n    const selectedWindow = reducers.getSelectedWindow(state);\r\n    return {\r\n        text: selectedText,\r\n        witnesses: witnesses,\r\n        workingWitness: workingWitness,\r\n        baseWitness: baseWitness,\r\n        annotations: annotations,\r\n        loading: loading,\r\n        paginated: paginated,\r\n        pageImagesVisible: false,\r\n        annotatedText: annotatedText,\r\n        selectedAnnotatedSegments: selectedAnnotatedSegments,\r\n        annotationPositions: annotationPositions,\r\n        activeAnnotations: { ...appliedAnnotations },\r\n        activeAnnotation: activeAnnotation,\r\n        pageBreaks: pageBreaks,\r\n        imagesBaseUrl: imagesBaseUrl,\r\n        user: user,\r\n        textListVisible,\r\n        selectedWitness,\r\n        selectedSearchResult,\r\n        searchValue,\r\n        fontSize,\r\n        isSecondWindowOpen: isSecondWindowOpen(state),\r\n        imageData: getImageData(state),\r\n        isPanelLinked,\r\n        selectedImage: getSelectedImage(state),\r\n        isImagePortrait: isImagePortrait(state),\r\n        isPanelVisible: isPanelVisible(state),\r\n        isAnnotating: reducers.isAnnotating(state),\r\n        textAlignment,\r\n        textAlignmentById,\r\n        scrollToId,\r\n        syncIdOnClick,\r\n        selectedWindow,\r\n        selectedSourceRange: getSelectedSourceRange(state),\r\n        selectedTargetRange: getSelectedTargetRange(state),\r\n        searchResults: getSearchResults(state, searchValue),\r\n        showTableContent: getShowTableContent(state),\r\n        syncIdOnSearch: reducers.getSyncIdOnSearch(state),\r\n    };\r\n};\r\n\r\nconst mergeProps = (stateProps, dispatchProps, ownProps) => {\r\n    const { dispatch } = dispatchProps;\r\n    const { annotatedText, annotationPositions } = stateProps;\r\n\r\n    const didSelectSegmentPosition = (segmentPosition, start, length) => {\r\n        let segmentAnnotations = annotationPositions[segmentPosition];\r\n        let segmentVariants = [];\r\n        let segmentPageBreaks = [];\r\n        let segmentLineBreaks = [];\r\n        if (segmentAnnotations) {\r\n            segmentVariants = segmentAnnotations.filter(\r\n                (annotation: Annotation) =>\r\n                    annotation.type === ANNOTATION_TYPES.variant\r\n            );\r\n            segmentPageBreaks = segmentAnnotations.filter(\r\n                (annotation: Annotation) =>\r\n                    annotation.type === ANNOTATION_TYPES.pageBreak\r\n            );\r\n            segmentLineBreaks = segmentAnnotations.filter(\r\n                (annotation: Annotation) =>\r\n                    annotation.type === ANNOTATION_TYPES.lineBreak\r\n            );\r\n        }\r\n        let activeAnnotations = _.intersectionWith(\r\n            segmentVariants.concat(segmentPageBreaks, segmentLineBreaks),\r\n            annotatedText.annotations,\r\n            (a, b) => a.toString() == b.toString()\r\n        );\r\n        let activeAnnotation = null;\r\n        if (activeAnnotations.length > 0) {\r\n            // get any active annotations\r\n            activeAnnotation = activeAnnotations[0];\r\n        } else if (segmentVariants && segmentVariants.length > 0) {\r\n            // get base text annotation for longest annotation highlighted in text\r\n            let longestAvailable = getLongestAnnotation(segmentVariants);\r\n            let [start, textLength] =\r\n                annotatedText.getPositionOfAnnotation(longestAvailable);\r\n            if (longestAvailable && longestAvailable.isInsertion) {\r\n                textLength = 0;\r\n            }\r\n            activeAnnotation = annotatedText.getBaseAnnotation(\r\n                start,\r\n                textLength\r\n            );\r\n        } else {\r\n            // get base annotation of just the segment\r\n            activeAnnotation = annotatedText.getBaseAnnotation(start, length);\r\n        }\r\n\r\n        dispatch(changedActiveTextAnnotation(activeAnnotation));\r\n    };\r\n\r\n    const isInsertion = (id) => {\r\n        return id.indexOf(\"i_\") !== -1;\r\n    };\r\n\r\n    const isDeletion = (id) => {\r\n        return id.indexOf(\"ds_\") !== -1;\r\n    };\r\n\r\n    const isPageBreak = (id) => {\r\n        return id.indexOf(\"p_\") !== -1;\r\n    };\r\n\r\n    const isLineBreak = (id) => {\r\n        return id.indexOf(\"l_\") !== -1;\r\n    };\r\n\r\n    const idFromSegmentId = (id) => {\r\n        let start = 0;\r\n        if (isInsertion(id)) {\r\n            start = id.substr(2);\r\n        } else if (isDeletion(id)) {\r\n            start = id.substr(3);\r\n        } else {\r\n            start = id.substr(2);\r\n        }\r\n\r\n        return start;\r\n    };\r\n\r\n    return {\r\n        ...stateProps,\r\n        ...ownProps,\r\n        didSelectSegmentIds: (segmentIds) => {\r\n            if (segmentIds.length === 0) {\r\n                return;\r\n            }\r\n            let segmentAnnotations = [];\r\n            let segments = [];\r\n            for (let segmentId of segmentIds) {\r\n                if (isDeletion(segmentId) || isInsertion(segmentId)) {\r\n                    continue;\r\n                }\r\n\r\n                let segmentPosition = idFromSegmentId(segmentId);\r\n                let textSegment =\r\n                    annotatedText.segmentedText.segmentAtPosition(\r\n                        segmentPosition\r\n                    );\r\n                segments.push(textSegment);\r\n                const annotations = annotationPositions[textSegment.start];\r\n                if (annotations) {\r\n                    segmentAnnotations = segmentAnnotations.concat(annotations);\r\n                }\r\n            }\r\n            segmentAnnotations = _.uniqWith(\r\n                segmentAnnotations,\r\n                (a, b) => a.toString() == b.toString()\r\n            );\r\n\r\n            let activeAnnotations = _.intersectionWith(\r\n                segmentAnnotations,\r\n                annotatedText.annotations,\r\n                (a, b) => a.toString() == b.toString()\r\n            );\r\n\r\n            const range = getSegmentsRange(\r\n                segments,\r\n                activeAnnotations,\r\n                segmentAnnotations,\r\n                stateProps.annotatedText\r\n            );\r\n            if (!range) {\r\n                console.warn(\r\n                    \"No range for selected segment ids: %o\",\r\n                    segmentIds\r\n                );\r\n                return;\r\n            }\r\n            const baseAnnotation = annotatedText.getBaseAnnotation(\r\n                range.start,\r\n                range.length\r\n            );\r\n            let activeAnnotation = null;\r\n            if (range.annotation) {\r\n                activeAnnotation = range.annotation;\r\n            } else if (activeAnnotations.length > 0) {\r\n                const content = annotatedText.segmentedText\r\n                    .segmentsInRange(range.start, range.length)\r\n                    .reduce((content, segment) => content + segment.text, \"\");\r\n                // TODO: test this when editing non-working edition.\r\n                // Check if getTextWorkingWitness works as required\r\n                if (!stateProps.selectedWitness) {\r\n                    console.log(\r\n                        \"no stateProps.selectedWitness: %o\",\r\n                        stateProps.selectedWitness\r\n                    );\r\n                }\r\n                activeAnnotation = new Annotation(\r\n                    WORKING_VERSION_ANNOTATION_ID,\r\n                    getTextWorkingWitness(stateProps.text),\r\n                    baseAnnotation.start,\r\n                    baseAnnotation.length,\r\n                    content,\r\n                    ANNOTATION_TYPES.variant,\r\n                    stateProps.selectedWitness,\r\n                    stateProps.user\r\n                );\r\n            } else {\r\n                activeAnnotation = baseAnnotation;\r\n            }\r\n            dispatch(changedActiveTextAnnotation(activeAnnotation));\r\n        },\r\n        selectedSegmentId: (segmentId) => {\r\n            let start = idFromSegmentId(segmentId);\r\n            let positionKey = start;\r\n            if (isInsertion(segmentId)) {\r\n                positionKey = INSERTION_KEY + start;\r\n            } else if (isDeletion(segmentId)) {\r\n                positionKey = DELETION_KEY + start;\r\n            } else if (isPageBreak(segmentId)) {\r\n                positionKey = PAGE_BREAK_KEY + start;\r\n            } else if (isLineBreak(segmentId)) {\r\n                positionKey = LINE_BREAK_KEY + start;\r\n            }\r\n\r\n            let segmentAnnotations = annotationPositions[positionKey];\r\n            if (\r\n                (DISMISS_CONTROLS_ON_CLICK && stateProps.activeAnnotation) ||\r\n                segmentId === \"\"\r\n            ) {\r\n                const activeAnnotation = stateProps.activeAnnotation;\r\n\r\n                if (activeAnnotation) {\r\n                    const dismissTextAnnotation =\r\n                        actions.changedActiveTextAnnotation(null);\r\n                    dispatch(dismissTextAnnotation);\r\n                }\r\n            } else {\r\n                if (\r\n                    isInsertion(segmentId) ||\r\n                    isDeletion(segmentId) ||\r\n                    isPageBreak(segmentId) ||\r\n                    isLineBreak(segmentId)\r\n                ) {\r\n                    const length = 0;\r\n                    didSelectSegmentPosition(positionKey, start, length);\r\n                } else {\r\n                    let segmentPosition = Number(idFromSegmentId(segmentId));\r\n                    let textSegment =\r\n                        annotatedText.segmentedText.segmentAtPosition(\r\n                            segmentPosition\r\n                        );\r\n                    if (textSegment) {\r\n                        didSelectSegmentPosition(\r\n                            textSegment.start,\r\n                            textSegment.start,\r\n                            textSegment.length\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        changeScrollToId: (payload) =>\r\n            dispatch(actions.changeScrollToId(payload)),\r\n        changeSyncIdOnClick: (payload) =>\r\n            dispatch(actions.changeSyncIdOnClick(payload)),\r\n        changeSelectedImage: (payload) => {\r\n            dispatch(actions.selectImage(payload));\r\n        },\r\n        changeSelectedWindow: (payload) => {\r\n            dispatch(actions.changeSelectedWindow(payload));\r\n        },\r\n        changeSelectedRange: (payload) => {\r\n            dispatch(actions.changeSelectedRange(payload));\r\n        },\r\n        changeShowTableContent: (payload) => {\r\n            dispatch(actions.showTableContent(payload));\r\n        },\r\n        closeAnnotation: () => {\r\n            const dismissTextAnnotation =\r\n                actions.changedActiveTextAnnotation(null);\r\n            dispatch(dismissTextAnnotation);\r\n        },\r\n    };\r\n};\r\n\r\nconst getPageBreaks = (\r\n    witnessPageBreaks: { [AnnotationUniqueId]: Annotation },\r\n    basePageBreaks: { [AnnotationUniqueId]: AnnotationData } | null\r\n): number[] => {\r\n    let witnessStarts = [];\r\n    _.forIn(witnessPageBreaks, (o) => witnessStarts.push(o.start));\r\n    witnessStarts = witnessStarts.sort((a, b) => a - b);\r\n\r\n    if (!basePageBreaks) {\r\n        return witnessStarts;\r\n    }\r\n\r\n    let baseStarts = [];\r\n    _.forIn(basePageBreaks, (o) => baseStarts.push(o.start));\r\n    baseStarts = baseStarts.sort((a, b) => a - b);\r\n\r\n    if (witnessStarts.length === 0) {\r\n        return baseStarts;\r\n    }\r\n\r\n    // Only add page breaks if witness has < 90% of base witness breaks.\r\n    // Editions often have differing numbers of words per page so can't\r\n    // be 100%.\r\n    const threshold = 0.9;\r\n    if (witnessStarts.length / baseStarts.length < threshold) {\r\n        let lastWitnessPageStart = witnessStarts[witnessStarts.length - 1];\r\n        for (let i = 0, len = baseStarts.length; i < len; i++) {\r\n            let start = baseStarts[i];\r\n            if (start > lastWitnessPageStart) witnessStarts.push(start);\r\n        }\r\n    }\r\n\r\n    return witnessStarts;\r\n};\r\n\r\nconst getTextWorkingWitness = (textData: TextData): Witness => {\r\n    const source = new Source(\r\n        WORKING_VERSION_ANNOTATION_ID,\r\n        WORKING_VERSION_SOURCE_NAME\r\n    );\r\n    const text = new Text(textData.id, textData.name);\r\n    const witness = new Witness(\r\n        WORKING_VERSION_ANNOTATION_ID,\r\n        text,\r\n        source,\r\n        \"\",\r\n        false\r\n    );\r\n\r\n    return witness;\r\n};\r\n\r\nconst getSegmentsRange = (\r\n    segments: TextSegment[],\r\n    activeAnnotations: Annotation[],\r\n    annotations: Annotation[],\r\n    annotatedText: AnnotatedText\r\n): { start: number, length: number, annotation: Annotation | null } | null => {\r\n    if (segments.length === 0) {\r\n        return null;\r\n    }\r\n    let first = segments[0];\r\n    let last = segments[segments.length - 1];\r\n\r\n    let start = first.start;\r\n    let end = last.end;\r\n\r\n    let startAnnotation = null;\r\n    let endAnnotation = null;\r\n    for (let i = 0; i < annotations.length; i++) {\r\n        const annotation = annotations[i];\r\n        let annotationStart,\r\n            annotationLength,\r\n            annotationEnd = null;\r\n        [annotationStart, annotationLength] =\r\n            annotatedText.getPositionOfAnnotation(annotation);\r\n\r\n        if (activeAnnotations.indexOf(annotation) !== -1) {\r\n            if (annotationStart && annotationStart < start) {\r\n                start = annotationStart;\r\n                startAnnotation = annotation;\r\n            }\r\n\r\n            annotationEnd = annotationStart + annotationLength - 1;\r\n\r\n            if (annotationEnd && annotationEnd > end) {\r\n                end = annotationEnd;\r\n                endAnnotation = annotationEnd;\r\n            }\r\n        } else {\r\n            // For inactive annotions - we want to select the whole\r\n            // length of text the annotation refers to.\r\n            annotationEnd = annotationStart + annotationLength - 1;\r\n            if (annotationEnd > end) {\r\n                end = annotationEnd;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set if the whole range is encompassed by a single annotation\r\n    let rangeAnnotation = null;\r\n    if (startAnnotation && endAnnotation && startAnnotation === endAnnotation) {\r\n        rangeAnnotation = startAnnotation;\r\n    }\r\n\r\n    return {\r\n        start: start,\r\n        length: end - start + 1,\r\n        annotation: rangeAnnotation,\r\n    };\r\n};\r\n\r\nconst getLongestAnnotation = (annotations: Annotation[]): Annotation | null => {\r\n    let longest = null;\r\n    for (let i = 0; i < annotations.length; i++) {\r\n        let annotation = annotations[i];\r\n        if (!longest) {\r\n            longest = annotation;\r\n        } else {\r\n            if (annotation.length > longest.length) {\r\n                longest = annotation;\r\n            }\r\n        }\r\n    }\r\n    return longest;\r\n};\r\n\r\nconst TextDetailContainer = connect(\r\n    mapStateToProps,\r\n    null,\r\n    mergeProps\r\n)(TextDetail);\r\n\r\nexport default TextDetailContainer;\r\n","import React, {\r\n    useState,\r\n    useRef,\r\n    useCallback,\r\n    useEffect,\r\n    useMemo,\r\n} from \"react\";\r\nimport styles from \"./textDetailHeading.css\";\r\nimport SelectVersion from \"./SelectVersion\";\r\nimport _ from \"lodash\";\r\nimport TextList from \"./TextListContainer\";\r\nimport CloseIcon from \"@mui/icons-material/Close\";\r\nimport {\r\n    Stack,\r\n    Box,\r\n    TextField,\r\n    Button,\r\n    Collapse,\r\n    Divider,\r\n    ButtonGroup,\r\n    ListItem,\r\n    List,\r\n    IconButton,\r\n} from \"@mui/material\";\r\nimport Share from \"./HeaderMenu/Share\";\r\nimport Annotate from \"./HeaderMenu/Annotate\";\r\nimport Refresh from \"./HeaderMenu/Refresh\";\r\nimport Search from \"./HeaderMenu/Search\";\r\nimport WindowSplitter from \"./HeaderMenu/WindowSplitter\";\r\nimport Settings from \"./HeaderMenu/Settings\";\r\nimport TableOfContent from \"./HeaderMenu/TableOfContent\";\r\nimport Autocomplete from \"@mui/material/Autocomplete\";\r\nimport { AutoSizer } from \"react-virtualized\";\r\nimport SearchList from \"./HeaderMenu/SearchList\";\r\n\r\ntype HeaderProps = {\r\n    selectedText: {},\r\n    witnesses: Witness[],\r\n    selectedWitness: Witness,\r\n    onSelectedWitness: () => void,\r\n    user: User,\r\n    activeLocale: string,\r\n    accountOverlayVisible: boolean,\r\n    navigationButtonClicked: () => void,\r\n    menuButtonClicked: () => void,\r\n    textFontSize: Number,\r\n    onChangedFontSize: () => void,\r\n    onChangeWindowOpen: () => void,\r\n    isSecondWindowOpen: boolean,\r\n    changeIsAnnotating: () => void,\r\n    isAnnotating: Boolean,\r\n    searchChanged: () => void,\r\n    searchValue: String,\r\n    changeShowTableContent: () => void,\r\n    searchResults: [],\r\n};\r\n\r\nfunction TextDetailHeading(props: HeaderProps) {\r\n    const [findvalue, setfindvalue] = useState(\"\");\r\n    let [showFind, setShowFind] = useState(false);\r\n    let [visible, setVisible] = useState(false);\r\n    const headingRef = useRef();\r\n    const inputRef = useRef();\r\n    const handleListItemClick = (id) => {\r\n        props.changeSelectSyncId(id);\r\n    };\r\n    const debouncedSearch = React.useRef(\r\n        _.debounce((s) => {\r\n            props.searchChanged(s);\r\n        }, 1000)\r\n    ).current;\r\n    const handleSearch = useCallback(\r\n        (e) => {\r\n            e.preventDefault();\r\n            debouncedSearch(findvalue);\r\n            setVisible(true);\r\n        },\r\n        [findvalue]\r\n    );\r\n    const handleWindowSearch = useCallback(() => {\r\n        if (showFind === false) debouncedSearch(null);\r\n        setShowFind(!showFind);\r\n    }, [showFind]);\r\n\r\n    useEffect(() => {\r\n        if (showFind === true) {\r\n            inputRef.current.focus();\r\n        }\r\n        if (showFind === false) debouncedSearch(null);\r\n    }, [showFind]);\r\n\r\n    const closeSearchItemBox = useCallback(() => {\r\n        setVisible(false);\r\n        debouncedSearch(null);\r\n        setfindvalue(\"\");\r\n    }, []);\r\n\r\n    let condition = useMemo(\r\n        () =>\r\n            _.isObject(props.searchResults) &&\r\n            props.searchResults.hasOwnProperty(props.selectedText.id),\r\n        [props.searchResults, props.selectedText]\r\n    );\r\n    let results = condition\r\n        ? props.searchResults[props.selectedText.id].results\r\n        : [];\r\n    return (\r\n        <Stack\r\n            ref={headingRef}\r\n            direction=\"column\"\r\n            spacing={1}\r\n            px={2}\r\n            py={1}\r\n            style={{ background: \"#f7f7f7\" }}\r\n        >\r\n            <Stack direction=\"row\" spacing={1} justifyContent=\"space-between\">\r\n                <Box sx={{ display: \"flex\", gap: 2 }}>\r\n                    <TextList />\r\n                    <SelectVersion\r\n                        witnesses={props.witnesses}\r\n                        activeWitness={props.selectedWitness}\r\n                        onSelectedWitness={props.onSelectedWitness}\r\n                        user={props.user}\r\n                    />\r\n                </Box>\r\n                <ButtonGroup\r\n                    size=\"small\"\r\n                    aria-label=\"small button group\"\r\n                    sx={{\r\n                        position: \"relative\",\r\n                        display: \"flex\",\r\n                        alignItems: \"center\",\r\n                        justifyContent: \"center\",\r\n                        width: \"fit-content\",\r\n                        border: (theme) => `1px solid ${theme.palette.divider}`,\r\n                        borderRadius: 1,\r\n                        bgcolor: \"background.paper\",\r\n                        color: \"text.secondary\",\r\n                        \"& svg\": {\r\n                            m: 1.5,\r\n                        },\r\n                        \"& hr\": {\r\n                            mx: 0.5,\r\n                        },\r\n                    }}\r\n                    className={styles.button_group_menu}\r\n                >\r\n                    <Refresh isSecondWindowOpen={props.isSecondWindowOpen} />\r\n                    <Divider orientation=\"vertical\" variant=\"middle\" flexItem />\r\n                    <Search handleWindowSearch={handleWindowSearch} />\r\n                    <Settings {...props} />\r\n                    <TableOfContent {...props} />\r\n                </ButtonGroup>\r\n            </Stack>\r\n\r\n            <Collapse in={showFind}>\r\n                <form onSubmit={handleSearch}>\r\n                    <Stack direction=\"row\" spacing={2} position=\"relative\">\r\n                        <TextField\r\n                            hiddenLabel\r\n                            id=\"filled-hidden-label-small\"\r\n                            inputProps={{\r\n                                style: {\r\n                                    height: 25,\r\n                                    padding: \"0 14px\",\r\n                                },\r\n                            }}\r\n                            style={{ height: 25, flex: 1 }}\r\n                            fullWidth\r\n                            inputRef={inputRef}\r\n                            value={findvalue}\r\n                            onChange={(e) => setfindvalue(e.target.value)}\r\n                        />\r\n\r\n                        <Button\r\n                            variant=\"outlined\"\r\n                            size=\"small\"\r\n                            onClick={handleSearch}\r\n                            style={{ height: 25 }}\r\n                        >\r\n                            Search\r\n                        </Button>\r\n\r\n                        {props.searchResults && visible && (\r\n                            <Box\r\n                                sx={{\r\n                                    position: \"absolute\",\r\n                                    top: 35,\r\n                                    right: 0,\r\n                                    zIndex: 1,\r\n                                    background: \"#eee\",\r\n                                    height: 350,\r\n                                    width: 350,\r\n                                    boxShadow: 3,\r\n                                    overflowX: \"hidden\",\r\n                                    boxShadow: 3,\r\n                                }}\r\n                            >\r\n                                {results.length === 0 && (\r\n                                    <p>no such word present</p>\r\n                                )}\r\n                                {condition && results.length > 0 && (\r\n                                    <SearchList\r\n                                        handleListItemClick={\r\n                                            handleListItemClick\r\n                                        }\r\n                                        searchValue={props.searchValue}\r\n                                        results={results}\r\n                                        selectedText={props.selectedText}\r\n                                    />\r\n                                )}\r\n                                <IconButton\r\n                                    aria-label=\"closeButton\"\r\n                                    onClick={closeSearchItemBox}\r\n                                    size=\"small\"\r\n                                    sx={{\r\n                                        right: 15,\r\n                                        top: 0,\r\n                                        position: \"absolute\",\r\n                                    }}\r\n                                >\r\n                                    <CloseIcon fontSize=\"inherit\" />\r\n                                </IconButton>\r\n                            </Box>\r\n                        )}\r\n                    </Stack>\r\n                </form>\r\n            </Collapse>\r\n        </Stack>\r\n    );\r\n}\r\n\r\nexport default React.memo(TextDetailHeading);\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport TextDetailHeading from \"./TextDetailHeading\";\r\nimport * as actions from \"actions\";\r\nimport * as reducers from \"reducers\";\r\nimport type { AppState } from \"reducers\";\r\nimport { getTextListVisible, getAccountOverlayVisible } from \"reducers\";\r\n\r\nconst mapStateToProps = (state: AppState): {} => {\r\n    const selectedText = reducers.getSelectedText(state);\r\n    const selectedText2 = reducers.getSelectedText2(state);\r\n    let witnesses = [];\r\n    let exportingWitness = false;\r\n    let selectedWitness;\r\n    let selectedWitness2;\r\n\r\n    if (selectedText) {\r\n        witnesses = reducers.getTextWitnesses(state, selectedText.id);\r\n        const selectedWitnessId = reducers.getSelectedTextWitnessId(\r\n            state,\r\n            selectedText.id\r\n        );\r\n        if (selectedWitnessId) {\r\n            selectedWitness = reducers.getWitness(state, selectedWitnessId);\r\n            exportingWitness = reducers.getExportingWitness(\r\n                state,\r\n                selectedWitnessId\r\n            );\r\n        } else {\r\n            selectedWitness = reducers.getWorkingWitness(\r\n                state,\r\n                selectedText.id\r\n            );\r\n        }\r\n    }\r\n\r\n    if (selectedText2) {\r\n        // witnesses = reducers.getTextWitnesses(state, selectedText2.id);\r\n        const selectedWitnessId2 = reducers.getSelectedTextWitnessId2(\r\n            state,\r\n            selectedText2.id\r\n        );\r\n        if (selectedWitnessId2) {\r\n            selectedWitness2 = reducers.getWitness2(state, selectedWitnessId2);\r\n        } else {\r\n            selectedWitness2 = reducers.getWorkingWitness2(\r\n                state,\r\n                selectedText2.id\r\n            );\r\n        }\r\n    }\r\n\r\n    let textFontSize = reducers.getTextFontSize(state);\r\n    let searchValue = reducers.getSearchValue(state);\r\n    return {\r\n        witnesses,\r\n        selectedText,\r\n        selectedText2,\r\n        selectedWitness,\r\n        selectedWitness2,\r\n        textListIsVisible: getTextListVisible(state),\r\n        accountOverlayVisible: getAccountOverlayVisible(state),\r\n        textFontSize,\r\n        isSecondWindowOpen: reducers.isSecondWindowOpen(state),\r\n        exportingWitness,\r\n        isPanelLinked: reducers.isPanelLinked(state),\r\n        user: reducers.getUser(state),\r\n        isAnnotating: reducers.isAnnotating(state),\r\n        searchValue,\r\n        showTableContent: reducers.getShowTableContent(state),\r\n        searchResults: reducers.getSearchResults(state, searchValue),\r\n    };\r\n};\r\n\r\nconst mergeProps = (stateProps, dispatchProps, ownProps) => {\r\n    const navigationButtonClicked = () => {\r\n        dispatchProps.dispatch(\r\n            actions.changedTextListVisible(!stateProps.textListIsVisible)\r\n        );\r\n    };\r\n\r\n    const { dispatch } = dispatchProps;\r\n    const { selectedText } = stateProps;\r\n\r\n    return {\r\n        ...ownProps,\r\n        ...stateProps,\r\n        navigationButtonClicked,\r\n        onSelectedWitness: (witness: Witness) => {\r\n            dispatch(\r\n                actions.selectedTextWitness(selectedText?.id, witness?.id)\r\n            );\r\n        },\r\n        onChangedFontSize: (fontSize: number) => {\r\n            dispatch(actions.changedTextFontSize(fontSize));\r\n        },\r\n        onChangeWindowOpen: (data: boolean, textId) => {\r\n            dispatch(actions.toggleSecondWindow(data, textId));\r\n        },\r\n        onExport: () => {\r\n            dispatch(\r\n                actions.exportWitness(stateProps.selectedWitness.id, \"docx\")\r\n            );\r\n        },\r\n        navigationButtonClicked: () => {\r\n            dispatch(\r\n                actions.changedTextListVisible(!stateProps.textListIsVisible)\r\n            );\r\n        },\r\n        onChangePanelLink: (data: boolean) => {\r\n            dispatch(actions.changePanelLink(data));\r\n        },\r\n        changeIsAnnotating: (payload) => {\r\n            dispatch(actions.changeIsAnnotating(payload));\r\n            if (payload === false) {\r\n                const dismissTextAnnotation =\r\n                    actions.changedActiveTextAnnotation(null);\r\n                dispatch(dismissTextAnnotation);\r\n                dispatch(actions.changedActiveTextAnnotation(null));\r\n            }\r\n        },\r\n        searchChanged: (searchTerm: string) => {\r\n            dispatch(actions.changedSearchValue(searchTerm));\r\n        },\r\n        changeShowTableContent: (payload) => {\r\n            dispatch(actions.showTableContent(payload));\r\n        },\r\n        changeSelectSyncId: (payload) => {\r\n            dispatch(actions.changeSyncIdOnSearch(payload));\r\n        },\r\n    };\r\n};\r\n\r\nconst TextDetailHeadingContainer = connect(\r\n    mapStateToProps,\r\n    null,\r\n    mergeProps\r\n)(TextDetailHeading);\r\n\r\nexport default TextDetailHeadingContainer;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"textlist\":\"TextList---textlist\",\"open\":\"TextList---open\",\"listToggelBtn\":\"TextList---listToggelBtn\"};","import React, { useState, useRef } from \"react\";\r\nimport {\r\n    List,\r\n    AutoSizer,\r\n    CellMeasurer,\r\n    CellMeasurerCache,\r\n} from \"react-virtualized\";\r\nimport classname from \"classnames\";\r\nimport styles from \"./TextList.css\";\r\nimport { TextField, ClickAwayListener, Box, Typography } from \"@mui/material\";\r\nimport addShay from \"lib/addTibetanShay\";\r\n\r\nfunction TextList(props) {\r\n    const temptext = useRef(props.texts);\r\n    const [textslist, setTextList] = useState(temptext.current);\r\n    const onSelectedText = props.onSelectedText;\r\n    const selectedText = props.selectedText;\r\n    const [isOpen, setIsOpen] = useState(false);\r\n    let selected = selectedText ? selectedText.name : textslist[0].name;\r\n    const cache = useRef(\r\n        new CellMeasurerCache({\r\n            fixedHeight: true,\r\n            defaultHeight: 30,\r\n            defaultWidth: 400,\r\n        })\r\n    );\r\n\r\n    let classes = [styles.textlist];\r\n\r\n    const handleClick = () => {\r\n        setIsOpen((prev) => !prev);\r\n        if (isOpen === false) classes.push(styles.open);\r\n    };\r\n    const handleChange = (e) => {\r\n        let value = e.target.value;\r\n        setTextList(temptext.current);\r\n        if (value === \"\" || value === null) {\r\n            return;\r\n        }\r\n\r\n        let newtextslist = textslist.filter((l) => l.name.includes(value));\r\n        setTextList(newtextslist);\r\n    };\r\n\r\n    return (\r\n        <ClickAwayListener onClickAway={() => setIsOpen(false)}>\r\n            <div style={{ position: \"relative\", border: \"1px solid #eee\" }}>\r\n                <Box\r\n                    onClick={handleClick}\r\n                    className={styles.listToggelBtn}\r\n                    component=\"div\"\r\n                    sx={{\r\n                        overflow: \"hidden\",\r\n                        textOverflow: \"ellipsis\",\r\n                        width: \"10rem\",\r\n                        height: \"100%\",\r\n                    }}\r\n                >\r\n                    <Typography noWrap={true}>{selected}</Typography>\r\n                </Box>\r\n                {isOpen && (\r\n                    <div\r\n                        className={classname(classes)}\r\n                        style={{ position: \"absolute\" }}\r\n                    >\r\n                        <TextField\r\n                            onChange={handleChange}\r\n                            id=\"standard-basic\"\r\n                            label=\"filter\"\r\n                            variant=\"standard\"\r\n                            style={{ width: \"100%\" }}\r\n                        />\r\n                        <AutoSizer>\r\n                            {({ width, height }) => (\r\n                                <List\r\n                                    width={width}\r\n                                    height={height}\r\n                                    rowHeight={cache.current.rowHeight}\r\n                                    deferredMeasurementCache={cache.current}\r\n                                    rowCount={textslist.length}\r\n                                    rowRenderer={({\r\n                                        key,\r\n                                        index,\r\n                                        style,\r\n                                        parent,\r\n                                    }) => {\r\n                                        let data = textslist[index];\r\n                                        return (\r\n                                            <CellMeasurer\r\n                                                key={`optionvalues-${key}`}\r\n                                                cache={cache.current}\r\n                                                parent={parent}\r\n                                                columnIndex={0}\r\n                                                rowIndex={index}\r\n                                            >\r\n                                                <div\r\n                                                    style={style}\r\n                                                    onClick={() => {\r\n                                                        setIsOpen(false);\r\n                                                        onSelectedText(data);\r\n                                                    }}\r\n                                                >\r\n                                                    <Box\r\n                                                        sx={{\r\n                                                            overflow: \"hidden\",\r\n                                                            textOverflow:\r\n                                                                \"ellipsis\",\r\n                                                            width: \"13rem\",\r\n                                                            paddingLeft: 2,\r\n                                                            fontSize: {\r\n                                                                lg: 12,\r\n                                                                md: 11,\r\n                                                                sm: 10,\r\n                                                                xs: 10,\r\n                                                            },\r\n                                                        }}\r\n                                                        component=\"div\"\r\n                                                    >\r\n                                                        <Typography\r\n                                                            noWrap={true}\r\n                                                        >\r\n                                                            {addShay(data.name)}\r\n                                                        </Typography>\r\n                                                    </Box>\r\n                                                </div>\r\n                                            </CellMeasurer>\r\n                                        );\r\n                                    }}\r\n                                />\r\n                            )}\r\n                        </AutoSizer>\r\n                    </div>\r\n                )}\r\n            </div>\r\n        </ClickAwayListener>\r\n    );\r\n}\r\n\r\nexport default TextList;\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport TextList from \"./TextList\";\r\nimport * as actions from \"actions\";\r\nimport { getSelectedText } from \"reducers\";\r\nimport type { AppState } from \"reducers\";\r\nimport * as api from \"api\";\r\nimport * as reducers from \"reducers\";\r\nimport { batchActions } from \"redux-batched-actions\";\r\n\r\nconst mapStateToProps = (state: AppState) => {\r\n    const searchValue = reducers.getSearchValue(state);\r\n    const searchResults = reducers.getSearchResults(state, searchValue);\r\n    const selectedSearchResult = reducers.getSelectedSearchResult(state);\r\n    // TODO: display search results or spinner depending on when anything\r\n    // returned\r\n    let searching = false;\r\n    let texts = reducers.getTexts(state);\r\n    if (searchValue.length > 0) {\r\n        if (searchResults === null) {\r\n            searching = true;\r\n            texts = [];\r\n        } else {\r\n            texts = texts.filter((text) =>\r\n                searchResults.hasOwnProperty(text.id)\r\n            );\r\n        }\r\n    }\r\n    return {\r\n        texts: texts,\r\n        selectedText: getSelectedText(state),\r\n        searchTerm: searchValue,\r\n        searchResults,\r\n        selectedSearchResult,\r\n        searching,\r\n    };\r\n};\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        onSelectedText: (text: api.TextData) => {\r\n            dispatch(actions.selectedText(text));\r\n        },\r\n    };\r\n};\r\n\r\nconst TextListContainer = connect(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(TextList);\r\n\r\nexport default TextListContainer;\r\n","export { default } from \"./TextDetail\";\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"button_group_menu\":\"textDetailHeading---button_group_menu\"};","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\n\nvar _ref =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3 0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9 0l60.1 60.1c18.8 18.7 18.8 49.1 0 67.9zM284.2 99.8L21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3 0-17l-111-111c-4.8-4.7-12.4-4.7-17.1 0zM124.1 339.9c-5.5-5.5-5.5-14.3 0-19.8l154-154c5.5-5.5 14.3-5.5 19.8 0s5.5 14.3 0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8 0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z\"\n});\n\nvar SvgPencilAltIcon = function SvgPencilAltIcon(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 512 512\"\n  }, props), _ref);\n};\n\nexport default SvgPencilAltIcon;","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\n\nvar _ref =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M0 0h24v24H0z\",\n  fill: \"none\"\n});\n\nvar _ref2 =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"\n});\n\nvar SvgCheckCircle = function SvgCheckCircle(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 24 24\"\n  }, props), _ref, _ref2);\n};\n\nexport default SvgCheckCircle;","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\n\nvar _ref =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M3 18h12v-2H3v2zM3 6v2h18V6H3zm0 7h18v-2H3v2z\"\n});\n\nvar _ref2 =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"none\",\n  d: \"M0 0h24v24H0V0z\"\n});\n\nvar SvgNote = function SvgNote(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 24 24\"\n  }, props), _ref, _ref2);\n};\n\nexport default SvgNote;","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\n\nvar _ref =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M3 0h24v15H3z\"\n});\n\nvar _ref2 =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  stroke: \"currentColor\",\n  strokeWidth: 3,\n  d: \"M0 20h8M11 20h8M22 20h8\"\n});\n\nvar _ref3 =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M3 25h24v15H3z\"\n});\n\nvar SvgPageBreakIcon = function SvgPageBreakIcon(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 30 40\",\n    fill: \"currentColor\"\n  }, props), _ref, _ref2, _ref3);\n};\n\nexport default SvgPageBreakIcon;","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\n\nvar _ref =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M0 0h24v24H0z\",\n  fill: \"none\"\n});\n\nvar _ref2 =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z\"\n});\n\nvar SvgQuestionAnswer = function SvgQuestionAnswer(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 24 24\",\n    fill: \"currentColor\"\n  }, props), _ref, _ref2);\n};\n\nexport default SvgQuestionAnswer;","export default function shallowEqual(objA, objB) {\r\n    if (objA === objB) {\r\n        return true;\r\n    }\r\n\r\n    let aKeys = Object.keys(objA);\r\n    let bKeys = Object.keys(objB);\r\n    let len = aKeys.length;\r\n\r\n    if (bKeys.length !== len) {\r\n        return false;\r\n    }\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        let key = aKeys[i];\r\n\r\n        if (objA[key] !== objB[key]) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n","// @flow\r\nimport type { Splitter } from \"lib/SplitText\";\r\n\r\n/**\r\n * Returns a function that accepts a string but simply\r\n * returns the initial array of positions passed to it.\r\n *\r\n * @param positions - The positions where a string should be split\r\n */\r\nexport default function positionSplitter(positions: number[]): Splitter {\r\n    const newPositions = [...positions];\r\n    if (newPositions[0] === 0) {\r\n        newPositions.shift();\r\n    }\r\n    return string => newPositions;\r\n}\r\n"],"mappings":";;;;;;;;;AAAA;AACA;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;;;;;;;;;;;AChBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AA8CA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;;;;;AAKA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AACA;AALA;AAMA;AACA;;;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAOA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAAA;AACA;AAOA;AACA;AACA;AACA;AACA;;;AAEA;AAWA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AAjBA;AAoBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAtBA;AACA;AAwBA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAUA;AACA;AACA;AAEA;AAAA;AAHA;AAFA;AAYA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAKA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AARA;AAYA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAOA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AAKA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AANA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAFA;AAQA;AAGA;AAGA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAsBA;AAAA;AAeA;AACA;AAAA;AAAA;AAFA;AAMA;;;;AA1lBA;AACA;AA4lBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1qBA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AASA;AAMA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAFA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAAA;AAEA;AACA;AAAA;AAIA;AACA;AACA;AACA;AA3CA;AACA;AACA;AAAA;AA0CA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AAQA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AASA;AAMA;AACA;AAAA;AAEA;AACA;AAKA;AAOA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAQA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AAGA;AAAA;AAIA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAUA;AAIA;AAEA;AACA;AACA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAYA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AAKA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAAA;AACA;AAMA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAMA;AACA;AACA;AAIA;AAMA;AAGA;AAMA;AACA;AACA;AAIA;AAMA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAMA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AAGA;AACA;AACA;AAWA;AAGA;AACA;AACA;AACA;AACA;AACA;AAWA;AAGA;AACA;AAKA;AAAA;AAAA;AAAA;AACA;AAEA;AAGA;AAEA;AACA;AAKA;AACA;AArQA;AAuQA;AACA;AACA;AAMA;;;;;;;;;;;ACh0BA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AAAA;;;;;AACA;AAAA;AACA;AADA;AAEA;AACA;;;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAMA;AATA;AAWA;AACA;AACA;AACA;AAdA;AAiBA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAHA;AAUA;AACA;AACA;AACA;AACA;AAdA;AAiBA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAVA;AAaA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAHA;AAUA;AACA;AACA;AACA;AACA;AAdA;AAkBA;AADA;AAGA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAMA;AAXA;AAsBA;;;;AA9FA;AACA;AAgGA;;;;;;;;;;;ACpHA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AAQA;;;;;;;;;;;;;AACA;AACA;AACA;AAAA;AACA;AAEA;AADA;AAIA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAGA;;;;AArBA;AACA;AAuBA;;;;;;;;;;;ACrCA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAUA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AAHA;AAUA;AAAA;AAAA;AACA;AACA;AACA;AAJA;AAcA;AACA;AACA;;;;;;;;;;;;AC7GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAMA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AAAA;AAGA;AACA;AAFA;AAIA;AAAA;AAMA;AACA;AACA;;;;;;;;;;;AC3DA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;;;;;;;;;;;;;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AADA;AAFA;AAMA;AAAA;AACA;AAAA;AAEA;AAAA;AAIA;;;;AAjBA;AACA;;;;;;;;;;;;ACdA;AACA;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAFA;AADA;AAAA;AAMA;AACA;AACA;AACA;AADA;AADA;AADA;AACA;AAOA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAAA;AAAA;AARA;AAUA;AAAA;AAMA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AAQA;;;;;AACA;AAAA;AACA;AADA;AAEA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AAAA;AADA;AAMA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;;;AAvCA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAJA;AASA;AACA;AACA;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAJA;AASA;AACA;AACA;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAFA;AACA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAOA;AAAA;AAGA;AACA;AAAA;AAAA;AAFA;AAKA;AACA;AACA;AAHA;AAUA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AADA;AAeA;AACA;AACA;;;;;;;;;;;ACpEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAJA;AAMA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAFA;AAWA;AACA;AACA;AACA;AAJA;AAOA;AAAA;AAAA;AAAA;AACA;AAAA;AAOA;AAAA;AAAA;AADA;AAMA;AAAA;AASA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AAQA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AALA;AAOA;AAAA;AAKA;AACA;AAHA;AAOA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAUA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAGA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AADA;AAaA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAFA;AAUA;;;;;;;;;;;;ACrHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAKA;AACA;AACA;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAFA;AADA;AAAA;AAMA;AACA;AACA;AACA;AADA;AADA;AADA;AACA;AAOA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AATA;AAWA;AAAA;AAMA;AACA;AACA;;;;;;;;;;;AC3CA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AAOA;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAKA;AACA;AAFA;AAQA;AAAA;AAAA;AAKA;;;;AAlCA;AACA;;;;;;;;;;;;ACZA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AAWA;;;;;AAGA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AADA;AAHA;AAMA;AACA;;;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AADA;AAGA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AANA;AAQA;AAAA;AAEA;AACA;AAFA;AAIA;AAAA;AAGA;AACA;AAFA;AAIA;AAAA;AAKA;;;;AAzDA;AACA;;;;;;;;;;;;AClBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AAiBA;;;;;AAGA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AADA;AAHA;AAMA;AACA;;;AACA;AACA;AAEA;AAKA;;;AAEA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AADA;AAGA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AAGA;AACA;AANA;AAQA;AAAA;AAEA;AACA;AAFA;AAIA;AAAA;AAGA;AACA;AAFA;AAIA;AAAA;AAKA;;;;AA/DA;AACA;;;;;;;;;;;;ACvBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAKA;AACA;AAAA;AAEA;AADA;AAMA;AAAA;AAAA;AACA;AAAA;AAIA;AACA;AACA;AADA;AAFA;AAMA;AAAA;AAEA;AAAA;AAKA;;;;AA1CA;AACA;;;;;;;;;;;;AChBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAcA;;;;AAlBA;AACA;;;;;;;;;;;;ACTA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AALA;AAWA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AASA;AAGA;AACA;AACA;;;;;;;;;;;AC1FA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AAIA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AA+CA;;;;;AAiBA;AA4BA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/BA;AAgCA;AACA;;;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAGA;AAAA;AACA;AAAA;AAEA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AAOA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AACA;AADA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAEA;AAEA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AAIA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AADA;AAJA;AASA;AACA;AAAA;AAAA;AACA;AAHA;AAMA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AADA;AAiBA;;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAEA;AAUA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAFA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAOA;AAAA;AAkCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9BA;AAqCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAiBA;;;;AAhiCA;AACA;;;;;;;;;;;;;AC3FA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAKA;AACA;AACA;;;;;;;;;;;ACZA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AA+BA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AATA;AAUA;AACA;;;AAAA;AACA;AACA;AAEA;AAFA;AAIA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAIA;AAKA;AAMA;;;AAEA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AASA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAUA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AASA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AAGA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AARA;AAYA;;;;AAzdA;AACA;;;;;;;;;;;;ACnFA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AA+CA;AACA;AACA;;;;;AAIA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AAJA;AAKA;AACA;;;AACA;AACA;AACA;;;AACA;AACA;AAIA;;;AACA;AACA;AACA;;;AACA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAKA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxCA;AA2CA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AAKA;AACA;AAXA;AAcA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAJA;AADA;AASA;AAAA;AAAA;AACA;AAFA;AAUA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AADA;AAiBA;;;;AAxJA;AACA;AA0JA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClOA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAOA;AACA;AAKA;AAiCA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAjEA;AACA;AAWA;AAAA;AACA;AADA;AAsDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAKA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AACA;AADA;AACA;AAqBA;AAAA;AACA;AAKA;AACA;AAIA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AAIA;AAIA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtCA;AAwCA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AANA;AAAA;AACA;AADA;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AArBA;AAAA;AAAA;AAAA;AAAA;AACA;AAqBA;AAEA;AAAA;AACA;AAEA;AAGA;AAAA;AACA;AAEA;AACA;AAKA;AACA;AAIA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AAIA;AACA;AAAA;AAUA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAzJA;AA2JA;AACA;AACA;AAIA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AADA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAQA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAHA;AACA;AADA;AACA;AAIA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACttBA;AAOA;AACA;AAEA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuBA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAKA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AANA;AAQA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAJA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AADA;AAbA;AAiBA;AApBA;AAsBA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAMA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AADA;AAMA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAbA;AAiBA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AADA;AAmBA;AAGA;AACA;AACA;AANA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAJA;AAUA;AAAA;AASA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACvOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAnBA;AAqBA;AAGA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAMA;;;;;;;;;;;AC5IA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAHA;AAOA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAJA;AAWA;AAAA;AAIA;AACA;AAAA;AAAA;AAFA;AAKA;AACA;AACA;AACA;AACA;AAAA;AAAA;AALA;AAQA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AANA;AAaA;AAdA;AAiBA;AADA;AASA;AArDA;AADA;AA+DA;AACA;AACA;;;;;;;;;;;;ACzIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAKA;;;;;;;;;;;;ACpDA;AAAA;AAAA;AAAA;;;;;;;;;;;;ACAA;AACA;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;;;A","sourceRoot":""}