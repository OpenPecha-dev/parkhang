{"version":3,"file":"47.parkhang-dev.js","sources":["webpack://parkhang/./app/components/TextDetail/SplitText.css","webpack://parkhang/./app/components/TextDetail/SplitText.js","webpack://parkhang/./app/images/lopenling_logo.png","webpack://parkhang/./app/lib/shallowEqual.js","webpack://parkhang/./node_modules/@mui/icons-material/Delete.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"inlineWidth\":\"280px\",\"annotationControls\":\"SplitText---annotationControls\",\"annotationContent\":\"SplitText---annotationContent\",\"subTitle\":\"SplitText---subTitle\",\"title\":\"SplitText---title\",\"sectionHeading\":\"SplitText---sectionHeading\",\"text\":\"SplitText---text\",\"padding\":\"SplitText---padding\",\"arrowTop\":\"SplitText---arrowTop\",\"arrowLeft\":\"SplitText---arrowLeft\",\"arrowRight\":\"SplitText---arrowRight\",\"inline\":\"SplitText---inline\",\"arrow\":\"SplitText---arrow\",\"arrowDs\":\"SplitText---arrowDs\",\"nothingSelected\":\"SplitText---nothingSelected\",\"anonymousMessage\":\"SplitText---anonymousMessage\",\"noNotes\":\"SplitText---noNotes\",\"breakButtons\":\"SplitText---breakButtons\",\"splitText\":\"SplitText---splitText\",\"splitTextRowContent\":\"SplitText---splitTextRowContent\",\"splitTextRow\":\"SplitText---splitTextRow\",\"pechaImage\":\"SplitText---pechaImage\",\"image\":\"SplitText---image\",\"controlsPlaceholder\":\"SplitText---controlsPlaceholder\",\"hide\":\"SplitText---hide\",\"pageNumber\":\"SplitText---pageNumber\",\"image-loading\":\"SplitText---image-loading\"};","// @flow\r\nimport * as React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { AutoSizer } from \"react-virtualized/dist/es/AutoSizer\";\r\nimport { List } from \"react-virtualized/dist/es/List\";\r\nimport lopenlinglogo from \"images/lopenling_logo.png\";\r\nimport {\r\n    CellMeasurer,\r\n    CellMeasurerCache,\r\n} from \"react-virtualized/dist/es/CellMeasurer\";\r\nimport \"react-virtualized/styles.css\";\r\nimport Text, {\r\n    idForSegment,\r\n    idForDeletedSegment,\r\n    idForInsertion,\r\n    idForPageBreak,\r\n    idForLineBreak,\r\n} from \"./Text\";\r\nimport SplitText from \"lib/SplitText\";\r\nimport SegmentedText from \"lib/SegmentedText\";\r\nimport shallowEqual from \"lib/shallowEqual\";\r\nimport { CONTROLS_MARGIN_LEFT } from \"./AnnotationControls\";\r\nimport AnnotationControlsContainer from \"./AnnotationControlsContainer\";\r\nimport styles from \"./SplitText.css\";\r\nimport annotationControlsStyles from \"./AnnotationControls.css\";\r\nimport controlStyles from \"./AnnotationControls.css\";\r\nimport _ from \"lodash\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport Annotation, { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport Witness from \"lib/Witness\";\r\nimport GraphemeSplitter from \"grapheme-splitter\";\r\nimport { TransformWrapper, TransformComponent } from \"react-zoom-pan-pinch\";\r\n\r\nconst MIN_SPACE_RIGHT =\r\n    parseInt(controlStyles.inlineWidth) + CONTROLS_MARGIN_LEFT;\r\n\r\nconst IMAGE_URL_PREFIX = \"//iiif.bdrc.io/\";\r\nconst IMAGE_URL_SUFFIX = \"/full/full/0/default.jpg\";\r\nconst IMAGE_START_PRE_KEY = \"bdrcimg_pre\";\r\nconst IMAGE_START_NUMBER_KEY = \"bdrcimg_number\";\r\nconst IMAGE_START_SUFFIX_KEY = \"bdrcimg_suffix\";\r\n\r\nlet _searchResultsCache: {\r\n    [splitTextUniqueId: string]: {\r\n        [searchTerm: string]: {\r\n            [index: number]: { [position: number]: [number, number] },\r\n        },\r\n    },\r\n} = {};\r\nfunction HttpUrl(data = \"\") {\r\n    if (data.includes(\"https\")) return data;\r\n    return \"https://\" + data;\r\n}\r\nexport type Props = {\r\n    textListVisible: boolean,\r\n    editMenuVisible: Boolean,\r\n    imagesBaseUrl: string,\r\n    splitText: SplitText,\r\n    didSelectSegmentIds: (segmentIds: string[]) => void,\r\n    limitWidth: boolean,\r\n    activeAnnotation: Annotation | null,\r\n    selectedAnnotatedSegments: Array<TextSegment | number>,\r\n    showImages: boolean,\r\n    annotationPositions: { [string]: Annotation[] },\r\n    annotations: Annotation[],\r\n    activeAnnotations: { [AnnotationUniqueId]: Annotation } | null,\r\n    selectedSegmentId: (segmentId: string) => void,\r\n    selectedWitness: Witness | null,\r\n    selectedWitness2: Witness | null,\r\n    selectedSearchResult: {\r\n        textId: number,\r\n        start: number,\r\n        length: number,\r\n    } | null,\r\n    searchValue: string | null,\r\n    fontSize: number,\r\n    isSecondWindowOpen: Boolean,\r\n    changeScrollToId: () => void,\r\n    changeSyncIdOnClick: () => void,\r\n    closeAnnotation: () => void,\r\n    imageData: {},\r\n    syncIdOnClick: Number,\r\n    isPanelLinked: Boolean,\r\n    isPanelVisible: Boolean,\r\n    textAlignment: {},\r\n    textAlignmentById: {},\r\n    selectedWindow: Boolean,\r\n    scrollToId: Number,\r\n    selectedTargetRange: [],\r\n    selectedSourceRange: [],\r\n    searchResults: [],\r\n    showTableContent: Boolean,\r\n    syncIdOnSearch: String,\r\n    imageAlignmentById: [],\r\n    changeImageScrollId: () => void,\r\n    condition: Boolean,\r\n};\r\n\r\nexport default class SplitTextComponent extends React.PureComponent<Props> {\r\n    isSecondWindowOpen: Boolean;\r\n    list: List | null;\r\n    splitText: HTMLDivElement | null;\r\n    cache: CellMeasurerCache;\r\n    rowRenderer: (params: {\r\n        key: string,\r\n        index: number,\r\n        parent: {},\r\n        style: {},\r\n    }) => React.Element<CellMeasurer>;\r\n    resizeHandler: () => void;\r\n    selectionHandler: (e: Event) => void;\r\n    textListVisible: boolean;\r\n    editMenuVisible: Boolean;\r\n    activeSelection: Selection | null;\r\n    selectedNodes: Node[] | null;\r\n    // Whether the mouse button is down\r\n    _mouseDown: boolean;\r\n    _activeWitness: Witness | null;\r\n    _didSetInitialScrollPosition: boolean;\r\n    _filteredSelectedAnnotatedSegments: TextSegment[];\r\n    _modifyingSelection: boolean;\r\n    selectedTextIndex: number | null;\r\n    splitTextRect: ClientRect | null;\r\n    firstSelectedSegment: TextSegment | null;\r\n    selectedElementId: string | null;\r\n    selectedElementIds: string[] | null;\r\n    imageWidth: number | null;\r\n    imageHeight: number | null;\r\n    calculatedImageHeight: number | null;\r\n    changeScrollToId: () => void;\r\n    changeImageScrollId: () => void;\r\n    changeSyncIdOnClick: () => void;\r\n    wheelScrolling: () => void;\r\n    closeAnnotation: () => void;\r\n    textlines: Node[] | null;\r\n    jump: number;\r\n    isPanelLinked: Boolean;\r\n    splitTextRef;\r\n    textAlignmentById;\r\n    scrollEvent: () => void;\r\n    selectedWindow;\r\n    debouncedScroll;\r\n    targetId;\r\n    condition;\r\n    imageAlignmentById;\r\n    changeImageScrollId;\r\n    imageData;\r\n    constructor(props: Props) {\r\n        super(props);\r\n        this.textAlignmentById = [];\r\n        this.childRef = React.createRef(\"0\");\r\n        this.list = null;\r\n        this.splitText = null;\r\n        this.cache = new CellMeasurerCache({\r\n            fixedWidth: true,\r\n        });\r\n        this.imageAlignmentById = this.props.imageAlignmentById;\r\n        this.changeImageScrollId = this.props.changeImageScrollId;\r\n        this.splitTextRef = React.createRef(null);\r\n        this.rowRenderer = this.rowRenderer.bind(this);\r\n        this.textListVisible = props.textListVisible;\r\n        this.editMenuVisible = props.editMenuVisible;\r\n        this.isPanelLinked = props.isPanelLinked;\r\n        this.activeSelection = null;\r\n        this.selectedNodes = null;\r\n        this._mouseDown = false;\r\n        this._activeWitness = null;\r\n        this._didSetInitialScrollPosition = false;\r\n        this._modifyingSelection = false;\r\n        this.imageHeight = null;\r\n        this.imageWidth = null;\r\n        this.calculatedImageHeight = null;\r\n        this.processProps(props);\r\n        this.changeScrollToId = props.changeScrollToId;\r\n        this.changeSyncIdOnClick = props.changeSyncIdOnClick;\r\n        this.closeAnnotation = props.closeAnnotation;\r\n        this.scrollJump = props.scrollJump;\r\n        this.textAlignmentById = [];\r\n        this.scrollEvent = this.scrollEvent.bind(this);\r\n        this.selectedWindow = props.selectedWindow;\r\n        this.changeImageScrollId = props.changeImageScrollId;\r\n        this.imageData = props.imageData;\r\n    }\r\n\r\n    scrollEvent(e) {\r\n        if (this.selectedWindow === 2) return null;\r\n        if (this.selectedWindow === 1 && this.isPanelLinked) {\r\n            let list = [];\r\n            let imageIdList = [];\r\n            this.textAlignmentById.map((l) => {\r\n                let number = document.getElementById(\"s_\" + l.start);\r\n                if (number) {\r\n                    let position = number.getBoundingClientRect();\r\n                    if (position.top > 102) {\r\n                        list.push({\r\n                            id: l.id,\r\n                            start: l.start,\r\n                            target: l.TStart,\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n            this.imageAlignmentById.map((l) => {\r\n                let number = document.getElementById(\"s_\" + l?.start);\r\n                if (number) {\r\n                    let position = number.getBoundingClientRect();\r\n                    if (position.top > 102) {\r\n                        imageIdList.push({\r\n                            id: l.id,\r\n                            start: l.start,\r\n                            end: l.end,\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n            if (!_.isEmpty(list) || !_.isEmpty(imageIdList)) {\r\n                if (this.selectedWindow === 1) {\r\n                    this.debouncedScroll(list, imageIdList);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    updateList(\r\n        resetCache: boolean = true,\r\n        resetRows: number | number[] | null = null\r\n    ) {\r\n        if (\r\n            this.props.showImages &&\r\n            !this.calculatedImageHeight &&\r\n            this.imageHeight &&\r\n            this.imageWidth\r\n        ) {\r\n            this.calculatedImageHeight = this.calculateImageHeight();\r\n        }\r\n        if (this.list) {\r\n            const list = this.list;\r\n            if (resetCache) {\r\n                if (resetRows !== null) {\r\n                    if (!Array.isArray(resetRows)) {\r\n                        this.cache.clear(resetRows);\r\n                    } else if (Array.isArray(resetRows)) {\r\n                        for (let i = 0; i < resetRows.length; i++) {\r\n                            let resetRow = resetRows[i];\r\n                            this.cache.clear(resetRow);\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.cache.clearAll();\r\n                    list.measureAllRows();\r\n                    list.recomputeRowHeights(0);\r\n                }\r\n            }\r\n            list.forceUpdateGrid();\r\n        }\r\n    }\r\n\r\n    mouseDown() {\r\n        this._mouseDown = true;\r\n    }\r\n\r\n    mouseUp() {\r\n        this._mouseDown = false;\r\n        if (this.activeSelection) {\r\n            let segmentIds = this.processSelection(this.activeSelection);\r\n            if (!segmentIds) {\r\n                segmentIds = [];\r\n            }\r\n            this.props.didSelectSegmentIds(segmentIds);\r\n            this.activeSelection = null;\r\n        }\r\n    }\r\n    handleSelection(e: Event) {\r\n        if (!this._modifyingSelection) {\r\n            this.activeSelection = document.getSelection();\r\n            if (!this._mouseDown) {\r\n                // sometimes, this gets called after the mouseDown event handler\r\n                this.mouseUp();\r\n            }\r\n        } else {\r\n            e.stopPropagation();\r\n            // Need to set this here. If set at callsite, the event will not\r\n            // have time to propagate.\r\n            this._modifyingSelection = false;\r\n        }\r\n    }\r\n\r\n    processSelection(selection: Selection): string[] | null {\r\n        if (\r\n            selection.rangeCount === 0 ||\r\n            selection.isCollapsed ||\r\n            selection.type === \"Caret\"\r\n        ) {\r\n            this.selectedNodes = null;\r\n            return null;\r\n        }\r\n\r\n        const range = selection.getRangeAt(0);\r\n        const start = range.startContainer;\r\n        const startSpan = this.getNodeSegmentSpan(start);\r\n        if (!(startSpan && startSpan.parentNode)) {\r\n            // If the selection is not a text segment, ignore.\r\n            // Assuming if the first node is a non-segment, they\r\n            // all are.\r\n            return null;\r\n        }\r\n\r\n        let nodes = this.getRangeNodes(range, startSpan.parentNode);\r\n        // Check if the selection starts after the end of a node, and\r\n        // if so remove that node.\r\n        if (nodes.length > 0) {\r\n            let firstNode = nodes[0];\r\n            if (range.startOffset === firstNode.textContent.length) {\r\n                nodes.shift();\r\n            }\r\n        }\r\n\r\n        const end = range.endContainer;\r\n        const endSpan = this.getNodeSegmentSpan(end);\r\n        if (!(endSpan && endSpan.parentNode)) {\r\n            return null;\r\n        }\r\n        if (endSpan && startSpan.parentNode !== endSpan.parentNode) {\r\n            // Selection is spanning Texts.\r\n            // We assume a selection can only run across a maximum\r\n            // of two Texts.\r\n            nodes = nodes.concat(this.getRangeNodes(range, endSpan.parentNode));\r\n        } else {\r\n            // Check if the selection ends before the start of a node, and\r\n            // if so remove that node.\r\n            if (range.endOffset === 0) {\r\n                nodes.pop();\r\n            }\r\n        }\r\n        this.selectedNodes = nodes;\r\n        let nodeIds = [];\r\n        nodes.reduce((accumulator: string[], current: Node) => {\r\n            if (current instanceof Element) {\r\n                accumulator.push(current.id);\r\n            }\r\n            return accumulator;\r\n        }, nodeIds);\r\n        return nodeIds;\r\n    }\r\n\r\n    getNodeSegmentSpan(node: Node): Element | null {\r\n        let currentNode = node;\r\n        let span = null;\r\n        const test = /^(i|s|ds)_/;\r\n        while (!span && currentNode.parentNode) {\r\n            if (currentNode instanceof Element && test.test(currentNode.id)) {\r\n                span = currentNode;\r\n            }\r\n            currentNode = currentNode.parentNode;\r\n        }\r\n\r\n        return span;\r\n    }\r\n\r\n    getRangeNodes(range: Range, parentNode: Node): Node[] {\r\n        let rangeSpans = [];\r\n        for (let i = 0, len = parentNode.childNodes.length; i < len; i++) {\r\n            const node = parentNode.childNodes[i];\r\n            // TODO: add polyfill for i.e.?\r\n            // e.g. https://gist.github.com/jonathansampson/6d09bd6d2e8c22c53868aec42e66b0f9\r\n            if (range.intersectsNode(node)) {\r\n                rangeSpans.push(node);\r\n            }\r\n        }\r\n        return rangeSpans;\r\n    }\r\n\r\n    getControlsMeasurements(props: Props): {\r\n        selectedTextIndex: number,\r\n        firstSelectedSegment: TextSegment,\r\n        selectedElementId: string,\r\n        splitTextRect: ClientRect,\r\n        selectedElementIds: string[],\r\n    } | null {\r\n        if (!this.splitText) {\r\n            return null;\r\n        }\r\n        let splitTextComponent = this.splitText;\r\n        let selectedTextIndex = null;\r\n        let firstSelectedSegment = null;\r\n        let selectedElementId = null;\r\n        let splitTextRect = null;\r\n        let segmentIdFunction: null | ((segment: TextSegment) => string) = null;\r\n        let selectedElementIds = [];\r\n        let startPos = 0;\r\n        if (props.activeAnnotation) {\r\n            let activeAnnotation = props.activeAnnotation;\r\n            [startPos] =\r\n                props.splitText.annotatedText.getPositionOfAnnotation(\r\n                    activeAnnotation\r\n                );\r\n            if (startPos === null) {\r\n                console.warn(\"No startPos in getControlsMeasurements\");\r\n                return null;\r\n            }\r\n            if (activeAnnotation.type === ANNOTATION_TYPES.pageBreak) {\r\n                startPos -= 1;\r\n            }\r\n            if (activeAnnotation.type === ANNOTATION_TYPES.lineBreak) {\r\n                startPos -= 1;\r\n            }\r\n\r\n            // Index of text containing end of annotation\r\n            let positionEnd = startPos + activeAnnotation.length;\r\n            if (activeAnnotation.length > 0) positionEnd -= 1;\r\n            selectedTextIndex =\r\n                props.splitText.getTextIndexOfPosition(positionEnd);\r\n            splitTextRect = splitTextComponent.getBoundingClientRect();\r\n        }\r\n        let selectedAnnotatedSegments = [];\r\n        if (\r\n            props.selectedAnnotatedSegments &&\r\n            props.selectedAnnotatedSegments.length > 0\r\n        ) {\r\n            selectedAnnotatedSegments = props.selectedAnnotatedSegments;\r\n            for (let i = 0; i < selectedAnnotatedSegments.length; i++) {\r\n                let segment = selectedAnnotatedSegments[i];\r\n                if (\r\n                    firstSelectedSegment === null &&\r\n                    segment instanceof TextSegment\r\n                ) {\r\n                    firstSelectedSegment = segment;\r\n                    break;\r\n                }\r\n            }\r\n            if (firstSelectedSegment) {\r\n                if (\r\n                    firstSelectedSegment.length === 0 &&\r\n                    props.activeAnnotation &&\r\n                    props.activeAnnotation.isInsertion\r\n                ) {\r\n                    selectedElementId = idForInsertion(firstSelectedSegment);\r\n                    segmentIdFunction = idForInsertion;\r\n                } else {\r\n                    selectedElementId = idForSegment(firstSelectedSegment);\r\n                    segmentIdFunction = idForSegment;\r\n                }\r\n            }\r\n        } else if (props.activeAnnotation) {\r\n            if (props.activeAnnotation.isDeletion) {\r\n                let segment = new TextSegment(startPos, \"\");\r\n                selectedElementId = idForDeletedSegment(segment);\r\n                segmentIdFunction = idForDeletedSegment;\r\n                firstSelectedSegment = segment;\r\n                selectedAnnotatedSegments = [firstSelectedSegment];\r\n            } else if (props.activeAnnotation.isInsertion) {\r\n                const [start] =\r\n                    props.splitText.annotatedText.getPositionOfAnnotation(\r\n                        props.activeAnnotation\r\n                    );\r\n                if (start) {\r\n                    let segment = new TextSegment(start, \"\");\r\n                    selectedElementId = idForInsertion(segment);\r\n                    segmentIdFunction = idForInsertion;\r\n                    firstSelectedSegment = segment;\r\n                    selectedAnnotatedSegments = [firstSelectedSegment];\r\n                }\r\n            } else if (\r\n                props.activeAnnotation.type === ANNOTATION_TYPES.pageBreak\r\n            ) {\r\n                let segment = new TextSegment(startPos + 1, \"\");\r\n                let prevSegment = new TextSegment(startPos, \"\");\r\n                selectedElementId = idForPageBreak(prevSegment);\r\n                firstSelectedSegment = segment;\r\n                selectedAnnotatedSegments = [segment];\r\n                selectedElementIds = [selectedElementId];\r\n            } else if (\r\n                props.activeAnnotation.type === ANNOTATION_TYPES.lineBreak\r\n            ) {\r\n                let segment = new TextSegment(startPos + 1, \"\");\r\n                let prevSegment = new TextSegment(startPos, \"\");\r\n                selectedElementId = idForLineBreak(prevSegment);\r\n                firstSelectedSegment = segment;\r\n                selectedAnnotatedSegments = [segment];\r\n                selectedElementIds = [selectedElementId];\r\n            }\r\n        }\r\n        if (segmentIdFunction) {\r\n            for (let i = 0; i < selectedAnnotatedSegments.length; i++) {\r\n                let segment = selectedAnnotatedSegments[i];\r\n                if (segment instanceof TextSegment) {\r\n                    const segmentId = segmentIdFunction(segment);\r\n                    selectedElementIds.push(segmentId);\r\n                }\r\n            }\r\n        }\r\n        if (\r\n            selectedTextIndex != null &&\r\n            firstSelectedSegment &&\r\n            selectedElementId &&\r\n            splitTextRect\r\n        ) {\r\n            return {\r\n                selectedTextIndex: selectedTextIndex,\r\n                firstSelectedSegment: firstSelectedSegment,\r\n                selectedElementId: selectedElementId,\r\n                splitTextRect: splitTextRect,\r\n                selectedElementIds: selectedElementIds,\r\n            };\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    shouldResetListCache(oldProps: Props, newProps: Props) {\r\n        let shouldReset = false;\r\n        if (\r\n            oldProps.showImages !== newProps.showImages ||\r\n            this.pageBreaksChanged(oldProps, newProps)\r\n        ) {\r\n            shouldReset = true;\r\n        }\r\n\r\n        return shouldReset;\r\n    }\r\n\r\n    pageBreaksChanged(oldProps: Props, newProps: Props) {\r\n        const oldTextBreaks = oldProps.splitText.getTextsFinalPositions();\r\n        const newTextBreaks = newProps.splitText.getTextsFinalPositions();\r\n\r\n        if (oldTextBreaks.length !== newTextBreaks.length) return true;\r\n\r\n        return JSON.stringify(oldTextBreaks) !== JSON.stringify(newTextBreaks);\r\n    }\r\n\r\n    lineBreaksChanges(oldProps: Props, newProps: Props) {\r\n        let oldActiveAnnotation = oldProps.activeAnnotation;\r\n        let newActiveAnnotation = newProps.activeAnnotation;\r\n        let hasChanged = false;\r\n\r\n        if (\r\n            oldActiveAnnotation &&\r\n            oldActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) &&\r\n            newProps.activeAnnotations &&\r\n            !newProps.activeAnnotations.hasOwnProperty(\r\n                oldActiveAnnotation.uniqueId\r\n            )\r\n        ) {\r\n            hasChanged = true;\r\n        }\r\n\r\n        if (\r\n            newActiveAnnotation &&\r\n            newActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) &&\r\n            oldProps.activeAnnotations &&\r\n            !oldProps.activeAnnotations.hasOwnProperty(\r\n                newActiveAnnotation.uniqueId\r\n            )\r\n        ) {\r\n            hasChanged = true;\r\n        }\r\n\r\n        return hasChanged;\r\n    }\r\n\r\n    selectedListRow(props: Props): number | null {\r\n        let row = null;\r\n        if (props.activeAnnotation) {\r\n            row = props.splitText.getTextIndexOfPosition(\r\n                props.activeAnnotation.start\r\n            );\r\n        }\r\n        return row;\r\n    }\r\n\r\n    processProps(props: Props) {\r\n        let changedWitness = false;\r\n        if (\r\n            !this.props.selectedWitness ||\r\n            (props.selectedWitness &&\r\n                props.selectedWitness.id !== this.props.selectedWitness.id)\r\n        ) {\r\n            changedWitness = true;\r\n            this._didSetInitialScrollPosition = false;\r\n        }\r\n\r\n        if (\r\n            props.selectedSearchResult &&\r\n            (!this.props.selectedSearchResult ||\r\n                props.selectedSearchResult.start !==\r\n                    this.props.selectedSearchResult.start ||\r\n                props.selectedSearchResult.textId !==\r\n                    this.props.selectedSearchResult.textId)\r\n        ) {\r\n            console.log(\"resetting scroll position from search result\");\r\n            this._didSetInitialScrollPosition = false;\r\n        }\r\n\r\n        // TODO: check if new selectedSearchResult and if so\r\n        // set this._didSetInitialScrollPosition = false\r\n\r\n        // make sure there's no numbers in selectedAnnotatedSegments\r\n        // as we want to pass it to Text which only expects TextSegments\r\n        this._filteredSelectedAnnotatedSegments =\r\n            props.selectedAnnotatedSegments.reduce(\r\n                (acc, current: TextSegment | number) => {\r\n                    if (current instanceof TextSegment) acc.push(current);\r\n                    return acc;\r\n                },\r\n                []\r\n            );\r\n\r\n        const controlsMeasurements = this.getControlsMeasurements(props);\r\n        if (controlsMeasurements) {\r\n            this.selectedTextIndex = controlsMeasurements.selectedTextIndex;\r\n            this.firstSelectedSegment =\r\n                controlsMeasurements.firstSelectedSegment;\r\n            this.splitTextRect = controlsMeasurements.splitTextRect;\r\n            this.selectedElementId = controlsMeasurements.selectedElementId;\r\n            this.selectedElementIds = controlsMeasurements.selectedElementIds;\r\n        }\r\n\r\n        if (\r\n            props.textListVisible !== this.textListVisible ||\r\n            props.editMenuVisible !== this.editMenuVisible\r\n        ) {\r\n            setTimeout(() => {\r\n                this.textListVisible = props.textListVisible;\r\n                this.editMenuVisible = props.editMenuVisible;\r\n                this.updateList(true);\r\n            }, 500);\r\n        } else {\r\n            if (changedWitness) {\r\n                this.updateList(true);\r\n            } else if (this.pageBreaksChanged(this.props, props)) {\r\n                let selectedRows = null;\r\n                let currentSelectedRow = this.selectedListRow(this.props);\r\n                let newSelectedRow = this.selectedListRow(props);\r\n                if (currentSelectedRow && newSelectedRow) {\r\n                    let firstChangedRow =\r\n                        currentSelectedRow > newSelectedRow\r\n                            ? newSelectedRow\r\n                            : currentSelectedRow;\r\n\r\n                    let splitRowTexts = this.props.splitText.texts;\r\n                    selectedRows = [];\r\n                    for (\r\n                        let i = firstChangedRow, len = splitRowTexts.length;\r\n                        i < len;\r\n                        i++\r\n                    ) {\r\n                        selectedRows.push(i);\r\n                    }\r\n                }\r\n                this.updateList(true, selectedRows);\r\n            } else if (this.lineBreaksChanges(this.props, props)) {\r\n                let selectedRow = this.selectedListRow(props);\r\n                if (!selectedRow)\r\n                    selectedRow = this.selectedListRow(this.props);\r\n                let splitRowTexts = this.props.splitText.texts;\r\n                let selectedRows = [];\r\n                if (selectedRow !== null) {\r\n                    for (\r\n                        let i = selectedRow, len = splitRowTexts.length;\r\n                        i < len;\r\n                        i++\r\n                    ) {\r\n                        selectedRows.push(i);\r\n                    }\r\n                    this.updateList(true, selectedRows);\r\n                }\r\n            } else if (this.props.fontSize !== props.fontSize) {\r\n                this.updateList(true);\r\n            } else if (\r\n                this.props.activeAnnotation &&\r\n                props.activeAnnotation &&\r\n                this.annotationsInSameLocation(\r\n                    this.props.activeAnnotation,\r\n                    props.activeAnnotation\r\n                )\r\n            ) {\r\n                this.updateList(true, this.selectedListRow(props));\r\n            } else {\r\n                this.updateList(this.shouldResetListCache(this.props, props));\r\n            }\r\n        }\r\n    }\r\n\r\n    annotationsInSameLocation(anno1: Annotation, anno2: Annotation): boolean {\r\n        if (anno1.start === anno2.start && anno1.length === anno2.length) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    UNSAFE_componentWillReceiveProps(props: Props) {\r\n        this.processProps(props);\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.resizeHandler = _.throttle(() => {\r\n            this.calculatedImageHeight = null;\r\n            this.updateList();\r\n        }, 600).bind(this);\r\n        this.debouncedScroll = _.debounce((list, imagelist) => {\r\n            if (list.length) {\r\n                this.changeScrollToId({ id: list[0]?.start, from: 1 });\r\n            }\r\n            if (imagelist.length) {\r\n                this.changeImageScrollId({\r\n                    id: {\r\n                        start: imagelist[0]?.start,\r\n                        end: imagelist[0]?.end,\r\n                    },\r\n                    from: 1,\r\n                });\r\n            }\r\n        }, 1000);\r\n\r\n        window.addEventListener(\"resize\", this.resizeHandler);\r\n\r\n        this.selectionHandler = _.debounce((e) => {\r\n            this.handleSelection(e);\r\n        }, 200).bind(this);\r\n\r\n        document.addEventListener(\"selectionchange\", this.selectionHandler);\r\n        document.addEventListener(\"mousedown\", this.mouseDown.bind(this), true);\r\n        document.addEventListener(\"mouseup\", this.mouseUp.bind(this), true);\r\n        this.processProps(this.props);\r\n        this.timer = setTimeout(() => {\r\n            this.resizeHandler();\r\n        }, 2000);\r\n        this.componentDidUpdate();\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        this.imageData = this.props.imageData;\r\n        if (this.imageData !== prevProps?.imageData) {\r\n            this.calculatedImageHeight = null;\r\n\r\n            this.updateList(true);\r\n        }\r\n        let Alignment = this.props.textAlignment;\r\n        this.imageAlignmentById = this.props.imageAlignmentById;\r\n        this.SearchSyncId = this.props.syncIdOnSearch || null;\r\n        this.condition = this.props.condition;\r\n\r\n        let scrollToId = this.props.scrollToId;\r\n        let list = this.list;\r\n\r\n        let con =\r\n            prevProps?.searchResults !== this.props?.searchResults ||\r\n            prevProps?.syncIdOnSearch !== this.props?.syncIdOnSearch;\r\n\r\n        // scroll to word searched using search input\r\n        if (con && this.props.searchResults) {\r\n            if (this.SearchSyncId) {\r\n                let selectedTextIndex =\r\n                    this.props.splitText.getTextIndexOfPosition(\r\n                        this.SearchSyncId\r\n                    );\r\n                setTimeout(() => {\r\n                    list.scrollToRow(selectedTextIndex);\r\n                    setTimeout(() => {\r\n                        list.scrollToPosition(list.props.scrollTop - 300);\r\n                    }, 0);\r\n                }, 100);\r\n            }\r\n        }\r\n\r\n        this.textAlignmentById = this.props.textAlignmentById;\r\n        this.isPanelLinked = this.props.isPanelLinked;\r\n        this.selectedWindow = this.props.selectedWindow;\r\n        this.targetId = this.props.syncIdOnClick;\r\n\r\n        if (this.selectedNodes && this.selectedNodes.length > 0) {\r\n            const selectedNodes = this.selectedNodes;\r\n            const selectedSegments = this.props.selectedAnnotatedSegments;\r\n            setTimeout(() => {\r\n                let selRange = document.createRange();\r\n                let startNode = selectedNodes[0];\r\n                let endNode = selectedNodes[selectedNodes.length - 1];\r\n                let lastSegment = selectedSegments[selectedSegments.length - 1];\r\n                if (lastSegment instanceof TextSegment) {\r\n                    let lastElement = document.getElementById(\r\n                        idForSegment(lastSegment)\r\n                    );\r\n                    if (lastElement) endNode = lastElement;\r\n                }\r\n\r\n                if (\r\n                    startNode instanceof Element &&\r\n                    endNode instanceof Element\r\n                ) {\r\n                    startNode = document.getElementById(startNode.id);\r\n                    endNode = document.getElementById(endNode.id);\r\n                    if (startNode && endNode) {\r\n                        selRange.setStart(startNode, 0);\r\n                        selRange.setEnd(endNode, endNode.childNodes.length);\r\n                        let sel = document.getSelection();\r\n                        if (sel) {\r\n                            this._modifyingSelection = true;\r\n                            sel.removeAllRanges();\r\n                            sel.addRange(selRange);\r\n                            this.selectedNodes = null;\r\n                        }\r\n                    }\r\n                }\r\n            }, 0);\r\n        }\r\n\r\n        if (!this._didSetInitialScrollPosition && this.list) {\r\n            const list = this.list;\r\n            if (\r\n                this.props.activeAnnotation ||\r\n                this.props.selectedSearchResult\r\n            ) {\r\n                let selectedTextIndex = this.getSelectedTextIndex();\r\n                setTimeout(() => {\r\n                    list.scrollToRow(selectedTextIndex);\r\n                    // scrollToRow often positions the annotation at the\r\n                    // bottom of the screen, so scroll up a bit\r\n                    setTimeout(() => {\r\n                        list.scrollToPosition(list.props.scrollTop - 300);\r\n                    }, 0);\r\n                }, 100);\r\n            }\r\n            this._didSetInitialScrollPosition = true;\r\n        }\r\n        //Video and audio alignment scrolling\r\n        if (scrollToId.from == \"video\" && scrollToId.id) {\r\n            let start = scrollToId.id;\r\n            let selectedTextIndex =\r\n                this.props.splitText.getTextIndexOfPosition(start);\r\n            setTimeout(() => {\r\n                list.scrollToRow(selectedTextIndex);\r\n\r\n                setTimeout(() => {\r\n                    list.scrollToPosition(list.props.scrollTop - 300);\r\n                }, 0);\r\n            }, 100);\r\n        }\r\n\r\n        // scroll control linked with alignment on click\r\n        if (\r\n            this.selectedWindow === 2 &&\r\n            scrollToId.from == 2 &&\r\n            this.isPanelLinked &&\r\n            this.condition &&\r\n            scrollToId.id !== null\r\n        ) {\r\n            let list = this.list;\r\n            this.textAlignmentById = this.props.textAlignmentById || [];\r\n            this.splitText.style.scrollBehavior = \"smooth\";\r\n            if (Alignment && this.isPanelLinked) {\r\n                let req = this.textAlignmentById.find(\r\n                    (l) => l.TStart === scrollToId.id\r\n                );\r\n\r\n                let start = req?.start;\r\n                if (start !== null) {\r\n                    let selectedTextIndex =\r\n                        this.props.splitText.getTextIndexOfPosition(start);\r\n                    setTimeout(() => {\r\n                        list.scrollToRow(selectedTextIndex);\r\n\r\n                        setTimeout(() => {\r\n                            list.scrollToPosition(list.props.scrollTop - 300);\r\n                        }, 0);\r\n                    }, 100);\r\n                }\r\n            }\r\n        }\r\n\r\n        //for scrolling to the highlighted alignment if its outside visible DOM\r\n\r\n        if (\r\n            this.targetId &&\r\n            scrollToId.from === \"ua\" &&\r\n            this.selectedWindow === 2 &&\r\n            scrollToId.id === \"ua\"\r\n        ) {\r\n            let clickIdObj = Alignment.alignment.find(\r\n                (l) =>\r\n                    this.targetId >= l.target_segment.start &&\r\n                    this.targetId < l.target_segment.end\r\n            );\r\n            let syncClickTargetId = clickIdObj?.source_segment?.start;\r\n            let selectedTextIndex =\r\n                this.props.splitText.getTextIndexOfPosition(syncClickTargetId);\r\n\r\n            setTimeout(() => {\r\n                list.scrollToRow(selectedTextIndex);\r\n\r\n                setTimeout(() => {\r\n                    list.scrollToPosition(list.props.scrollTop - 300);\r\n                }, 0);\r\n            }, 100);\r\n        }\r\n    }\r\n    componentWillUnmount() {\r\n        document.removeEventListener(\"mousedown\", this);\r\n        document.removeEventListener(\"mouseup\", this);\r\n        window.removeEventListener(\"resize\", this.resizeHandler);\r\n\r\n        document.removeEventListener(\"selectionchange\", this.selectionHandler);\r\n        clearTimeout(this.timer);\r\n    }\r\n\r\n    calculateImageHeight() {\r\n        let height = null;\r\n        if (this.imageHeight && this.imageWidth) {\r\n            const ratio = this.imageWidth / this.imageHeight;\r\n            const pechaImageClass = styles.pechaImage;\r\n            const pechaImageContainers =\r\n                document.getElementsByClassName(pechaImageClass);\r\n            if (pechaImageContainers.length > 0) {\r\n                let container = pechaImageContainers[0];\r\n                height = container.offsetWidth / ratio;\r\n            }\r\n        }\r\n        return height;\r\n    }\r\n\r\n    getSelectedTextIndex(): number {\r\n        let selectedTextIndex = 0;\r\n        let startPos = null;\r\n        if (this.props.activeAnnotation) {\r\n            [startPos] =\r\n                this.props.splitText.annotatedText.getPositionOfAnnotation(\r\n                    this.props.activeAnnotation\r\n                );\r\n        } else if (this.props.selectedSearchResult) {\r\n            let segment =\r\n                this.props.splitText.annotatedText.segmentAtOriginalPosition(\r\n                    this.props.selectedSearchResult.start\r\n                );\r\n            if (segment instanceof TextSegment) {\r\n                startPos = segment.start;\r\n            } else if (typeof segment === \"number\") {\r\n                startPos = segment;\r\n            }\r\n        }\r\n        if (startPos) {\r\n            selectedTextIndex =\r\n                this.props.splitText.getTextIndexOfPosition(startPos);\r\n        }\r\n        return selectedTextIndex;\r\n    }\r\n\r\n    getBaseAnnotation(annotation: Annotation): Annotation {\r\n        let [start] =\r\n            this.props.splitText.annotatedText.getPositionOfAnnotation(\r\n                annotation\r\n            );\r\n        if (start === null) start = 0;\r\n        return this.props.splitText.annotatedText.getBaseAnnotation(\r\n            start,\r\n            annotation.content.length\r\n        );\r\n    }\r\n\r\n    render() {\r\n        const props = this.props;\r\n        const rowRenderer = this.rowRenderer;\r\n        const cache = this.cache;\r\n        const key = props.selectedWitness ? props.selectedWitness.id : 0;\r\n\r\n        return (\r\n            <div\r\n                className={styles.splitText}\r\n                ref={(div) => (this.splitText = div)}\r\n                key={key}\r\n            >\r\n                <button\r\n                    id=\"updateList\"\r\n                    style={{ display: \"none\" }}\r\n                    onClick={this.resizeHandler}\r\n                ></button>\r\n                <AutoSizer disableWidth>\r\n                    {({ height }) => (\r\n                        <List\r\n                            width={1}\r\n                            ref={(list) => (this.list = list)}\r\n                            height={height}\r\n                            rowCount={props.splitText.texts.length}\r\n                            rowHeight={cache.rowHeight}\r\n                            rowRenderer={rowRenderer}\r\n                            overscanRowCount={0}\r\n                            deferredMeasurementCache={cache}\r\n                            onScroll={this.scrollEvent}\r\n                            scrollToAlignment=\"start\"\r\n                            containerStyle={{\r\n                                width: \"100%\",\r\n                                maxWidth: \"100%\",\r\n                            }}\r\n                            style={{\r\n                                width: \"100%\",\r\n                            }}\r\n                        ></List>\r\n                    )}\r\n                </AutoSizer>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    getImageUrl(pageIndex: number): string {\r\n        if (\r\n            !this.props.selectedWitness ||\r\n            !this.props.selectedWitness.properties\r\n        )\r\n            return \"\";\r\n        let witnessProperties = this.props.selectedWitness.properties;\r\n        let prefix = witnessProperties[IMAGE_START_PRE_KEY];\r\n        let start = witnessProperties[IMAGE_START_NUMBER_KEY];\r\n        let suffix = witnessProperties[IMAGE_START_SUFFIX_KEY];\r\n        let id = Number(start) + pageIndex;\r\n        console.log(id);\r\n        let url =\r\n            IMAGE_URL_PREFIX + prefix + id + \".\" + suffix + IMAGE_URL_SUFFIX;\r\n        console.log(url);\r\n        return url;\r\n    }\r\n\r\n    getStringPositions(\r\n        text: SegmentedText,\r\n        string: string,\r\n        index: number\r\n    ): { [position: number]: [number, number] } {\r\n        const uniqueId = this.props.splitText.annotatedText.getUniqueId();\r\n\r\n        if (!_searchResultsCache.hasOwnProperty(uniqueId)) {\r\n            _searchResultsCache = {\r\n                [uniqueId]: {},\r\n            };\r\n        }\r\n\r\n        if (!_searchResultsCache[uniqueId].hasOwnProperty(string)) {\r\n            _searchResultsCache[uniqueId] = {\r\n                [string]: {},\r\n            };\r\n        }\r\n\r\n        if (_searchResultsCache[uniqueId][string].hasOwnProperty(index)) {\r\n            return _searchResultsCache[uniqueId][string][index];\r\n        }\r\n\r\n        const splitter = new GraphemeSplitter();\r\n        const content = text.getText();\r\n        const firstSegment = text.segments[0];\r\n        const startingPosition = firstSegment?.start;\r\n        let positions = [];\r\n        let position = content.indexOf(string);\r\n        while (position !== -1) {\r\n            positions.push(position);\r\n            position = content.indexOf(string, position + 1);\r\n        }\r\n\r\n        // Position needs to be position in complete text\r\n        let verifiedPositions: { [position: number]: [number, number] } = {};\r\n        if (positions.length > 0) {\r\n            const graphemes = splitter.splitGraphemes(content);\r\n            let position = 0;\r\n            let activePosition = null;\r\n            for (let i = 0; i < graphemes.length; i++) {\r\n                const grapheme = graphemes[i];\r\n                const graphemeEnd = position + (grapheme.length - 1);\r\n                if (activePosition !== null) {\r\n                    let expectedEnd = activePosition + (string.length - 1);\r\n                    if (graphemeEnd >= expectedEnd) {\r\n                        verifiedPositions[activePosition + startingPosition] = [\r\n                            activePosition + startingPosition,\r\n                            graphemeEnd + startingPosition,\r\n                        ];\r\n                        activePosition = null;\r\n                    }\r\n                } else if (positions.indexOf(position) !== -1) {\r\n                    if (string.length === grapheme.length) {\r\n                        verifiedPositions[position + startingPosition] = [\r\n                            position + startingPosition,\r\n                            graphemeEnd + startingPosition,\r\n                        ];\r\n                    } else if (string.length > grapheme.length) {\r\n                        activePosition = position;\r\n                    }\r\n                } else {\r\n                    activePosition = null;\r\n                }\r\n\r\n                position += grapheme.length;\r\n            }\r\n        }\r\n\r\n        _searchResultsCache[uniqueId][string][index] = verifiedPositions;\r\n\r\n        return verifiedPositions;\r\n    }\r\n\r\n    rowRenderer({\r\n        key,\r\n        index,\r\n        parent,\r\n        style,\r\n    }: {\r\n        key: string,\r\n        index: number,\r\n        parent: {},\r\n        style: {},\r\n    }): React.Element<CellMeasurer> {\r\n        const props = this.props;\r\n        const cache = this.cache;\r\n        const component = this;\r\n        const pechaImageClass = props.showImages ? styles.pechaImage : null;\r\n\r\n        let imageUrl = \"\";\r\n        // if (this.imageData?.alignment && props.selectedWitness) {\r\n        //     imageUrl = HttpUrl(\r\n        //         this.imageData?.alignment[index]?.target_segment\r\n        //     );\r\n        // }\r\n        if (\r\n            props.selectedWitness &&\r\n            props.selectedWitness.properties &&\r\n            props.selectedWitness.properties.hasOwnProperty(IMAGE_START_PRE_KEY)\r\n        ) {\r\n            console.log(\"running\");\r\n            imageUrl = this.getImageUrl(index);\r\n        }\r\n\r\n        let searchStringPositions = {};\r\n        let searchValue = this.props.searchValue;\r\n        if (searchValue && searchValue.length > 0 && props.splitText) {\r\n            searchStringPositions = this.getStringPositions(\r\n                props.splitText.texts[index],\r\n                searchValue,\r\n                index\r\n            );\r\n        }\r\n\r\n        let pechaStyles = {};\r\n\r\n        if (props.showImages && pechaImageClass && this.calculatedImageHeight) {\r\n            pechaStyles[\"height\"] = this.calculatedImageHeight + \"px\";\r\n        }\r\n        let newStyle = {\r\n            ...style,\r\n            height: style.height + 10,\r\n            cursor: !this.props.isAnnotating ? \"pointer\" : \"text\",\r\n        };\r\n        return (\r\n            <CellMeasurer\r\n                columnIndex={0}\r\n                key={key}\r\n                parent={parent}\r\n                rowIndex={index}\r\n                cache={cache}\r\n            >\r\n                <div\r\n                    key={key}\r\n                    style={newStyle}\r\n                    className={styles.splitTextRow}\r\n                    ref={this.splitTextRef}\r\n                    id={`index_${index}`}\r\n                >\r\n                    <div className={styles.splitTextRowContent}>\r\n                        {props.showImages && (\r\n                            <div\r\n                                className={pechaImageClass}\r\n                                style={pechaStyles}\r\n                            >\r\n                                <img\r\n                                    alt=\"Text related Image\"\r\n                                    className={styles.image}\r\n                                    src={imageUrl}\r\n                                    width=\"100%\"\r\n                                    height=\"100%\"\r\n                                    loading=\"lazy\"\r\n                                    decoding=\"async\"\r\n                                    onLoad={(e) => {\r\n                                        if (\r\n                                            e.target &&\r\n                                            component.imageWidth === null\r\n                                        ) {\r\n                                            component.imageWidth =\r\n                                                e.target.naturalWidth;\r\n                                            component.imageHeight =\r\n                                                e.target.naturalHeight;\r\n                                            component.calculatedImageHeight =\r\n                                                null;\r\n                                            window.setTimeout(\r\n                                                component.updateList.bind(\r\n                                                    component\r\n                                                ),\r\n                                                0\r\n                                            );\r\n                                        }\r\n                                    }}\r\n                                />\r\n                            </div>\r\n                        )}\r\n\r\n                        <Text\r\n                            ref={this.childRef}\r\n                            segmentedText={props.splitText.texts[index]}\r\n                            annotations={props.annotations}\r\n                            activeAnnotations={props.activeAnnotations}\r\n                            activeAnnotation={props.activeAnnotation}\r\n                            row={index}\r\n                            selectedSegmentId={props.selectedSegmentId}\r\n                            annotationPositions={props.annotationPositions}\r\n                            selectedAnnotatedSegments={\r\n                                this._filteredSelectedAnnotatedSegments\r\n                            }\r\n                            getBaseAnnotation={this.getBaseAnnotation.bind(\r\n                                this\r\n                            )}\r\n                            activeWitness={this.props.selectedWitness}\r\n                            searchValue={searchValue}\r\n                            selectedSearchResult={\r\n                                this.props.selectedSearchResult\r\n                            }\r\n                            searchStringPositions={searchStringPositions}\r\n                            fontSize={props.fontSize}\r\n                            changeSyncIdOnClick={this.props.changeSyncIdOnClick}\r\n                            changeScrollToId={this.props.changeScrollToId}\r\n                            textAlignmentById={this.props.textAlignmentById}\r\n                            selectedSourceRange={this.props.selectedSourceRange}\r\n                            selectedTargetRange={this.props.selectedTargetRange}\r\n                            changeSelectedRange={this.props.changeSelectedRange}\r\n                            condition={this.condition}\r\n                        />\r\n                    </div>\r\n                    {this.props.isAnnotating &&\r\n                        this.selectedTextIndex === index &&\r\n                        this.props.activeAnnotation && (\r\n                            <AnnotationControlsContainer\r\n                                annotationPositions={props.annotationPositions}\r\n                                annotatedText={props.splitText.annotatedText}\r\n                                activeAnnotation={props.activeAnnotation}\r\n                                inline={true}\r\n                                firstSelectedSegment={this.firstSelectedSegment}\r\n                                splitTextRect={this.splitTextRect}\r\n                                selectedElementId={this.selectedElementId}\r\n                                pechaImageClass={pechaImageClass}\r\n                                splitText={props.splitText}\r\n                                selectedElementIds={this.selectedElementIds}\r\n                                list={this.list}\r\n                            />\r\n                        )}\r\n                </div>\r\n            </CellMeasurer>\r\n        );\r\n    }\r\n}\r\n","export default __webpack_public_path__ + \"8967124136190c7842d863e4a862a528.png\";","export default function shallowEqual(objA, objB) {\r\n    if (objA === objB) {\r\n        return true;\r\n    }\r\n\r\n    let aKeys = Object.keys(objA);\r\n    let bKeys = Object.keys(objB);\r\n    let len = aKeys.length;\r\n\r\n    if (bKeys.length !== len) {\r\n        return false;\r\n    }\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        let key = aKeys[i];\r\n\r\n        if (objA[key] !== objB[key]) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _jsxRuntime = require(\"react/jsx-runtime\");\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)(\"path\", {\n  d: \"M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z\"\n}), 'Delete');\n\nexports.default = _default;"],"mappings":";;;;;;;;;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AAAA;AACA;AACA;AACA;AACA;AA6CA;;;;;AAiBA;AAgCA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlCA;AAmCA;AACA;;;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAGA;AAAA;AACA;AAAA;AAMA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AAOA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AACA;AADA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAEA;AAEA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AALA;AAOA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AAIA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAHA;AAMA;AACA;AAAA;AAAA;AACA;AAHA;AAKA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AADA;AAfA;AADA;AAwBA;;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAEA;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAEA;AAUA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAHA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAOA;AAAA;AAGA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AAEA;AAMA;AACA;AA1BA;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5BA;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAiBA;;;;AA9nCA;AACA;;;;;;;;;;;;;ACpGA;AAAA;;;;;;;;;;;;ACAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}