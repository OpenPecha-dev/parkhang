{"version":3,"file":"25.parkhang-dev.js","sources":["webpack://parkhang/./app/components/TextDetail2/Text2.css","webpack://parkhang/./app/components/TextDetail2/Text2.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"paddingSide\":\"20px\",\"maxWidth\":\"600px\",\"text\":\"Text2---text\",\"textFirstRow\":\"Text2---textFirstRow\",\"textLine\":\"Text2---textLine\",\"textline\":\"Text2---textline\",\"limitWidth\":\"Text2---limitWidth\",\"textContainer\":\"Text2---textContainer\",\"annotation\":\"Text2---annotation\",\"removedByAnnotation\":\"Text2---removedByAnnotation\",\"insertion\":\"Text2---insertion\",\"highlight\":\"Text2---highlight\",\"activeHighlight\":\"Text2---activeHighlight\",\"lineBreak\":\"Text2---lineBreak\",\"pageBreak\":\"Text2---pageBreak\",\"syncIdClass\":\"Text2---syncIdClass\",\"selectedRangelight\":\"Text2---selectedRangelight\",\"selectedRangeDark\":\"Text2---selectedRangeDark\"};","// @flow\r\nimport React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport styles from \"./Text2.css\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport {\r\n    INSERTION_KEY,\r\n    DELETION_KEY,\r\n    PAGE_BREAK_KEY,\r\n    LINE_BREAK_KEY,\r\n} from \"lib/AnnotatedText\";\r\nimport _ from \"lodash\";\r\nimport SegmentedText from \"lib/SegmentedText\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport Witness from \"lib/Witness\";\r\nimport { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport GraphemeSplitter from \"grapheme-splitter\";\r\nimport { withTheme } from \"@mui/styles\";\r\n\r\nexport function idForSegment(segment: TextSegment): string {\r\n    return \"s2_\" + segment.start;\r\n}\r\n\r\nexport function idForDeletedSegment(segment: TextSegment): string {\r\n    return \"ds_\" + segment.start;\r\n}\r\n\r\n// export function idForInsertion(segment: TextSegment): string {\r\n//     return \"i_\" + segment.start;\r\n// }\r\n\r\n// export function idForPageBreak(segment: TextSegment): string {\r\n//     return \"p_\" + (segment.end + 1);\r\n// }\r\n\r\n// export function idForLineBreak(segment: TextSegment): string {\r\n//     return \"l_\" + (segment.end + 1);\r\n// }\r\n\r\nexport type Props = {\r\n    segmentedText: SegmentedText,\r\n    annotationPositions: { [string]: Annotation[] },\r\n    selectedSegmentId: (id: string) => void,\r\n    activeAnnotations: { [AnnotationUniqueId]: Annotation } | null,\r\n    getBaseAnnotation: (annotation: Annotation) => Annotation,\r\n    selectedAnnotatedSegments: TextSegment[],\r\n    row: number,\r\n    activeAnnotation: Annotation | null,\r\n    searchValue: string | null,\r\n    selectedSearchResult: {\r\n        textId: number,\r\n        start: number,\r\n        length: number,\r\n    } | null,\r\n    searchStringPositions: { [position: number]: [number, number] },\r\n    fontSize?: number,\r\n    activeWitness: Witness,\r\n    textAlignmentById: {},\r\n    selectedSourceRange: [],\r\n    selectedTargetRange: [],\r\n    changeSyncIdOnClick: () => void,\r\n};\r\n\r\nexport type State = {\r\n    segmentedText: SegmentedText,\r\n};\r\n\r\n// import ReactDOMServer from \"react-dom/server\";\r\n// import PageBreakIcon from \"images/page_break_icon.svg\";\r\n// const PARA_SYMBOL = String.fromCharCode(182);\r\n// const pageBreakIconString = ReactDOMServer.renderToStaticMarkup(\r\n//     <PageBreakIcon />\r\n// );\r\n\r\nclass Text2 extends React.Component<Props, State> {\r\n    _renderedSegments: TextSegment[] | null;\r\n    _renderedHtml: { __html: string } | null;\r\n    textAlignmentById;\r\n\r\n    constructor(props: Props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            segmentedText: props.segmentedText,\r\n        };\r\n        this.textAlignmentById = this.props.textAlignmentById;\r\n        this._renderedSegments = null;\r\n        this._renderedHtml = null;\r\n    }\r\n\r\n    UNSAFE_componentWillReceiveProps(nextProps: Props) {\r\n        this.setState((prevState: State, props: Props) => {\r\n            return {\r\n                ...prevState,\r\n                segmentedText: nextProps.segmentedText,\r\n            };\r\n        });\r\n    }\r\n\r\n    // annotationsForSegment(segment: TextSegment): Annotation[] {\r\n    //     let annotations: Annotation[] = [];\r\n    //     const foundAnnotations = this.props.annotationPositions[\r\n    //         String(segment.start)\r\n    //     ];\r\n    //     if (foundAnnotations) {\r\n    //         annotations = foundAnnotations;\r\n    //     }\r\n    //     const insertions =\r\n    //         this.props.annotationPositions[INSERTION_KEY + segment.start] || [];\r\n    //     const deletions =\r\n    //         this.props.annotationPositions[DELETION_KEY + segment.start] || [];\r\n    //     const pageBreaks =\r\n    //         this.props.annotationPositions[\r\n    //             PAGE_BREAK_KEY + (segment.end + 1)\r\n    //         ] || [];\r\n    //     const lineBreaks =\r\n    //         this.props.annotationPositions[\r\n    //             LINE_BREAK_KEY + (segment.end + 1)\r\n    //         ] || [];\r\n\r\n    //     return annotations.concat(\r\n    //         insertions,\r\n    //         deletions,\r\n    //         pageBreaks,\r\n    //         lineBreaks\r\n    //     );\r\n    // }\r\n\r\n    // segmentsContainSegment(segments: TextSegment[], segment: TextSegment) {\r\n    //     for (let i = 0; i < segments.length; i++) {\r\n    //         let listSegment = segments[i];\r\n    //         if (\r\n    //             listSegment.start === segment.start &&\r\n    //             listSegment.text === segment.text\r\n    //         ) {\r\n    //             return true;\r\n    //         }\r\n    //     }\r\n    //     return false;\r\n    // }\r\n\r\n    selectedElement(element: Element) {\r\n        let sourceRangeSelection = [];\r\n        let targetRangeSelection = [];\r\n        const selection = document.getSelection();\r\n        if (\r\n            element?.id.includes(\"s2_\") &&\r\n            this.props.isPanelLinked &&\r\n            this.props.condition\r\n        ) {\r\n            var clickId = parseInt(element.id.replace(\"s2_\", \"\"));\r\n\r\n            this.props.changeSyncIdOnClick(clickId);\r\n            this.props.changeScrollToId({ id: \"ua\", from: \"ua\" });\r\n\r\n            let id = parseInt(element.id.replace(\"s2_\", \"\"));\r\n            let rangeUnique = this.textAlignmentById.find(\r\n                (l) => id >= l.TStart && id < l.TEnd\r\n            );\r\n            if (rangeUnique) {\r\n                for (let i = rangeUnique.start; i < rangeUnique.end; i++) {\r\n                    sourceRangeSelection.push(i);\r\n                }\r\n                for (let i = rangeUnique.TStart; i < rangeUnique.TEnd; i++) {\r\n                    targetRangeSelection.push(i);\r\n                }\r\n                this.props.changeSelectedRange({\r\n                    source: sourceRangeSelection,\r\n                    target: targetRangeSelection,\r\n                });\r\n            }\r\n        }\r\n\r\n        if (selection && selection.type === \"Range\") {\r\n            return;\r\n        }\r\n        this.props.selectedSegmentId(element.id);\r\n        if (!element.id) {\r\n            this.props.changeSelectedRange({ source: [], target: [] });\r\n        }\r\n    }\r\n\r\n    generateHtml(renderProps: Props, renderState: State): { __html: string } {\r\n        let segments = renderState.segmentedText.segments;\r\n\r\n        let textLineClass = styles.textLine;\r\n        let segmentHTML = '<p class=\"' + textLineClass + '\">';\r\n        if (segments.length === 0) return { __html: segmentHTML };\r\n\r\n        const endPosition = segments[segments.length - 1].end + 1;\r\n\r\n        let highlightClass = styles.highlight;\r\n        let activeHighlightClass = styles.activeHighlight;\r\n        let activeSearchResultEnd = null;\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let segment = segments[i];\r\n            let classAttribute = \"\";\r\n            let classes = [];\r\n            let selectedCurrentDeletion = false;\r\n            let selectedCurrentPageBreak = false;\r\n            let selectedCurrentLineBreak = false;\r\n            let lineBreakAnnotation = false;\r\n            let pageBreakAnnotation = null;\r\n\r\n            // It's an insertion at the end of the text, which should have just been added to the html.\r\n            // So break as we don't want anymore segment html adding.\r\n            if (segment.start === endPosition) {\r\n                break;\r\n            }\r\n            let id = null;\r\n            if (segment.length === 0) {\r\n                // id = idForDeletedSegment(segment);\r\n                // classes.push(styles.removedByAnnotation);\r\n                // if (deletionText) {\r\n                //     segment = new TextSegment(segment.start, deletionText);\r\n                // }\r\n            } else {\r\n                id = idForSegment(segment);\r\n            }\r\n\r\n            // if (\r\n            //     this.segmentsContainSegment(\r\n            //         renderProps.selectedAnnotatedSegments,\r\n            //         segment\r\n            //     ) ||\r\n            //     selectedCurrentDeletion\r\n            // ) {\r\n            //     classes.push(styles.selectedAnnotation);\r\n            // }\r\n            if (\r\n                renderProps.selectedTargetRange?.includes(segment.start) &&\r\n                renderProps.condition\r\n            ) {\r\n                let newClass =\r\n                    renderProps.theme.palette.mode === \"light\"\r\n                        ? styles.selectedRangelight\r\n                        : styles.selectedRangeDark;\r\n                classes.push(newClass);\r\n            }\r\n\r\n            if (classes.length > 0) {\r\n                let className = classnames(...classes);\r\n                classAttribute = 'class=\"' + className + '\"';\r\n            }\r\n\r\n            let segmentContent = segment.text;\r\n            // Add search result highlight if required.\r\n            if (renderProps.searchStringPositions) {\r\n                let segmentStart = segment.start;\r\n                let position = segmentStart;\r\n                segmentContent = \"\";\r\n\r\n                let highlight = highlightClass;\r\n                if (\r\n                    renderProps.selectedSearchResult &&\r\n                    renderProps.selectedSearchResult.start <= position &&\r\n                    renderProps.selectedSearchResult.start +\r\n                        renderProps.selectedSearchResult.length >\r\n                        position\r\n                ) {\r\n                    highlight = activeHighlightClass;\r\n                }\r\n\r\n                for (let j = 0; j < segment.text.length; j++) {\r\n                    let char = segment.text.charAt(j);\r\n                    position = segmentStart + j;\r\n                    if (activeSearchResultEnd) {\r\n                        let [start, end] = activeSearchResultEnd;\r\n                        if (j === 0) {\r\n                            segmentContent +=\r\n                                '<span class=\"' + highlight + '\">';\r\n                        }\r\n                        if (position === end) {\r\n                            segmentContent += char + \"</span>\";\r\n                            activeSearchResultEnd = null;\r\n                        } else if (j === segment.text.length - 1) {\r\n                            segmentContent += char + \"</span>\";\r\n                        } else {\r\n                            segmentContent += char;\r\n                        }\r\n                    } else if (position in renderProps.searchStringPositions) {\r\n                        let [start, end] =\r\n                            renderProps.searchStringPositions[position];\r\n                        segmentContent +=\r\n                            '<span class=\"' + highlight + '\">' + char;\r\n                        if (j === segment.text.length - 1 || position === end) {\r\n                            segmentContent += \"</span>\";\r\n                        }\r\n                        if (position < end) {\r\n                            activeSearchResultEnd = [start, end];\r\n                        }\r\n                    } else {\r\n                        segmentContent += char;\r\n                    }\r\n                }\r\n            }\r\n            // if (\r\n            //     this.props.textAlignmentById !== null\r\n            //     // && selectedTextId === TargetId\r\n            // ) {\r\n            //     let r = this.props.textAlignmentById.find(\r\n            //         (d) => d.TStart === segment.start\r\n            //     );\r\n            //     if (r) {\r\n            //         segmentHTML +=\r\n            //             \"<span id='alignment2_\" +\r\n            //             segment.start +\r\n            //             \"'>\" +\r\n            //             `<sup class=` +\r\n            //             styles.syncIdClass +\r\n            //             `>${r.id}</sup>` +\r\n            //             \"</span>\";\r\n            //     }\r\n            // }\r\n\r\n            segmentHTML +=\r\n                \"<span id=\" +\r\n                id +\r\n                \" key=\" +\r\n                id +\r\n                \" \" +\r\n                classAttribute +\r\n                \">\" +\r\n                segmentContent +\r\n                \"</span>\";\r\n        }\r\n\r\n        this._renderedSegments = segments;\r\n        segmentHTML += \"</p>\";\r\n\r\n        const html = {\r\n            __html: segmentHTML,\r\n        };\r\n        return html;\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps: Props, nextState: State) {\r\n        const renderedHtml = this.generateHtml(nextProps, nextState);\r\n        if (this.props.fontSize !== nextProps.fontSize) {\r\n            return true;\r\n        } else if (\r\n            this._renderedHtml &&\r\n            renderedHtml.__html === this._renderedHtml.__html\r\n        ) {\r\n            return false;\r\n        } else if (this._renderedHtml !== renderedHtml) {\r\n            this._renderedHtml = renderedHtml;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    componentDidUpdate() {\r\n        this.textAlignmentById = this.props.textAlignmentById;\r\n    }\r\n    render() {\r\n        let classes = [styles.text];\r\n        if (this.props.row === 0) {\r\n            classes.push(styles.textFirstRow);\r\n        }\r\n\r\n        // Generate HTML manually as it is much faster when\r\n        // creating large numbers of elements, such as these spans.\r\n        const html = this._renderedHtml\r\n            ? this._renderedHtml\r\n            : this.generateHtml(this.props, this.state);\r\n        if (!this._renderedHtml) {\r\n            this._renderedHtml = html;\r\n        }\r\n\r\n        return (\r\n            <div className={styles.textContainer}>\r\n                <div\r\n                    className={classnames(...classes)}\r\n                    dangerouslySetInnerHTML={html}\r\n                    onClick={(e) => this.selectedElement(e.target)}\r\n                    style={{\r\n                        fontSize: this.props.fontSize,\r\n                        fontFamily: \"var(--tibetan-fonts2)\",\r\n                    }}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\nexport default withTheme(Text2);\r\n"],"mappings":";;;;;;;;;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AA6BA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AADA;AAGA;AACA;AACA;AARA;AASA;AACA;;;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAAA;AAKA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAUA;AACA;AACA;AACA;AAEA;AACA;AADA;AAGA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AACA;AACA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAFA;AAJA;AAWA;;;;AApTA;AACA;AAqTA;;;;A","sourceRoot":""}