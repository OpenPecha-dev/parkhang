{"version":3,"file":"20.parkhang-dev.js","sources":["webpack://parkhang/./app/components/TextDetail/AnnotationControlsContainer.js","webpack://parkhang/./app/lib/SplitText.js"],"sourcesContent":["// @flow\r\nimport React from \"react\";\r\nimport { connect, useStore } from \"react-redux\";\r\nimport { batchActions } from \"redux-batched-actions\";\r\nimport AnnotationControls from \"./AnnotationControls\";\r\nimport type { Props as ControlsProps } from \"./AnnotationControls\";\r\nimport addTibetanShay from \"lib/addTibetanShay\";\r\nimport * as reducers from \"reducers\";\r\nimport type { AppState } from \"reducers\";\r\nimport * as actions from \"actions\";\r\nimport { BASE_ANNOTATION_ID } from \"lib/AnnotatedText\";\r\nimport Annotation, {\r\n    ANNOTATION_TYPES,\r\n    TemporaryAnnotation,\r\n} from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport AnnotatedText from \"lib/AnnotatedText\";\r\nimport User from \"lib/User\";\r\nimport Witness from \"lib/Witness\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport SplitText from \"lib/SplitText\";\r\nimport _ from \"lodash\";\r\nimport { changedActiveTextAnnotation } from \"actions\";\r\nimport ReactDOMServer from \"react-dom/server\";\r\nimport Question from \"lib/Question\";\r\nimport type { QuestionData } from \"./AnnotationControls\";\r\nimport { getTextFontSize } from \"reducers\";\r\n\r\nconst TEMPORARY_ANNOTATION_ID = -3;\r\nconst BASE_NAME = \"Working\";\r\n\r\ntype AnnotationData = {\r\n    name: string,\r\n    content: string,\r\n    id: AnnotationUniqueId,\r\n    isTemporary: boolean,\r\n    annotation: Annotation,\r\n    userCreated: boolean,\r\n};\r\nconst getAnnotationsData = (\r\n    annotations,\r\n    sources,\r\n    workingSourceName,\r\n    selectedText\r\n): AnnotationData[] => {\r\n    let annotationsData = [];\r\n    let baseSources = sources.filter(\r\n        (source) => source.isWorking || source.isBase\r\n    );\r\n    let baseSourceNames = baseSources.map((source) => source.name);\r\n    if (annotations) {\r\n        let annotationsById = {};\r\n        for (let i = 0; i < annotations.length; i++) {\r\n            let annotation = annotations[i];\r\n            let id = annotation.content + annotation.start;\r\n            if (annotation.isTemporary) {\r\n                annotationsById[TEMPORARY_ANNOTATION_ID] = {\r\n                    name: annotation.getSourceName(),\r\n                    content: annotation.content,\r\n                    id: annotation.uniqueId,\r\n                    isTemporary: true,\r\n                    annotation: annotation,\r\n                };\r\n                baseSourceNames = baseSourceNames.filter(\r\n                    (a) => a !== annotation.getSourceName()\r\n                );\r\n                id = TEMPORARY_ANNOTATION_ID;\r\n            } else if (annotationsById[id]) {\r\n                let existingAnnotation = annotationsById[id];\r\n                existingAnnotation.name +=\r\n                    \" \" + addTibetanShay(annotation.getSourceName());\r\n                baseSourceNames = baseSourceNames.filter(\r\n                    (a) => a !== annotation.getSourceName()\r\n                );\r\n            } else {\r\n                annotationsById[id] = {\r\n                    name: addTibetanShay(annotation.getSourceName()),\r\n                    content: annotation.content,\r\n                    id: annotation.uniqueId,\r\n                    userCreated: annotation.userCreated,\r\n                    annotation: annotation,\r\n                };\r\n                baseSourceNames = baseSourceNames.filter(\r\n                    (a) => a !== annotation.getSourceName()\r\n                );\r\n            }\r\n            if (\r\n                !annotation.userCreated &&\r\n                annotation.creatorWitness.isWorking\r\n            ) {\r\n                annotationsById[id].isWorking = true;\r\n            } else {\r\n                annotationsById[id].isWorking = false;\r\n            }\r\n        }\r\n        // Make sure Working source is first\r\n        baseSourceNames.unshift(workingSourceName);\r\n        let Base = baseSourceNames;\r\n        if (\r\n            selectedText?.name !==\r\n            \"བྱང་ཆུབ་སེམས་དཔའི་སྤྱོད་པ་ལ་འཇུག་པ་བཞུགས་སོ།\"\r\n        ) {\r\n            //Dominant only awailable for chojuk text\r\n            Base = baseSourceNames.filter((l) => l !== \"Dominant\");\r\n        }\r\n\r\n        annotationsData = Object.keys(annotationsById).reduce((arr, key) => {\r\n            const annotationData = annotationsById[key];\r\n\r\n            if (annotationData.isWorking) {\r\n                annotationData.name = Base.reduce(\r\n                    (prev, cur) => (prev += \" \" + addTibetanShay(cur, \";\")),\r\n                    \"\"\r\n                );\r\n            }\r\n            arr.push(annotationData);\r\n            return arr;\r\n        }, []);\r\n    }\r\n\r\n    return annotationsData;\r\n};\r\n\r\nconst getAvailableAnnotations = (\r\n    annotatedText: AnnotatedText,\r\n    activeAnnotation: Annotation,\r\n    temporaryAnnotation: TemporaryAnnotation | null,\r\n    annotationPositions: { [string]: Annotation[] }\r\n): Annotation[] => {\r\n    let availableAnnotations = [];\r\n    if (\r\n        !temporaryAnnotation ||\r\n        activeAnnotation.naturalId !== temporaryAnnotation.naturalId\r\n    ) {\r\n        availableAnnotations.push(activeAnnotation);\r\n    }\r\n    if (temporaryAnnotation) {\r\n        availableAnnotations.push(temporaryAnnotation);\r\n    }\r\n    let [start, length] =\r\n        annotatedText.getPositionOfAnnotation(activeAnnotation);\r\n\r\n    if (!start) {\r\n        return availableAnnotations;\r\n    }\r\n\r\n    let end = start + length;\r\n\r\n    let possibleAnnotations = [];\r\n\r\n    if (activeAnnotation.isInsertion) {\r\n        const insertionAnnotations = annotationPositions[\"i\" + start];\r\n        if (insertionAnnotations) {\r\n            possibleAnnotations =\r\n                possibleAnnotations.concat(insertionAnnotations);\r\n        }\r\n        const activeInsertionAnnotations = annotationPositions[String(start)];\r\n        if (activeInsertionAnnotations) {\r\n            possibleAnnotations = possibleAnnotations.concat(\r\n                activeInsertionAnnotations\r\n            );\r\n        }\r\n    } else {\r\n        // Only include annotations if they encompass the whole annotation\r\n        // i.e. not if activeAnnotation is a user annotation and combines\r\n        // annotated text with normal text.\r\n        let startAnnotations = annotationPositions[String(start)];\r\n        let endAnnotations = annotationPositions[String(end)];\r\n\r\n        if (startAnnotations) {\r\n            possibleAnnotations = startAnnotations;\r\n        }\r\n        if (endAnnotations) {\r\n            possibleAnnotations = possibleAnnotations.concat(endAnnotations);\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < possibleAnnotations.length; i++) {\r\n        const annotation = possibleAnnotations[i];\r\n        if (\r\n            annotation.start === activeAnnotation.start &&\r\n            annotation.length === activeAnnotation.length\r\n        ) {\r\n            // If an annotation is being edited, there will be a temporary annotation\r\n            // with the same natural id. If so, don't show the orignal version.\r\n            //\r\n            // We use natualId, as it normalises the id regardless of the original's\r\n            // save state. e.g. Upon editing a witness variant, a new annotation will be\r\n            // created. If the user is offline, that will not have been saved via the\r\n            // API yet. The user could then edit this new annotation, creating a temporary\r\n            // annotation based upon it. While this is being edited, the user could come\r\n            // back online and the save operation will succeed. This will mean the id of\r\n            // the temporary annotation will be different to the original edit, but naturalId\r\n            // will be the same.\r\n            if (\r\n                !temporaryAnnotation ||\r\n                annotation.naturalId !== temporaryAnnotation.naturalId\r\n            ) {\r\n                availableAnnotations.push(annotation);\r\n            }\r\n        } else if (!annotatedText.activeWitness.isWorking) {\r\n            if (\r\n                annotation.type === ANNOTATION_TYPES.pageBreak ||\r\n                annotation.type === ANNOTATION_TYPES.lineBreak\r\n            ) {\r\n                availableAnnotations.push(annotation);\r\n            }\r\n        }\r\n    }\r\n\r\n    availableAnnotations = _.uniqWith(\r\n        availableAnnotations,\r\n        (a, b) => a.id === b.id\r\n    );\r\n\r\n    return availableAnnotations;\r\n};\r\n\r\nconst getTemporaryAnnotation = (\r\n    state: AppState,\r\n    type: string,\r\n    user: User,\r\n    witness: Witness,\r\n    start: number,\r\n    length: number\r\n): TemporaryAnnotation | null => {\r\n    const annotations = reducers.getTemporaryAnnotations(\r\n        state,\r\n        witness.id,\r\n        start,\r\n        length,\r\n        type\r\n    );\r\n    if (annotations.length > 0) {\r\n        return annotations[0];\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\ntype StateProps = ControlsProps & {\r\n    questionsData: { [annotationId: AnnotationUniqueId]: Question[] },\r\n};\r\n\r\n// These are the props that are expected to be set and available in ownProps\r\ntype ContainerProps = {\r\n    annotationPositions: { [string]: Annotation[] },\r\n    annotatedText: AnnotatedText,\r\n    activeAnnotation: Annotation | null,\r\n    inline?: boolean,\r\n    firstSelectedSegment: TextSegment,\r\n    splitTextRect: ClientRect | null,\r\n    splitText: SplitText | null,\r\n};\r\n\r\nexport const mapStateToProps = (state: AppState, ownProps: ContainerProps) => {\r\n    const user = reducers.getUser(state);\r\n    const selectedText = reducers.getSelectedText(state);\r\n    const activeAnnotation = ownProps.activeAnnotation;\r\n    const inline = ownProps.inline;\r\n    let selectedWitness = reducers.getSelectedTextWitness(state);\r\n    if (!selectedWitness) {\r\n        if (selectedText) {\r\n            selectedWitness = reducers.getWorkingWitness(\r\n                state,\r\n                selectedText.id\r\n            );\r\n        }\r\n    }\r\n\r\n    if (!activeAnnotation || !selectedWitness) {\r\n        return {\r\n            annotationsData: null,\r\n            activeAnnotation: null,\r\n            baseAnnotation: null,\r\n            availableAnnotations: null,\r\n            user: user,\r\n            temporaryAnnotation: null,\r\n            inline: null,\r\n            firstSelectedSegment: null,\r\n            splitTextRect: null,\r\n            selectedWitness: null,\r\n        };\r\n    }\r\n\r\n    const temporaryVariant = getTemporaryAnnotation(\r\n        state,\r\n        ANNOTATION_TYPES.variant,\r\n        user,\r\n        selectedWitness,\r\n        activeAnnotation.start,\r\n        activeAnnotation.length\r\n    );\r\n\r\n    const annotations = getAvailableAnnotations(\r\n        ownProps.annotatedText,\r\n        activeAnnotation,\r\n        temporaryVariant,\r\n        ownProps.annotationPositions\r\n    );\r\n    const variants = annotations.filter(\r\n        (annotation: Annotation) => annotation.type === ANNOTATION_TYPES.variant\r\n    );\r\n    const sources = reducers.getSources(state);\r\n    const workingSourceName = reducers.getTranslation(\r\n        state,\r\n        \"annotation.workingEdition\",\r\n        BASE_NAME\r\n    );\r\n    let variantsData = getAnnotationsData(\r\n        variants,\r\n        sources,\r\n        workingSourceName,\r\n        selectedText\r\n    );\r\n\r\n    let baseAnnotation = null;\r\n    if (activeAnnotation.id == BASE_ANNOTATION_ID) {\r\n        baseAnnotation = activeAnnotation;\r\n    } else {\r\n        const [start, length] =\r\n            ownProps.annotatedText.getPositionOfAnnotation(activeAnnotation);\r\n        if (start === null || length === null) {\r\n            variantsData = null;\r\n        } else {\r\n            baseAnnotation = ownProps.annotatedText.getBaseAnnotation(\r\n                start,\r\n                length\r\n            );\r\n            const baseAnnotationData = getAnnotationsData(\r\n                [baseAnnotation],\r\n                sources,\r\n                workingSourceName\r\n            );\r\n            variantsData = [...baseAnnotationData, ...variantsData];\r\n        }\r\n    }\r\n\r\n    // make sure temporary annotation is first, then user created, then base annotation\r\n    if (variantsData) {\r\n        variantsData.sort((a, b) => {\r\n            if (a.isTemporary) {\r\n                return -1;\r\n            } else if (b.isTemporary) {\r\n                return 1;\r\n            } else if (a.userCreated) {\r\n                return -1;\r\n            } else if (b.userCreated) {\r\n                return 1;\r\n            } else if (a.annotation.id && b.annotation.id) {\r\n                return a.annotation.id - b.annotation.id;\r\n            } else {\r\n                return 1;\r\n            }\r\n        });\r\n    }\r\n\r\n    const notes: Array<Annotation> = annotations.filter(\r\n        (annotation: Annotation) => annotation.type === ANNOTATION_TYPES.note\r\n    );\r\n\r\n    const temporaryNotes = reducers.getTemporaryAnnotations(\r\n        state,\r\n        selectedWitness.id,\r\n        activeAnnotation.start,\r\n        activeAnnotation.length,\r\n        ANNOTATION_TYPES.note\r\n    );\r\n\r\n    const questionAnnotations: Array<Annotation> = annotations.filter(\r\n        (annotation: Annotation): boolean =>\r\n            annotation.type === ANNOTATION_TYPES.question\r\n    );\r\n    let questionsData = {};\r\n    if (questionAnnotations.length > 0) {\r\n        for (var i = 0; i < questionAnnotations.length; i++) {\r\n            const question = questionAnnotations[i];\r\n            questionsData[question.uniqueId] = {};\r\n            const isLoading = reducers.questionIsLoading(state, question);\r\n            questionsData[question.uniqueId][\"loading\"] = isLoading;\r\n            const questions = reducers.getQuestions(state, question.uniqueId);\r\n            questionsData[question.uniqueId][\"questions\"] = questions;\r\n        }\r\n    }\r\n\r\n    const temporaryQuestions = reducers.getTemporaryAnnotations(\r\n        state,\r\n        selectedWitness.id,\r\n        activeAnnotation.start,\r\n        activeAnnotation.length,\r\n        ANNOTATION_TYPES.question\r\n    );\r\n\r\n    let questionQuote = null;\r\n    if (temporaryQuestions.length > 0) {\r\n        const firstQuestion = temporaryQuestions[0];\r\n\r\n        let [start, end] =\r\n            ownProps.annotatedText.getPositionOfAnnotation(firstQuestion);\r\n        if (start) {\r\n            if (!end) {\r\n                end = start + 1;\r\n            }\r\n            const [startText, mainText, endText] =\r\n                ownProps.annotatedText.segmentedText.extractTextAroundPosition(\r\n                    start,\r\n                    end,\r\n                    [\"།\", \" \"]\r\n                );\r\n\r\n            const linkUrl = document.location.href;\r\n            questionQuote = (\r\n                <blockquote>\r\n                    {startText}\r\n                    <a href={linkUrl}>{mainText}</a>\r\n                    {endText}\r\n                </blockquote>\r\n            );\r\n        }\r\n    }\r\n    let fontSize = getTextFontSize(state);\r\n\r\n    return {\r\n        annotationsData: variantsData,\r\n        activeAnnotation: activeAnnotation,\r\n        baseAnnotation: baseAnnotation,\r\n        availableAnnotations: annotations,\r\n        user: user,\r\n        temporaryAnnotation: temporaryVariant,\r\n        inline: inline,\r\n        firstSelectedSegment: ownProps.firstSelectedSegment,\r\n        splitTextRect: ownProps.splitTextRect,\r\n        selectedWitness: selectedWitness,\r\n        notes: notes,\r\n        temporaryNotes: temporaryNotes,\r\n        questions: questionAnnotations,\r\n        temporaryQuestions: temporaryQuestions,\r\n        questionsData: questionsData,\r\n        questionQuote: questionQuote,\r\n        fontSize,\r\n    };\r\n};\r\n\r\nconst mergeProps = (stateProps: StateProps, dispatchProps, ownProps) => {\r\n    const { dispatch } = dispatchProps;\r\n\r\n    if (stateProps.questions.length > 0) {\r\n        for (var i = 0; i < stateProps.questions.length; i++) {\r\n            const question = stateProps.questions[i];\r\n            let loadQuestionData = true;\r\n            if (stateProps.questionsData.hasOwnProperty(question.uniqueId)) {\r\n                if (\r\n                    stateProps.questionsData[question.uniqueId].questions\r\n                        .length > 0 ||\r\n                    stateProps.questionsData[question.uniqueId].loading\r\n                ) {\r\n                    loadQuestionData = false;\r\n                }\r\n            }\r\n            if (loadQuestionData) {\r\n                dispatch(new actions.loadQuestion(question));\r\n            }\r\n        }\r\n    }\r\n\r\n    const addBreak = (\r\n        breakType: string,\r\n        selectBreak: boolean = false\r\n    ): (() => void) => {\r\n        return () => {\r\n            const location = ownProps.activeAnnotation;\r\n\r\n            const breakAnnotation = new Annotation(\r\n                null,\r\n                location.witness,\r\n                location.end + 1,\r\n                0,\r\n                null,\r\n                breakType,\r\n                stateProps.selectedWitness,\r\n                stateProps.user\r\n            );\r\n            let selectedWitnessData = reducers.dataFromWitness(\r\n                stateProps.selectedWitness\r\n            );\r\n\r\n            let actionsBatch = [];\r\n\r\n            actionsBatch.push(actions.createdAnnotation(breakAnnotation));\r\n            actionsBatch.push(\r\n                actions.appliedAnnotation(\r\n                    breakAnnotation.uniqueId,\r\n                    selectedWitnessData\r\n                )\r\n            );\r\n            if (selectBreak) {\r\n                actionsBatch.push(\r\n                    actions.changedActiveTextAnnotation(breakAnnotation)\r\n                );\r\n            } else {\r\n                actionsBatch.push(actions.changedActiveTextAnnotation(null));\r\n            }\r\n\r\n            dispatch(batchActions(actionsBatch));\r\n        };\r\n    };\r\n\r\n    const saveAnnotation = (\r\n        selectedAnnotation: TemporaryAnnotation,\r\n        content: string\r\n    ) => {\r\n        if (!selectedAnnotation.isTemporary) {\r\n            console.warn(\r\n                \"Tried to save a non-temporary annotation: %o\",\r\n                selectedAnnotation\r\n            );\r\n            return;\r\n        }\r\n\r\n        let selectedWitness = stateProps.selectedWitness;\r\n        let selectedWitnessData = reducers.dataFromWitness(selectedWitness);\r\n\r\n        const newAnnotation = new Annotation(\r\n            selectedAnnotation.id,\r\n            selectedAnnotation.witness,\r\n            selectedAnnotation.start,\r\n            selectedAnnotation.length,\r\n            content,\r\n            selectedAnnotation.type,\r\n            selectedAnnotation.creatorWitness,\r\n            stateProps.user,\r\n            selectedAnnotation.uniqueId,\r\n            selectedAnnotation.basedOn\r\n        );\r\n        newAnnotation.isSaved = selectedAnnotation.isSaved;\r\n        let actionsBatch = [];\r\n        let action = null;\r\n        if (newAnnotation.isSaved) {\r\n            action = actions.updatedAnnotation;\r\n        } else {\r\n            action = actions.createdAnnotation;\r\n        }\r\n        actionsBatch.push(action(newAnnotation));\r\n        actionsBatch.push(\r\n            actions.removedTemporaryAnnotation(selectedAnnotation)\r\n        );\r\n        // TODO: figure out what needs changing to handle note annotations\r\n        actionsBatch.push(\r\n            actions.appliedAnnotation(\r\n                newAnnotation.uniqueId,\r\n                selectedWitnessData\r\n            )\r\n        );\r\n        if (newAnnotation.type === ANNOTATION_TYPES.variant) {\r\n            actionsBatch.push(\r\n                actions.changedActiveTextAnnotation(newAnnotation)\r\n            );\r\n        }\r\n        dispatch(batchActions(actionsBatch));\r\n    };\r\n\r\n    return {\r\n        ...stateProps,\r\n        ...ownProps,\r\n        closeAnnotation: () => {\r\n            const activeAnnotation = stateProps.activeAnnotation;\r\n            if (activeAnnotation) {\r\n                const dismissTextAnnotation =\r\n                    actions.changedActiveTextAnnotation(null);\r\n                dispatch(dismissTextAnnotation);\r\n            }\r\n        },\r\n        didSelectAnnotation: (annotation: Annotation) => {\r\n            let selectedAnnotation: Annotation | null = null;\r\n            if (annotation.id == BASE_ANNOTATION_ID) {\r\n                selectedAnnotation = stateProps.baseAnnotation;\r\n            } else {\r\n                selectedAnnotation =\r\n                    _.find(\r\n                        stateProps.availableAnnotations,\r\n                        (value) => value.uniqueId == annotation.uniqueId\r\n                    ) || null;\r\n            }\r\n            let actionsBatch = [];\r\n            let selectedWitness = stateProps.selectedWitness;\r\n            // let selectedWitnessData = reducers.getWitnessData(\r\n            //     state,\r\n            //     selectedWitness.id\r\n            // );\r\n            let selectedWitnessData = reducers.dataFromWitness(selectedWitness);\r\n\r\n            if (annotation.uniqueId != stateProps.activeAnnotation.uniqueId) {\r\n                if (selectedWitness.isWorking) {\r\n                    if (annotation.id != BASE_ANNOTATION_ID) {\r\n                        actionsBatch.push(\r\n                            actions.appliedAnnotation(\r\n                                selectedAnnotation.uniqueId,\r\n                                selectedWitnessData\r\n                            )\r\n                        );\r\n                    }\r\n                    if (stateProps.activeAnnotation.id != BASE_ANNOTATION_ID) {\r\n                        actionsBatch.push(\r\n                            actions.removedAppliedAnnotation(\r\n                                stateProps.activeAnnotation.uniqueId,\r\n                                selectedWitnessData\r\n                            )\r\n                        );\r\n                    }\r\n                } else {\r\n                    if (\r\n                        stateProps.activeAnnotation.creatorWitness.id ===\r\n                        selectedWitness.id\r\n                    ) {\r\n                        // Replacing a default annotation\r\n\r\n                        // Currently selected annotation is a default\r\n                        // annotation. So need to remove that then\r\n                        // apply the newly selected annotation.\r\n\r\n                        actionsBatch.push(\r\n                            actions.removedDefaultAnnotation(\r\n                                stateProps.activeAnnotation.uniqueId,\r\n                                selectedWitnessData\r\n                            )\r\n                        );\r\n\r\n                        if (selectedAnnotation.id !== BASE_ANNOTATION_ID) {\r\n                            actionsBatch.push(\r\n                                actions.appliedAnnotation(\r\n                                    selectedAnnotation.uniqueId,\r\n                                    selectedWitnessData\r\n                                )\r\n                            );\r\n                        }\r\n                    } else {\r\n                        if (\r\n                            selectedAnnotation.creatorWitness.id ===\r\n                            selectedWitness.id\r\n                        ) {\r\n                            actionsBatch.push(\r\n                                actions.appliedDefaultAnnotation(\r\n                                    selectedAnnotation.uniqueId,\r\n                                    selectedWitnessData\r\n                                )\r\n                            );\r\n                        } else if (\r\n                            selectedAnnotation.id !== BASE_ANNOTATION_ID\r\n                        ) {\r\n                            actionsBatch.push(\r\n                                actions.appliedAnnotation(\r\n                                    selectedAnnotation.uniqueId,\r\n                                    selectedWitnessData\r\n                                )\r\n                            );\r\n                        }\r\n\r\n                        if (\r\n                            stateProps.activeAnnotation.id !==\r\n                            BASE_ANNOTATION_ID\r\n                        ) {\r\n                            actionsBatch.push(\r\n                                actions.removedAppliedAnnotation(\r\n                                    stateProps.activeAnnotation.uniqueId,\r\n                                    selectedWitnessData\r\n                                )\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                actionsBatch.push(\r\n                    actions.changedActiveTextAnnotation(selectedAnnotation)\r\n                );\r\n\r\n                dispatch(batchActions(actionsBatch));\r\n            }\r\n        },\r\n        editAnnotation: (selectedAnnotation: Annotation) => {\r\n            const basedOn =\r\n                selectedAnnotation.isWorkingAnnotation ||\r\n                selectedAnnotation.userCreated ||\r\n                selectedAnnotation.id === BASE_ANNOTATION_ID\r\n                    ? null\r\n                    : selectedAnnotation;\r\n            const temporaryAnnotation = new TemporaryAnnotation(\r\n                basedOn,\r\n                selectedAnnotation.witness,\r\n                selectedAnnotation.start,\r\n                selectedAnnotation.length,\r\n                selectedAnnotation.content,\r\n                selectedAnnotation.type,\r\n                stateProps.selectedWitness,\r\n                stateProps.user\r\n            );\r\n            if (selectedAnnotation.userCreated) {\r\n                // user annotations are updated\r\n                temporaryAnnotation.uniqueId = selectedAnnotation.uniqueId;\r\n                temporaryAnnotation.isSaved = selectedAnnotation.isSaved;\r\n            }\r\n\r\n            dispatch(\r\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\r\n            );\r\n        },\r\n        saveAnnotation: saveAnnotation,\r\n        cancelEditAnnotation: (selectedAnnotation: TemporaryAnnotation) => {\r\n            if (!selectedAnnotation.isTemporary) {\r\n                console.warn(\r\n                    \"Tried to call cancelEditAnnotation on a non-temporary annotation: %o\",\r\n                    selectedAnnotation\r\n                );\r\n                return;\r\n            }\r\n\r\n            const cancelAction =\r\n                actions.removedTemporaryAnnotation(selectedAnnotation);\r\n            dispatch(cancelAction);\r\n        },\r\n        deleteAnnotation: (annotation: Annotation) => {\r\n            let selectedWitness = stateProps.selectedWitness;\r\n            let selectedWitnessData = reducers.dataFromWitness(selectedWitness);\r\n            let actionsBatch = [];\r\n            if (annotation.userCreated) {\r\n                const deleteAction = actions.deletedAnnotation(\r\n                    annotation,\r\n                    selectedWitness\r\n                );\r\n                const removeAppliedAction = actions.removedAppliedAnnotation(\r\n                    annotation.uniqueId,\r\n                    selectedWitnessData\r\n                );\r\n                actionsBatch = [deleteAction, removeAppliedAction];\r\n            } else {\r\n                // Assume this is a default annotation that was\r\n                // automatically imported from external data\r\n                const removeDefaultAnnotation =\r\n                    actions.removedDefaultAnnotation(\r\n                        annotation.uniqueId,\r\n                        selectedWitnessData\r\n                    );\r\n                actionsBatch = [removeDefaultAnnotation];\r\n            }\r\n\r\n            if (stateProps.activeAnnotation.uniqueId === annotation.uniqueId) {\r\n                actionsBatch.push(actions.changedActiveTextAnnotation(null));\r\n            }\r\n\r\n            dispatch(batchActions(actionsBatch));\r\n        },\r\n        addNote: () => {\r\n            const activeAnnotation = ownProps.activeAnnotation;\r\n            const temporaryAnnotation = new TemporaryAnnotation(\r\n                null,\r\n                activeAnnotation.witness,\r\n                activeAnnotation.start,\r\n                activeAnnotation.length,\r\n                \"\",\r\n                ANNOTATION_TYPES.note,\r\n                stateProps.selectedWitness,\r\n                stateProps.user\r\n            );\r\n\r\n            dispatch(\r\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\r\n            );\r\n        },\r\n        editNote: (note: Annotation) => {\r\n            const temporaryAnnotation = new TemporaryAnnotation(\r\n                note,\r\n                note.witness,\r\n                note.start,\r\n                note.length,\r\n                note.content,\r\n                ANNOTATION_TYPES.note,\r\n                stateProps.selectedWitness,\r\n                stateProps.user\r\n            );\r\n\r\n            dispatch(\r\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\r\n            );\r\n        },\r\n        addPageBreak: addBreak(ANNOTATION_TYPES.pageBreak),\r\n        addLineBreak: addBreak(ANNOTATION_TYPES.lineBreak),\r\n        addQuestion: () => {\r\n            const activeAnnotation = ownProps.activeAnnotation;\r\n            const temporaryAnnotation = new TemporaryAnnotation(\r\n                null,\r\n                activeAnnotation.witness,\r\n                activeAnnotation.start,\r\n                activeAnnotation.length,\r\n                \"\",\r\n                ANNOTATION_TYPES.question,\r\n                stateProps.selectedWitness,\r\n                stateProps.user\r\n            );\r\n\r\n            dispatch(\r\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\r\n            );\r\n        },\r\n        saveQuestion: (\r\n            question: TemporaryAnnotation,\r\n            title: string,\r\n            content: string\r\n        ) => {\r\n            let [start, end] =\r\n                ownProps.annotatedText.getPositionOfAnnotation(question);\r\n\r\n            const questionQuoteText = ReactDOMServer.renderToStaticMarkup(\r\n                stateProps.questionQuote\r\n            );\r\n            let questionText = questionQuoteText + content;\r\n\r\n            saveAnnotation(question, content);\r\n            const createdQuestionAction = actions.createdQuestion(\r\n                question,\r\n                title,\r\n                questionText\r\n            );\r\n            dispatch(createdQuestionAction);\r\n        },\r\n    };\r\n};\r\n\r\nconst AnnotationControlsContainer = connect(\r\n    mapStateToProps,\r\n    null,\r\n    mergeProps\r\n)(AnnotationControls);\r\n\r\nexport default AnnotationControlsContainer;\r\n","// @flow\r\nimport SegmentedText from \"./SegmentedText\";\r\nimport AnnotatedText from \"./AnnotatedText\";\r\n\r\nexport type Splitter = (string) => number[];\r\n\r\nexport default class SplitText {\r\n    annotatedText: AnnotatedText;\r\n    splitter: Splitter;\r\n    _texts: SegmentedText[] | null;\r\n    _textsId: string | null;\r\n    _textsFinalPositions: number[];\r\n\r\n    constructor(annotatedText: AnnotatedText, splitter: Splitter) {\r\n        this.annotatedText = annotatedText;\r\n        this.splitter = splitter;\r\n        this._texts = null;\r\n        this._textsId = null;\r\n        this._textsFinalPositions = [];\r\n    }\r\n\r\n    get texts(): SegmentedText[] {\r\n        if (!this.annotatedText) {\r\n            return [];\r\n        }\r\n        if (\r\n            !this._texts ||\r\n            this._textsId !== this.annotatedText.getUniqueId()\r\n        ) {\r\n            this._textsFinalPositions = [];\r\n            const segmentedText = this.annotatedText.segmentedText;\r\n            const textString = segmentedText.getText();\r\n            let splitPositions = this.splitter(textString).filter(\r\n                (l) => l !== 0\r\n            );\r\n            if (splitPositions.length === 0) {\r\n                this._textsFinalPositions.push(textString.length);\r\n                return [segmentedText];\r\n            }\r\n            let lastPosition = splitPositions[splitPositions.length - 1];\r\n            if (lastPosition + 1 < textString.length) {\r\n                splitPositions.push(textString.length - 1);\r\n            }\r\n            const segments = segmentedText.segments;\r\n            let startIndex = 0;\r\n            let texts = [];\r\n            for (let i = 0; i < splitPositions.length; i++) {\r\n                const position = splitPositions[i];\r\n                const endIndex = segmentedText.indexOfSegmentAtPosition(\r\n                    position - 1\r\n                );\r\n                let textSegments;\r\n                if (i == splitPositions.length - 1) {\r\n                    // final position\r\n                    textSegments = segments.slice(startIndex);\r\n                } else {\r\n                    textSegments = segments.slice(startIndex, endIndex + 1);\r\n                }\r\n\r\n                const text = new SegmentedText(textSegments);\r\n                texts.push(text);\r\n                startIndex = endIndex + 1;\r\n                if (endIndex >= 0) {\r\n                    const finalSegment = segments[endIndex];\r\n                    this._textsFinalPositions.push(finalSegment.end);\r\n                }\r\n            }\r\n\r\n            this._texts = texts.filter((l) => l.segments.length > 0);\r\n            this._textsId = this.annotatedText.getUniqueId();\r\n        }\r\n        return this._texts || [];\r\n    }\r\n\r\n    getTextsFinalPositions(): number[] {\r\n        this.texts;\r\n        return this._textsFinalPositions;\r\n    }\r\n\r\n    /**\r\n     * Return the index of the text portion that contains the given position.\r\n     *\r\n     * @param position\r\n     * @returns number\r\n     */\r\n    getTextIndexOfPosition(position: number): number {\r\n        const textsFinalPositions = this.getTextsFinalPositions();\r\n        let lastPosition = 0;\r\n        let textIndex = null;\r\n        for (let i = 0; i < textsFinalPositions.length; i++) {\r\n            let endPosition = textsFinalPositions[i];\r\n            if (position >= lastPosition && position <= endPosition) {\r\n                textIndex = i;\r\n                break;\r\n            }\r\n            lastPosition = endPosition;\r\n        }\r\n        if (textIndex === null) {\r\n            // Likely an insertion at the end of a text\r\n            console.warn(\"no index for position %d\", position);\r\n            textIndex = textsFinalPositions.length - 1;\r\n        }\r\n        return textIndex;\r\n    }\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AASA;AAMA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAFA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAAA;AAEA;AACA;AAAA;AAIA;AACA;AACA;AACA;AA3CA;AACA;AACA;AAAA;AA0CA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AAQA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AASA;AAMA;AACA;AAAA;AAEA;AACA;AAKA;AAOA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAQA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AAGA;AAAA;AAIA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAUA;AAIA;AAEA;AACA;AACA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAYA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AAKA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAAA;AACA;AAMA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAMA;AACA;AACA;AAIA;AAMA;AAGA;AAMA;AACA;AACA;AAIA;AAMA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAMA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AAGA;AACA;AACA;AAWA;AAGA;AACA;AACA;AACA;AACA;AACA;AAWA;AAGA;AACA;AAKA;AAAA;AAAA;AAAA;AACA;AAEA;AAGA;AAEA;AACA;AAKA;AACA;AArQA;AAuQA;AACA;AACA;AAMA;;;;;;;;;;;;;;;;;;;;;;AC/zBA;AACA;AACA;AAGA;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;A","sourceRoot":""}