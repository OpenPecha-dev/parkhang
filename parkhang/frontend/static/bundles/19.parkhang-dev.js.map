{"version":3,"file":"19.parkhang-dev.js","sources":["webpack://parkhang/./app/components/TextDetail/Text.css","webpack://parkhang/./app/components/TextDetail/Text.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"paddingSide\":\"20px\",\"maxWidth\":\"600px\",\"text\":\"Text---text\",\"syncIdClass\":\"Text---syncIdClass\",\"textFirstRow\":\"Text---textFirstRow\",\"textLine\":\"Text---textLine\",\"textline\":\"Text---textline\",\"limitWidth\":\"Text---limitWidth\",\"textContainer\":\"Text---textContainer\",\"annotation\":\"Text---annotation\",\"selectedAnnotation\":\"Text---selectedAnnotation\",\"removedByAnnotation\":\"Text---removedByAnnotation\",\"insertion\":\"Text---insertion\",\"highlight\":\"Text---highlight\",\"activeHighlight\":\"Text---activeHighlight\",\"lineBreak\":\"Text---lineBreak\",\"pageBreak\":\"Text---pageBreak\",\"selectedRangelight\":\"Text---selectedRangelight\",\"selectedRangeDark\":\"Text---selectedRangeDark\",\"selectedImage\":\"Text---selectedImage\"};","// @flow\r\nimport React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport styles from \"./Text.css\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport {\r\n    INSERTION_KEY,\r\n    DELETION_KEY,\r\n    PAGE_BREAK_KEY,\r\n    LINE_BREAK_KEY,\r\n} from \"lib/AnnotatedText\";\r\nimport _ from \"lodash\";\r\nimport SegmentedText from \"lib/SegmentedText\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport Witness from \"lib/Witness\";\r\nimport { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport GraphemeSplitter from \"grapheme-splitter\";\r\nimport { find } from \"lodash\";\r\nimport { withTheme } from \"@mui/styles\";\r\n\r\nexport function idForSegment(segment: TextSegment): string {\r\n    return \"s_\" + segment.start;\r\n}\r\n\r\nexport function idForDeletedSegment(segment: TextSegment): string {\r\n    return \"ds_\" + segment.start;\r\n}\r\n\r\nexport function idForInsertion(segment: TextSegment): string {\r\n    return \"i_\" + segment.start;\r\n}\r\n\r\nexport function idForPageBreak(segment: TextSegment): string {\r\n    return \"p_\" + (segment.end + 1);\r\n}\r\n\r\nexport function idForLineBreak(segment: TextSegment): string {\r\n    return \"l_\" + (segment.end + 1);\r\n}\r\n\r\nexport type Props = {\r\n    segmentedText: SegmentedText,\r\n    annotationPositions: { [string]: Annotation[] },\r\n    selectedSegmentId: (id: string) => void,\r\n    activeAnnotations: { [AnnotationUniqueId]: Annotation } | null,\r\n    getBaseAnnotation: (annotation: Annotation) => Annotation,\r\n    selectedAnnotatedSegments: TextSegment[],\r\n    row: number,\r\n    activeAnnotation: Annotation | null,\r\n    searchValue: string | null,\r\n    selectedSearchResult: {\r\n        textId: number,\r\n        start: number,\r\n        length: number,\r\n    } | null,\r\n    searchStringPositions: { [position: number]: [number, number] },\r\n    fontSize?: number,\r\n    activeWitness: Witness,\r\n    changeSyncIdOnClick: () => void,\r\n    changeScrollToId: () => void,\r\n    textAlignmentById: {},\r\n    selectedSourceRange: [],\r\n    selectedTargetRange: [],\r\n};\r\n\r\nexport type State = {\r\n    segmentedText: SegmentedText,\r\n};\r\n\r\nimport ReactDOMServer from \"react-dom/server\";\r\nimport PageBreakIcon from \"images/page_break_icon.svg\";\r\nconst PARA_SYMBOL = String.fromCharCode(182);\r\nconst pageBreakIconString = ReactDOMServer.renderToStaticMarkup(\r\n    <PageBreakIcon />\r\n);\r\nclass Text extends React.Component<Props, State> {\r\n    _renderedSegments: TextSegment[] | null;\r\n    _renderedHtml: { __html: string } | null;\r\n    textAlignmentById;\r\n    rangeSelect;\r\n    theme;\r\n    constructor(props: Props) {\r\n        super(props);\r\n        this.textAlignmentById = [];\r\n        this.state = {\r\n            segmentedText: props.segmentedText,\r\n        };\r\n        this.textAlignmentById = this.props.textAlignmentById;\r\n        this._renderedSegments = null;\r\n        this._renderedHtml = null;\r\n        this.rangeSelect = [];\r\n        this.theme = props.theme;\r\n    }\r\n    UNSAFE_componentWillReceiveProps(nextProps: Props) {\r\n        this.setState((prevState: State, props: Props) => {\r\n            return {\r\n                ...prevState,\r\n                segmentedText: nextProps.segmentedText,\r\n            };\r\n        });\r\n    }\r\n\r\n    annotationsForSegment(segment: TextSegment): Annotation[] {\r\n        let annotations: Annotation[] = [];\r\n        const foundAnnotations =\r\n            this.props.annotationPositions[String(segment.start)];\r\n        if (foundAnnotations) {\r\n            annotations = foundAnnotations;\r\n        }\r\n        const insertions =\r\n            this.props.annotationPositions[INSERTION_KEY + segment.start] || [];\r\n        const deletions =\r\n            this.props.annotationPositions[DELETION_KEY + segment.start] || [];\r\n        const pageBreaks =\r\n            this.props.annotationPositions[\r\n                PAGE_BREAK_KEY + (segment.end + 1)\r\n            ] || [];\r\n        const lineBreaks =\r\n            this.props.annotationPositions[\r\n                LINE_BREAK_KEY + (segment.end + 1)\r\n            ] || [];\r\n\r\n        return annotations.concat(\r\n            insertions,\r\n            deletions,\r\n            pageBreaks,\r\n            lineBreaks\r\n        );\r\n    }\r\n\r\n    segmentsContainSegment(segments: TextSegment[], segment: TextSegment) {\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let listSegment = segments[i];\r\n            if (\r\n                listSegment.start === segment.start &&\r\n                listSegment.text === segment.text\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    selectedElement(element: Element) {\r\n        if (element.tagName === \"DIV\") {\r\n            this.props.selectedSegmentId(\"\");\r\n            return;\r\n        }\r\n        let sourceRangeSelection = [];\r\n        let targetRangeSelection = [];\r\n        const selection = document.getSelection();\r\n        var clickId = parseInt(element.id.replace(\"s_\", \"\"));\r\n        this.props.changeSyncIdOnClick(clickId);\r\n        if (element?.id.includes(\"s_\") && this.props.condition) {\r\n            this.props.changeScrollToId({ id: null, from: null });\r\n\r\n            let id = parseInt(element.id.replace(\"s_\", \"\"));\r\n            let rangeUnique = find(\r\n                this.textAlignmentById,\r\n                (l) => id >= l.start && id < l.end\r\n            );\r\n            if (rangeUnique) {\r\n                for (let i = rangeUnique.start; i < rangeUnique.end; i++) {\r\n                    sourceRangeSelection.push(i);\r\n                }\r\n                for (let i = rangeUnique.TStart; i < rangeUnique.TEnd; i++) {\r\n                    targetRangeSelection.push(i);\r\n                }\r\n                this.props.changeSelectedRange({\r\n                    source: sourceRangeSelection,\r\n                    target: targetRangeSelection,\r\n                });\r\n            }\r\n        }\r\n\r\n        if (selection && selection.type === \"Range\") {\r\n            return;\r\n        }\r\n        this.props.selectedSegmentId(element.id);\r\n\r\n        if (!element.id) {\r\n            this.props.changeSelectedRange({ source: [], target: [] });\r\n        }\r\n    }\r\n\r\n    generateHtml(renderProps: Props, renderState: State): { __html: string } {\r\n        let segments = renderState.segmentedText.segments;\r\n\r\n        let textLineClass = styles.textLine;\r\n        let segmentHTML = '<p class=\"' + textLineClass + '\">';\r\n        if (segments.length === 0) return { __html: segmentHTML };\r\n\r\n        const insertionClass = styles.insertion;\r\n        const endPosition = segments[segments.length - 1].end + 1;\r\n        if (renderProps.annotationPositions[INSERTION_KEY + endPosition]) {\r\n            const endSegment = new TextSegment(endPosition, \"\");\r\n            segments.push(endSegment);\r\n        }\r\n        if (renderProps.annotationPositions[PAGE_BREAK_KEY + endPosition]) {\r\n            const endSegment = new TextSegment(endPosition, \"\");\r\n            segments.push(endSegment);\r\n        }\r\n        if (renderProps.annotationPositions[LINE_BREAK_KEY + endPosition]) {\r\n            const endSegment = new TextSegment(endPosition, \"\");\r\n            segments.push(endSegment);\r\n        }\r\n\r\n        let activeAnnotations = renderProps.activeAnnotations || {};\r\n\r\n        let highlightClass = styles.highlight;\r\n        let activeHighlightClass = styles.activeHighlight;\r\n        let activeSearchResultEnd = null;\r\n        let processedInactiveInsertions = {};\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let segment = segments[i];\r\n            let classAttribute = \"\";\r\n            let classes = [];\r\n            let annotations = this.annotationsForSegment(segment);\r\n            let deletionText = null;\r\n            let selectedCurrentDeletion = false;\r\n            let selectedCurrentPageBreak = false;\r\n            let selectedCurrentLineBreak = false;\r\n            let lineBreakAnnotation = false;\r\n            let pageBreakAnnotation = null;\r\n\r\n            if (annotations) {\r\n                let activeInsertions = [];\r\n                let inactiveInsertions = [];\r\n                let remainingAnnotations = [];\r\n                let activeDeletions = [];\r\n\r\n                for (let j = 0, len = annotations.length; j < len; j++) {\r\n                    let annotation = annotations[j];\r\n                    if (annotation.isInsertion) {\r\n                        if (annotation.uniqueId in activeAnnotations) {\r\n                            activeInsertions.push(annotation);\r\n                        } else {\r\n                            // Only first inactive insertion at a position will\r\n                            // be shown, so only process first one.\r\n                            // TODO: need to check if there is an active insertion\r\n                            // at the same place. If so, ignore inactive insertion\r\n                            // as they should be shown in the popover.\r\n                            const annotationKey = annotation.start;\r\n                            if (\r\n                                !processedInactiveInsertions.hasOwnProperty(\r\n                                    annotationKey\r\n                                )\r\n                            ) {\r\n                                inactiveInsertions.push(annotation);\r\n                                processedInactiveInsertions[annotationKey] =\r\n                                    annotation;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (annotation.isDeletion) {\r\n                            if (annotation.uniqueId in activeAnnotations) {\r\n                                activeDeletions.push(annotation);\r\n                            }\r\n                        } else if (\r\n                            annotation.type === ANNOTATION_TYPES.pageBreak &&\r\n                            !renderProps.activeWitness.isWorking\r\n                        ) {\r\n                            pageBreakAnnotation = annotation;\r\n                        } else if (\r\n                            annotation.type === ANNOTATION_TYPES.lineBreak &&\r\n                            !renderProps.activeWitness.isWorking\r\n                        ) {\r\n                            lineBreakAnnotation = annotation;\r\n                        } else {\r\n                            remainingAnnotations.push(annotation);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (\r\n                    activeInsertions.length === 0 &&\r\n                    inactiveInsertions.length > 0\r\n                ) {\r\n                    const insertion = inactiveInsertions[0];\r\n                    const insertionId = idForInsertion(segment);\r\n                    let insertionClasses = insertionClass;\r\n                    if (\r\n                        renderProps.activeAnnotation &&\r\n                        renderProps.activeAnnotation.isInsertion &&\r\n                        renderProps.activeAnnotation.start === insertion.start\r\n                    ) {\r\n                        insertionClasses += \" \" + styles.selectedAnnotation;\r\n                    }\r\n\r\n                    segmentHTML +=\r\n                        \"<span id=\" +\r\n                        insertionId +\r\n                        \" key=\" +\r\n                        insertionId +\r\n                        ' class=\"' +\r\n                        insertionClasses +\r\n                        '\">' +\r\n                        insertion.content +\r\n                        \"</span>\";\r\n                }\r\n\r\n                if (activeDeletions.length > 0) {\r\n                    const activeDeletion = activeDeletions[0];\r\n                    const baseAnnotation =\r\n                        renderProps.getBaseAnnotation(activeDeletion);\r\n                    deletionText = baseAnnotation.content;\r\n                    if (\r\n                        renderProps.activeAnnotation &&\r\n                        renderProps.activeAnnotation.isDeletion &&\r\n                        renderProps.activeAnnotation.start ===\r\n                            activeDeletion.start &&\r\n                        renderProps.activeAnnotation.length ===\r\n                            activeDeletion.length &&\r\n                        segment.length === 0\r\n                    ) {\r\n                        selectedCurrentDeletion = true;\r\n                    }\r\n                }\r\n\r\n                if (pageBreakAnnotation) {\r\n                    if (\r\n                        renderProps.activeAnnotation &&\r\n                        renderProps.activeAnnotation.uniqueId ===\r\n                            pageBreakAnnotation.uniqueId\r\n                    ) {\r\n                        selectedCurrentPageBreak = true;\r\n                    }\r\n                }\r\n\r\n                if (lineBreakAnnotation) {\r\n                    if (\r\n                        renderProps.activeAnnotation &&\r\n                        renderProps.activeAnnotation.uniqueId ===\r\n                            lineBreakAnnotation.uniqueId\r\n                    ) {\r\n                        selectedCurrentLineBreak = true;\r\n                    }\r\n                }\r\n\r\n                if (\r\n                    remainingAnnotations.length > 0 ||\r\n                    activeInsertions.length > 0\r\n                ) {\r\n                    classes.push(styles.annotation);\r\n                }\r\n            }\r\n\r\n            // It's an insertion at the end of the text, which should have just been added to the html.\r\n            // So break as we don't want anymore segment html adding.\r\n            if (segment.start === endPosition) {\r\n                break;\r\n            }\r\n\r\n            let id = null;\r\n            if (segment.length === 0) {\r\n                id = idForDeletedSegment(segment);\r\n                classes.push(styles.removedByAnnotation);\r\n                if (deletionText) {\r\n                    segment = new TextSegment(segment.start, deletionText);\r\n                }\r\n            } else {\r\n                id = idForSegment(segment);\r\n            }\r\n\r\n            if (\r\n                this.segmentsContainSegment(\r\n                    renderProps.selectedAnnotatedSegments,\r\n                    segment\r\n                ) ||\r\n                selectedCurrentDeletion\r\n            ) {\r\n                classes.push(styles.selectedAnnotation);\r\n            }\r\n\r\n            if (\r\n                renderProps.selectedSourceRange.includes(segment.start) &&\r\n                renderProps.condition\r\n            ) {\r\n                let newClass =\r\n                    renderProps.theme.palette.mode === \"light\"\r\n                        ? styles.selectedRangelight\r\n                        : styles.selectedRangeDark;\r\n                classes.push(newClass);\r\n            }\r\n\r\n            if (classes.length > 0) {\r\n                let className = classnames(...classes);\r\n                classAttribute = 'class=\"' + className + '\"';\r\n            }\r\n\r\n            let segmentContent = segment.text;\r\n\r\n            // Add search result highlight if required.\r\n            if (renderProps.searchStringPositions) {\r\n                let segmentStart = segment.start;\r\n                let position = segmentStart;\r\n                segmentContent = \"\";\r\n\r\n                let highlight = highlightClass;\r\n                if (\r\n                    renderProps.selectedSearchResult &&\r\n                    renderProps.selectedSearchResult.start <= position &&\r\n                    renderProps.selectedSearchResult.start +\r\n                        renderProps.selectedSearchResult.length >\r\n                        position\r\n                ) {\r\n                    highlight = activeHighlightClass;\r\n                }\r\n\r\n                for (let j = 0; j < segment.text.length; j++) {\r\n                    let char = segment.text.charAt(j);\r\n                    position = segmentStart + j;\r\n                    if (activeSearchResultEnd) {\r\n                        let [start, end] = activeSearchResultEnd;\r\n                        if (j === 0) {\r\n                            segmentContent +=\r\n                                '<span class=\"' + highlight + '\">';\r\n                        }\r\n                        if (position === end) {\r\n                            segmentContent += char + \"</span>\";\r\n                            activeSearchResultEnd = null;\r\n                        } else if (j === segment.text.length - 1) {\r\n                            segmentContent += char + \"</span>\";\r\n                        } else {\r\n                            segmentContent += char;\r\n                        }\r\n                    } else if (position in renderProps.searchStringPositions) {\r\n                        let [start, end] =\r\n                            renderProps.searchStringPositions[position];\r\n                        segmentContent +=\r\n                            '<span class=\"' + highlight + '\">' + char;\r\n                        if (j === segment.text.length - 1 || position === end) {\r\n                            segmentContent += \"</span>\";\r\n                        }\r\n                        if (position < end) {\r\n                            activeSearchResultEnd = [start, end];\r\n                        }\r\n                    } else {\r\n                        segmentContent += char;\r\n                    }\r\n                }\r\n            }\r\n\r\n            segmentHTML +=\r\n                \"<span id=\" +\r\n                id +\r\n                \" key=\" +\r\n                id +\r\n                \" \" +\r\n                classAttribute +\r\n                \">\" +\r\n                segmentContent +\r\n                \"</span>\";\r\n\r\n            if (pageBreakAnnotation) {\r\n                let pageBreakClasses = [styles.pageBreak];\r\n                if (selectedCurrentPageBreak) {\r\n                    pageBreakClasses.push(styles.selectedAnnotation);\r\n                }\r\n                const pageBreakClassAttribute =\r\n                    ' class=\"' + pageBreakClasses.join(\" \") + '\" ';\r\n                segmentHTML +=\r\n                    \"<span id=\" +\r\n                    idForPageBreak(segment) +\r\n                    \" key=\" +\r\n                    idForPageBreak(segment) +\r\n                    pageBreakClassAttribute +\r\n                    \">\" +\r\n                    pageBreakIconString +\r\n                    \"</span>\";\r\n            }\r\n            if (lineBreakAnnotation) {\r\n                let lineBreakClasses = [styles.lineBreak];\r\n                if (selectedCurrentLineBreak) {\r\n                    lineBreakClasses.push(styles.selectedAnnotation);\r\n                }\r\n                const lineBreakClassAttribute =\r\n                    ' class=\"' + lineBreakClasses.join(\" \") + '\" ';\r\n                segmentHTML +=\r\n                    \"<span id=\" +\r\n                    idForLineBreak(segment) +\r\n                    \" key=\" +\r\n                    idForLineBreak(segment) +\r\n                    lineBreakClassAttribute +\r\n                    \">\" +\r\n                    PARA_SYMBOL +\r\n                    \"</span>\";\r\n\r\n                segmentHTML += '</p><p class=\"' + textLineClass + '\">';\r\n            }\r\n        }\r\n\r\n        this._renderedSegments = segments;\r\n\r\n        segmentHTML += \"</p>\";\r\n        const html = {\r\n            __html: segmentHTML,\r\n        };\r\n        return html;\r\n    }\r\n    shouldComponentUpdate(nextProps: Props, nextState: State) {\r\n        const renderedHtml = this.generateHtml(nextProps, nextState);\r\n\r\n        if (this.props.fontSize !== nextProps.fontSize) {\r\n            return true;\r\n        } else if (\r\n            this._renderedHtml &&\r\n            renderedHtml.__html === this._renderedHtml.__html\r\n        ) {\r\n            return false;\r\n        } else {\r\n            this._renderedHtml = renderedHtml;\r\n            return true;\r\n        }\r\n        // return false;\r\n    }\r\n    componentDidUpdate() {\r\n        this.textAlignmentById = this.props.textAlignmentById;\r\n    }\r\n\r\n    render() {\r\n        let classes = [styles.text];\r\n        if (this.props.row === 0) {\r\n            classes.push(styles.textFirstRow);\r\n        }\r\n        // Generate HTML manually as it is much faster when\r\n        // creating large numbers of elements, such as these spans.\r\n        const html = this._renderedHtml\r\n            ? this._renderedHtml\r\n            : this.generateHtml(this.props, this.state);\r\n        if (!this._renderedHtml) {\r\n            this._renderedHtml = html;\r\n        }\r\n        return (\r\n            <div className={styles.textContainer}>\r\n                <div\r\n                    className={classnames(...classes)}\r\n                    id=\"text1\"\r\n                    dangerouslySetInnerHTML={html}\r\n                    style={{\r\n                        fontSize: this.props.fontSize,\r\n                        fontFamily: \"var(--tibetan-fonts)\",\r\n                    }}\r\n                    onClick={(e) => {\r\n                        this.selectedElement(e.target);\r\n                    }}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default withTheme(Text);\r\n"],"mappings":";;;;;;;;;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AA+BA;AACA;AACA;AACA;AACA;AAEA;;;;;AAMA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AAVA;AAWA;AACA;;;AAAA;AACA;AACA;AAEA;AAFA;AAIA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAIA;AAKA;AAMA;;;AAEA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AASA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AASA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AAGA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAVA;AAcA;;;;AA1dA;AACA;AA4dA;;;;A","sourceRoot":""}