{"version":3,"file":"app_components_Editors_index_js-node_modules_react-virtualized_styles_css.parkhang-dev.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAGA;AACA;AAGA;;AACA;AAGA;AAAA;AACA;AAAA;AACA;;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AANA;AASA;AAEA;AADA;AAIA;AACA;AACA;AAAA;AAAA;AARA;AAWA;AACA;AACA;AAHA;AAMA;AAEA;AADA;AAIA;AACA;AACA;AAAA;AAAA;AARA;AAYA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AANA;AASA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AALA;AASA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAHA;AAKA;AAEA;AACA;AACA;AACA;AACA;AALA;AADA;AAUA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAUA;;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACrMA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AAIA;AACA;;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AAIA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AAuBA;;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAFA;AAuBA;AACA;AAKA;AAEA;AACA;AAFA;AAKA;AAAA;AAAA;AACA;AASA;AACA;AACA;AAzBA;AA4CA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AAEA;AAIA;;AACA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/HA;;AAEA;;;;;AACA;AAAA;;AAAA;;AACA;AACA;AAAA;AAAA;AAFA;AAGA;;;;AAOA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAjBA;AACA;AACA;AAAA;AAAA;AACA;;;;AATA;;AA0BA;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAWA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;AAIA;;AAEA;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;AADA;AAMA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AATA;AAaA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAOA;AAAA;AAAA;AAGA;AAAA;AAAA;AAOA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvEA;;;;;;;;;;;;;;;;;;AADA;AACA;AACA;AAEA;AACA;AASA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;;AACA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AACA;AADA;AAAA;;AAAA;AAEA;AACA;AAHA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAOA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;;AACA;AAIA;AACA;AACA;AAAA;AAIA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAIA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AAEA;;AADA;AASA;AACA;AACA;AACA;AAFA;AAFA;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAFA;AANA;AAYA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAQA;AAKA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAHA;AAQA;AAAA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAMA;AAAA;AAKA;AACA;AACA;AACA;AACA;AALA;AAUA;AAAA;AAAA;AAAA;AACA;AAAA;AAKA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAPA;AASA;AAAA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAHA;AASA;AAAA;AAOA;;AAEA;;;;;;;;;;;;;;;;;;;;;;ACzPA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAiBA;;AAEA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAMA;AACA;AAMA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAVA;AAaA;;AAEA;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAFA;AASA;AACA;AAAA;AAAA;AAAA;AAFA;AAUA;AACA;AAAA;AAAA;AAFA;AAQA;AACA;AACA;AACA;AACA;AAJA;AADA;AAiBA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxDA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;;AAKA;AACA;AAAA;AAAA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AACA;AACA;;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;;AACA;AACA;AACA;AACA;AAFA;AAIA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;;AAIA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AADA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAbA;AAiBA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AADA;AAeA;AACA;AACA;AACA;AAHA;AAKA;AANA;AASA;AACA;AAAA;AAAA;AACA;AACA;AAJA;AAOA;AAAA;AAAA;AAAA;AACA;AAFA;AAOA;AAAA;AAAA;AAAA;AACA;AAFA;AAMA;AAAA;AAAA;AAAA;AACA;AAFA;AAMA;AAAA;AAAA;AAAA;AACA;AAFA;AAQA;AAAA;AAAA;AAGA;AAAA;AAAA;AAGA;AAAA;AAAA;AAGA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AAWA;;AAEA;;AAQA;AACA;AACA;AACA;AAFA;AAIA;;AAEA;AACA;AAAA;AAAA;AAAA;;AAEA;AAEA;AACA;AACA;AACA;AAJA;AAMA;AAAA;AAAA;AANA;AAQA;AAAA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnIA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAFA;AAIA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAMA;;AAEA;AACA;AACA;AACA;AAFA;AAIA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AAEA;AAAA;AAAA;AAAA;AAKA;AAEA;AAAA;AAAA;AACA;AAFA;AAKA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAFA;AADA;AAFA;AAaA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAdA;AAgBA;;AAEA;;;;;;;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAGA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAQA;AACA;AACA;AACA;;AAEA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAHA;AADA;AAQA;AACA;AAAA;AAAA;AAFA;AAOA;AAAA;AAGA;AACA;AAAA;AAAA;AAFA;AAOA;AAAA;AAGA;AACA;AAAA;AAAA;AAFA;AAOA;AAAA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;;AAEA;;;;;;;;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AACA;;AAOA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AA8CA;AACA;AACA;AACA;AACA;AAJA;;AAOA;;;;;AAKA;AAAA;;AAAA;;AACA;AAEA;AACA;AACA;AALA;AAMA;;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AAEA;AACA;;;AAEA;AACA;;AACA;AAMA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAOA;AAEA;;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAWA;AACA;AACA;;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AAGA;AACA;;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;;;AAEA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAKA;AACA;;;AAGA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAKA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AAjBA;AAoBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAtBA;;AAyBA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAUA;AACA;AACA;AAEA;AAAA;AAHA;AAFA;AAYA;AACA;AACA;AACA;AAAA;AAEA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAKA;AACA;AAAA;AAKA;;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AARA;AAYA;AACA;;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAYA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAOA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;;AAEA;AACA;;AACA;AAKA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AANA;AASA;AAEA;;AAEA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AACA;AAGA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAFA;AAKA;AACA;;AACA;;AACA;AACA;AACA;AAAA;AAEA;;AAEA;;AACA;AACA;AACA;;AAEA;AAIA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAeA;AAEA;AACA;AAAA;AAAA;AAFA;AAQA;AAGA;AAGA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAyBA;AACA;AAAA;AAAA;AAFA;AAMA;;;;AAlmBA;;AAqmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACprBA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;;AAUA;AAMA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;;AACA;AACA;;AADA;AAGA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAAA;AAEA;;AACA;AAIA;AACA;AACA;AACA;AA3CA;;AAEA;AAAA;AA0CA;;;AAEA;AACA;;AACA;AAIA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AAGA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAMA;;AACA;AAIA;AACA;;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;;AACA;AACA;AAEA;;AACA;;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;;AAEA;AAEA;AAAA;AAGA;AACA;;AAEA;AAQA;;AAOA;AACA;AACA;AACA;AACA;AACA;;AAiBA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;;AAEA;AASA;AAMA;AACA;AAAA;AAEA;AACA;AAKA;AAOA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AAIA;AAKA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAGA;AAQA;AACA;AAAA;AAGA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAQA;;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAOA;AACA;AAGA;AAAA;AAIA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AAmBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AAKA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AAGA;AACA;AACA;AAEA;AAUA;AAIA;AAEA;AACA;;AAMA;AACA;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAIA;AACA;AAIA;AACA;;AAEA;AACA;AAEA;AAYA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAIA;;AAMA;AACA;AAGA;;AACA;AACA;;AAEA;AAGA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAGA;AAAA;AAEA;;AACA;AACA;AAEA;AACA;AACA;;AACA;;AAEA;AACA;AACA;AACA;AAMA;;AACA;AACA;AAMA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAEA;;AAOA;AACA;AAMA;AACA;AACA;AAIA;AAMA;AAGA;AAMA;;AAEA;AAIA;AAMA;AACA;AACA;;AAEA;AAIA;AACA;AACA;AACA;AACA;AAMA;;AAUA;AACA;AACA;AACA;AACA;;AAEA;AAGA;AACA;AACA;AACA;AACA;AAIA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AAKA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAWA;AAGA;AACA;AACA;AAWA;AAGA;AACA;AACA;AACA;AACA;AACA;AAWA;AAGA;AACA;AAKA;AAAA;AAAA;AAAA;;AAGA;AAGA;AAEA;AACA;AAKA;AACA;AArQA;AAuQA;;AAEA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/zBA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;;AACA;;;;;AACA;AACA;AAAA;;AAAA;AAEA;;;;AACA;AAAA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AAAA;;AACA;AACA;;AACA;AAAA;;AACA;AACA;;AACA;AAAA;;AACA;AACA;;AACA;AAAA;;AACA;AACA;AACA;;AACA;AAAA;AAAA;AACA;;;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAMA;AATA;AAWA;AACA;AACA;AACA;AACA;AAfA;AAkBA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAHA;AAUA;AACA;AACA;AACA;AACA;AACA;AAfA;AAkBA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AAXA;AAcA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAHA;AAUA;AACA;AACA;AACA;AACA;AACA;AAfA;AAmBA;AADA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAMA;AACA;AAbA;AAwBA;;;;AAhIA;;AAmIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtJA;AACA;AACA;AACA;AACA;;AASA;;;;;;;;;;;;;AACA;AACA;;AACA;AACA;AAEA;AADA;AAIA;AACA;AAAA;AAAA;AAEA;;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAGA;;;;AArBA;;AAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AAEA;AACA;AACA;AAUA;;AAEA;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AAEA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;;AAEA;AAGA;AAAA;AAKA;;AAEA;AACA;AACA;AACA;;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AAHA;AAUA;AAAA;AAAA;AACA;AACA;AACA;AAJA;AAcA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AAEA;;AAOA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAMA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AACA;AAAA;AAAA;AAAA;AAHA;AAKA;AAAA;AAYA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMA;;;;;;;;;;;;;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AADA;AAFA;AAMA;AAAA;AACA;AAAA;AAEA;AAAA;AAIA;;;;AAjBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;;AASA;;;;;AACA;AAAA;;AAAA;AAEA;;;;AAEA;AAAA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAGA;AACA;AAAA;AAAA;AADA;AAMA;AACA;;AACA;AAAA;AAAA;AACA;;;;AAvCA;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAJA;AASA;;AAEA;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;;AAEA;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AAMA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAFA;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAOA;AAAA;AAGA;AACA;AAAA;AAAA;AAFA;AAKA;AACA;AACA;AAHA;AAUA;;AAEA;AACA;AAGA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AADA;AAeA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AAUA;;AACA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAFA;AAWA;AACA;AACA;AACA;AAJA;AAQA;AACA;AAFA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AASA;;AAEA;;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAGA;AAAA;AAAA;AACA;AAFA;AAKA;AACA;AAAA;AAAA;AAIA;AAIA;;;;;;;;;;;;;;;;;;;;ACrGA;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AAEA;AAAA;AAKA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;;AAOA;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAKA;AACA;AAFA;AAIA;AAAA;AAAA;AACA;AAAA;AAKA;AAAA;AAAA;AAKA;;;;AArCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;;AAYA;;;;;AAGA;AAAA;;AAAA;;AACA;AAEA;AACA;AADA;AAHA;AAMA;;;;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AADA;AAGA;AACA;;;AAEA;AAAA;;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AANA;AAQA;AAAA;AAEA;AACA;AAFA;AAIA;AAAA;AAGA;AACA;AAFA;AAIA;AAAA;AAKA;;;;AAzDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;;AAkBA;;;;;AAGA;AAAA;;AAAA;;AACA;AAEA;AACA;AADA;AAHA;AAMA;;;;AAEA;AACA;AAEA;AAKA;;;AAEA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AADA;AAGA;AACA;;;AAEA;AAAA;;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AAGA;AACA;AANA;AAQA;AAAA;AAEA;AACA;AAFA;AAIA;AAAA;AAGA;AACA;AAFA;AAIA;AAAA;AAKA;;;;AA/DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMA;;;;;;;;;;;;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;;AACA;AAKA;AAEA;AACA;AAAA;AAAA;AAFA;AAKA;AACA;AACA;AADA;AAFA;AAQA;AADA;AAMA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAEA;AAAA;AAKA;;;;AA7CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAcA;;;;AAlBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AAEA;AACA;AACA;AACA;AACA;;AAQA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AALA;AAWA;AAEA;;AAEA;AAAA;;AACA;AAMA;;AAEA;AAEA;AACA;AACA;AAHA;AAQA;AAGA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;;AAOA;AAAA;AACA;AACA;AACA;;AA8CA;;;;;AAiBA;AAgCA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnCA;AAoCA;;;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAGA;AAAA;;AACA;AAMA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;;;AAEA;AACA;AAKA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;;;AAEA;AACA;;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;;;AAEA;AAOA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AADA;;AAAA;;AAEA;;AAIA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAEA;;AAEA;AACA;;AACA;;AACA;AAIA;;AACA;AACA;;AACA;AAIA;AACA;AACA;AACA;;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAIA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;;;AAEA;AACA;;AACA;AAIA;AACA;;AAEA;AACA;;;AAEA;AACA;AACA;AAEA;AAEA;AACA;;;AAEA;AACA;AACA;AACA;;AAEA;AAQA;AACA;;AAEA;AAQA;AACA;;AAEA;AACA;;;AAEA;AACA;;AACA;AACA;AAGA;;AACA;AACA;;;AAEA;AAAA;;AACA;;AACA;AAKA;AACA;AACA;;AAEA;AAQA;AACA;AACA;AAGA;AAEA;AACA;;;AACA;AAGA;AACA;AACA;AAIA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAIA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAKA;AACA;;AACA;AAKA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AAKA;AACA;;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAAA;;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAEA;AAAA;AAAA;AAAA;;AACA;;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAKA;AACA;AACA;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAGA;AACA;;AAEA;AAIA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AAIA;;AACA;AACA;AAEA;;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;;AAEA;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AAMA;;AACA;AACA;AACA;AAAA;;AAGA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AAGA;;;AAEA;AAMA;;AACA;AACA;AAAA;AAIA;;AACA;;AAGA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;;;AAEA;AACA;AACA;;AACA;AAAA;;AAAA;;AACA;AAIA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;;AACA;AACA;;;AAEA;AACA;AAAA;AAAA;;AAIA;AACA;AAIA;;;AAEA;AAAA;;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAHA;AAMA;AACA;AAAA;AAAA;AACA;AAHA;AAKA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AADA;AAfA;AADA;AAwBA;;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAEA;AAKA;;AAEA;AACA;AAGA;;AAEA;AACA;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;AAGA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;;;AAEA;AAUA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AACA;AAKA;AACA;;AAEA;AACA;;AACA;AACA;AAKA;;AAEA;;AAEA;AACA;AACA;;AACA;AAEA;AACA;AAHA;;AAKA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAOA;AAAA;AAGA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AAEA;AAMA;AACA;AA1BA;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5BA;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAiBA;;;;AAtnCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AARA;AAUA;AACA;AAFA;AATA;AAeA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAAA;AAUA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AADA;AAHA;AARA;AAAA;;AAkBA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAFA;AAWA;AACA;AACA;AACA;AAHA;AADA;AAOA;AAAA;AAAA;AAQA;AACA;AAAA;AAAA;AAFA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AAHA;AAFA;AAaA;AAIA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AA+BA;AACA;AACA;AACA;;AAGA;;;;;AAMA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AAVA;AAWA;;;;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AAEA;AAEA;AAIA;AAKA;AAMA;;;AAEA;AACA;AACA;;AACA;AAIA;AACA;AACA;;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAEA;AAAA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAFA;AAIA;AACA;;AAEA;AACA;AACA;;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAIA;AACA;AACA;;AACA;AAKA;AACA;;AAEA;AAUA;;AAEA;AACA;AACA;AAEA;;AACA;AASA;AACA;AACA;;AAEA;AACA;AAKA;AACA;AACA;;AAEA;AACA;AAKA;AACA;AACA;;AACA;AAIA;AACA;AACA;AAGA;;;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAOA;AACA;;AAEA;AAIA;AAIA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAGA;AACA;AACA;AACA;AAEA;;AACA;AAOA;AACA;;AAEA;AACA;;AACA;;AACA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAWA;AACA;;AACA;AACA;AACA;;AACA;AAEA;AASA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AAEA;AAUA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AADA;AAGA;AACA;;;AACA;AACA;;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;;AAEA;;;AACA;AACA;AACA;;;AAEA;AAAA;;AACA;;AACA;AACA;AACA;AAEA;;;AACA;;AAGA;AACA;AACA;;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAVA;AAcA;;;;AAzdA;;AA4dA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACviBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAmDA;;AAEA;;;;;AAIA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;AAJA;AAKA;;;;AAEA;AACA;AAEA;;;AACA;AACA;AAIA;;;AACA;AACA;AACA;;;AAEA;AACA;AACA;AADA;;AAGA;AACA;AACA;;AACA;AACA;AACA;;AACA;AAKA;AACA;AAAA;AAIA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAdA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/CA;AAkDA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAKA;AACA;AAbA;AAiBA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAJA;AADA;AASA;AADA;AAUA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AAJA;AADA;AAcA;;;;AAvKA;;AA0KA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrPA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAOA;AACA;AAKA;AAmCA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;;AAEA;;AACA;;AACA;;AACA;;AACA;AAIA;AAKA;AACA;;AAEA;AACA;;AAVA;AAaA;;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAGA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;;;AACA;AACA;AACA;AACA;AACA;AAjEA;;AAYA;AAAA;;AAAA;AAsDA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AAmBA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AAKA;AACA;;AAIA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAnBA;;AAAA;;AAqBA;AAAA;;AAMA;AACA;AAIA;AAGA;;;AACA;AACA;AACA;AACA;AAIA;AAIA;;AACA;AACA;AAEA;AACA;;AACA;AACA;AAIA;;AACA;AACA;AAMA;;AAEA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAMA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxCA;AA0CA;;AAEA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;;AACA;AAGA;AAAA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;;AACA;AAIA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAGA;AACA;AACA;AACA;;AACA;AACA;;AALA;AAAA;;AAAA;AAMA;AAAA;;AACA;AACA;AACA;;AAEA;AACA;AAIA;AACA;;AACA;AACA;AACA;AACA;AArBA;AAAA;AAAA;AAAA;AAAA;;AAsBA;AAEA;AAAA;;AAGA;AAGA;AAAA;;AAGA;;AAMA;AACA;AAIA;AACA;;AACA;AAIA;;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;;AACA;AACA;AAIA;;AACA;AAUA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AAIA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;;AAIA;AACA;AAKA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA5JA;AA8JA;;AAEA;AAIA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AAGA;AACA;;;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AAIA;AACA;AAQA;AACA;;AAEA;AAMA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAAA;AAAA;;AAFA;;AAAA;;AAKA;AAAA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7tBA;AAOA;AACA;AAEA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;;AAwBA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAKA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAJA;AAJA;AAWA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAHA;AADA;AASA;AACA;AACA;AACA;AAJA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AADA;AAdA;AAkBA;AApBA;AAsBA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AAFA;AAOA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AADA;AAMA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAbA;AAiBA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AADA;AAkBA;AAGA;AACA;AACA;AANA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAJA;AAUA;AAAA;AASA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AChPA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAIA;AACA;AACA;AAIA;AACA;AAIA;AACA;;AAEA;AACA;AACA;;AAIA;AACA;AACA;AACA;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;;AAEA;AAAA;;AACA;AACA;AAGA;;AAEA;AACA;AAEA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAnBA;AAqBA;AAGA;AAGA;;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnIA;AAOA;AAMA;AACA;AACA;AAQA;;AAEA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AAEA;AACA;AAFA;AAMA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAXA;AAaA;AAdA;AAgBA;AAAA;AAOA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAJA;AAWA;AAAA;AAKA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAFA;AASA;AACA;AACA;AACA;AACA;AAAA;AAAA;AALA;AAQA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AADA;AAgBA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;;AASA;;;;;AACA;AAAA;;AAAA;AAEA;;;;AAEA;AAAA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAGA;AACA;AAAA;AAAA;AADA;AAMA;AACA;;AACA;AAAA;AAAA;AACA;;;;AAvCA;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAIA;;AAEA;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;;AAEA;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AAMA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAFA;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAOA;AAAA;AAGA;AACA;AAAA;AAAA;AAFA;AAKA;AACA;AACA;AAHA;AAUA;;AAEA;AACA;AAGA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AADA;AAeA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AAEA;AACA;AASA;;AAEA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAFA;AAWA;AACA;AACA;AACA;AAJA;AAQA;AACA;AAFA;AAIA;AAAA;AAAA;AAAA;AASA;;AAEA;;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAGA;AAAA;AAAA;AACA;AAFA;AAKA;AACA;AAAA;AAAA;AAIA;AAIA;;;;;;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AAAA;AACA;AAAA;AAKA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;ACjBA;AAEA;AACA;AACA;AACA;;AASA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AALA;AAUA;;AACA;AAEA;;AAEA;AACA;AAMA;;AAEA;AAEA;AACA;AACA;AAHA;AAQA;AAGA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAiCA;;;;;AAiBA;AAeA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAvBA;AAwBA;;;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;;AACA;AACA;AAGA;;AACA;AACA;;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;;;AACA;AACA;AACA;;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;;;AAEA;AAGA;AAAA;;AACA;AAMA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;AAEA;AAAA;;AACA;;AACA;AAKA;AACA;AACA;;AAEA;AAQA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAIA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAKA;AACA;;AACA;AAKA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AAKA;AACA;;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAEA;AAEA;AACA;;;AAEA;AACA;AACA;AACA;;AAEA;AAQA;AACA;;AAEA;AAQA;AACA;;AAEA;AACA;;;AACA;AACA;;AACA;AAIA;AACA;;AAEA;AACA;;;AAEA;AACA;AACA;;;AAEA;AAAA;;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMA;AACA;AACA;AAEA;AACA;AACA;;;AAIA;AAMA;;AAEA;AACA;AACA;AAAA;AAEA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;;AACA;AAMA;;AACA;AACA;AAAA;AAIA;;AACA;;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;AACA;AAAA;;AAAA;;AACA;AAIA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;;AACA;AACA;;;AACA;AAOA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AADA;;AAAA;;AAEA;;AAIA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAEA;AACA;;AACA;;AACA;AAIA;;AACA;AACA;;AACA;AAIA;AACA;AACA;AACA;;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAIA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;;;AAEA;AAAA;;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AADA;AAJA;AASA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAHA;AAKA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AADA;AAfA;AADA;AAwBA;;;AACA;AAKA;;AAEA;AACA;AAGA;;AAEA;AACA;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;AAGA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;;;AAEA;AAUA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;;AACA;AACA;AAKA;;AAEA;AAEA;AAFA;;AAIA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAOA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAPA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AAuBA;;;;AAv4BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AARA;AAUA;AACA;AAFA;AATA;AAeA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAAA;AAUA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AADA;AAHA;AARA;AAAA;;AAkBA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AADA;AAUA;AACA;AACA;AACA;AAHA;AADA;AAOA;AAAA;AAAA;AAQA;AACA;AAAA;AAAA;AAFA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AAHA;AAFA;AAaA;AAIA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AA8BA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AAAA;;AAAA;;AACA;AAEA;AACA;AADA;AAGA;AACA;AACA;AARA;AASA;;;;AAEA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAEA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;;AAEA;;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAFA;AAIA;AACA;;AAEA;AACA;AACA;;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AACA;AACA;AACA;;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAIA;AAIA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AACA;AAOA;AACA;;AAEA;AACA;;AACA;;AACA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAUA;;AAEA;AACA;AAEA;AACA;AADA;AAGA;AACA;;;AAEA;AACA;;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;;AACA;AACA;;;AACA;AACA;AACA;;;AACA;AAAA;;AACA;;AACA;AACA;AACA;AAGA;;;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAFA;AAJA;AAWA;;;;AAhTA;;AAkTA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AADA;;AAGA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAJA;AAKA;AALA;AAOA;AACA;AACA;AAEA;AACA;AAZA;AAaA;AACA;AAEA;AAhBA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjCA;AAoCA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAHA;AAYA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAJA;AADA;AASA;AADA;AASA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AAJA;AADA;AAcA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAgCA;;AAEA;AACA;AACA;;AAEA;;AACA;;AACA;;AACA;;AACA;AAIA;AAKA;AACA;;AAEA;AACA;;AAVA;AAaA;;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAGA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;;;AACA;AACA;AACA;AACA;AACA;AAjEA;;AAYA;AAAA;;AAAA;AAsDA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;;AAIA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AAIA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AAuBA;;AAEA;AACA;AAAA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;;AACA;AAGA;AAAA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;;AACA;AAIA;AACA;AACA;AACA;;AAGA;;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;;AALA;AAAA;;AAAA;AAMA;AAAA;;AACA;AACA;AACA;;AAEA;AACA;AAIA;AACA;;AACA;AACA;AACA;AACA;AArBA;AAAA;AAAA;AAAA;AAAA;;AAsBA;AAEA;AAAA;;AAGA;AAGA;AAAA;;AAGA;;AAMA;AACA;AAIA;AACA;;AACA;AAIA;;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;;AACA;AACA;AAIA;;AACA;AAUA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAlJA;AAoJA;;AAEA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAYA;AAEA;;AAQA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;;AACA;AACA;AACA;;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAGA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AALA;AAJA;AAYA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAHA;AADA;AASA;AACA;AACA;AACA;AAJA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AADA;AAdA;AAkBA;AArBA;AAuBA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AAFA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AADA;AAMA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAbA;AAgBA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AADA;AAmBA;AAGA;AACA;AACA;AANA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAJA;AAUA;AAAA;AASA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/NA;AACA;AACA;AACA;AACA;AAEA;;AAMA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;;AAEA;AACA;AACA;AAGA;;AAEA;AACA;AAEA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApBA;AAsBA;;AAEA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/FA;AACA;AAMA;AACA;AACA;AAEA;AAQA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAFA;AAMA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAXA;AAaA;AAdA;AAgBA;AAAA;AAOA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAXA;AAaA;AAAA;AAIA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAFA;AASA;AACA;AACA;AACA;AACA;AAAA;AAAA;AALA;AAQA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AADA;AAgBA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;AC9JA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDA;AACA;AACA;;AASA;;;;;AACA;AAAA;;AAAA;AAEA;;;;AAEA;AAAA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAGA;AACA;AAAA;AAAA;AADA;AAMA;AACA;;AACA;AAAA;AAAA;AACA;;;;AAvCA;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AAMA;AACA;;AACA;AACA;AAEA;AAAA;AAGA;AACA;AAEA;AAAA;AAGA;;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBA;AACA;;AAOA;;;;;AACA;AAAA;;AAAA;AAEA;;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;AATA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AAIA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuBA;;AAEA;;;;;AAUA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAPA;AAQA;;;;AAEA;AACA;AACA;AACA;;;AACA;;;AAEA;AAUA;;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAJA;;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAKA;AACA;;AAEA;AAEA;;AACA;AACA;AACA;AAIA;;AAGA;AAEA;AACA;;AACA;AAEA;AACA;AACA;AAMA;AACA;AAVA;AAaA;AACA;AACA;AAHA;AAOA;AACA;;AAEA;AACA;AACA;;AACA;AAGA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AAHA;AAOA;AACA;AACA;AACA;AAJA;AAUA;AAAA;AAMA;AACA;AAFA;AAIA;AAAA;AAOA;;;AACA;AAAA;AACA;AACA;;;AACA;AAAA;;AACA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAXA;AADA;AAiBA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAIA;;;;AAxMA;;AA2MA;;;;;;;;;;;;;;;;;;;;;ACnPA;AACA;AACA;;AAOA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AAFA;AAOA;;AAEA;;;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;;AAEA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AAEA;AACA;AACA;;AAYA;AACA;;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAFA;AAIA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AADA;AAGA;AARA;AAWA;AACA;AAEA;AACA;AALA;AAMA;AACA;AAPA;AAaA;;AAEA;;;;;;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AAKA;;;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AAEA;AACA;AACA;AAFA;;AAcA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAJA;AASA;;AAEA;;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;;AACA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAQA;AACA;AACA;AAEA;AAAA;AALA;AAsBA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;;AAkBA;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAEA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AAJA;AAOA;AAAA;AAGA;AAAA;AAGA;AAAA;AAKA;;;;AA3CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;;AAEA;AAKA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAOA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAXA;AAcA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAQA;;AAEA;;;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;;AACA;AACA;AACA;AAAA;AACA;AAAA;AAGA;;AAEA;;;;;;;;;;;;;;;;;ACXA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AAAA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;;AAEA;AACA;AACA;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AAFA;AAAA;AAAA;;AAKA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAvBA;AAyBA;;AAEA;AAKA;;;;;;;;;;;;;;;;;;;;;;;ACzEA;AACA;;AAIA;AAOA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAEA;AACA;AACA;AACA;;AACA;AAIA;AACA;AACA;AACA;AACA;AAAA;;AAEA;AACA;;AACA;AACA;;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAGA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AACA;AACA;;AACA;AACA;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACvGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACdA;AAEA;AACA;AACA;AAGA;AACA;AAGA;AAEA;AAIA;;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAKA;;AACA;AACA;AACA;AAEA;;;AACA;AACA;AAKA;AAEA;;AACA;AAKA;AAEA;AACA;AACA;AAEA;AAKA;;AACA;AACA;AACA;;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AAKA;;AACA;AACA;AACA;;AACA;AACA;AAKA;AACA;;AACA;AAKA;AACA;AACA;AACA;AAEA;AAOA;AAQA;AACA;AAIA;;AAEA;AAEA;AAKA;AAMA;AAEA;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAMA;;AAEA;AACA;AACA;;AACA;AAMA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AAKA;AAKA;AACA;;AAEA;AACA;;AACA;AACA;AAIA;;AAEA;AAKA;AAGA;AAKA;;AAIA;AAIA;AACA;AACA;AAFA;AAIA;;AAEA;AACA;;AAEA;AAIA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AAGA;AAAA;AAKA;AACA;;AAEA;AAKA;;AAEA;AACA;AACA;;AACA;;AAIA;AACA;AACA;;AAEA;;AACA;AACA;AACA;;AAKA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AAIA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;;AAGA;;AACA;AACA;AACA;AAGA;;AAEA;AACA;;;;;;;;;;;;;;;AC1UA;;;;;;;;;;;;;;;ACAA;;;;;;;;;;ACAA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;;;;;;;;;;ACAA;AACA;;;;;;;;;;ACDA;;;;;;;;;;ACAA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA;;;;;;;;;;ACDA;AACA","sources":["webpack://parkhang/./app/images/PencilAltIcon.svg","webpack://parkhang/./app/images/check_circle.svg","webpack://parkhang/./app/images/note.svg","webpack://parkhang/./app/images/options.svg","webpack://parkhang/./app/images/page_break_icon.svg","webpack://parkhang/./app/images/question_answer.svg","webpack://parkhang/./app/images/search.svg","webpack://parkhang/./app/images/wrench.svg","webpack://parkhang/./app/components/Editors/Editor.js","webpack://parkhang/./app/components/Editors/EditorContainer.js","webpack://parkhang/./app/components/Editors/TextSheet.js","webpack://parkhang/./app/components/ErrorBoundary/ErrorBoundary.js","webpack://parkhang/./app/components/MediaComponent/Audio.js","webpack://parkhang/./app/components/MediaComponent/DraggableMedia.js","webpack://parkhang/./app/components/MediaComponent/Image.js","webpack://parkhang/./app/components/MediaComponent/MediaContainer.js","webpack://parkhang/./app/components/MediaComponent/MediaOptions.js","webpack://parkhang/./app/components/MediaComponent/Video.js","webpack://parkhang/./app/components/Sidebar/Sidebar.js","webpack://parkhang/./app/components/Sidebar/SidebarOptions/About.js","webpack://parkhang/./app/components/Sidebar/SidebarOptions/Commentary.js","webpack://parkhang/./app/components/Sidebar/SidebarOptions/Dictionary.js","webpack://parkhang/./app/components/Sidebar/SidebarOptions/Resources.js","webpack://parkhang/./app/components/Sidebar/SidebarOptions/index.js","webpack://parkhang/./app/components/TextDetail/AddButton.js","webpack://parkhang/./app/components/TextDetail/AnnotationControls.js","webpack://parkhang/./app/components/TextDetail/AnnotationControlsContainer.js","webpack://parkhang/./app/components/TextDetail/AnnotationControlsHeader.js","webpack://parkhang/./app/components/TextDetail/AnnotationControlsHeading.js","webpack://parkhang/./app/components/TextDetail/AnnotationDetail.js","webpack://parkhang/./app/components/TextDetail/AnnotationDetailEdit.js","webpack://parkhang/./app/components/TextDetail/AnswerView.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/HighlightedString.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/Refresh.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/Search.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/SearchList.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/Settings.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/TableOfContent.js","webpack://parkhang/./app/components/TextDetail/Note.js","webpack://parkhang/./app/components/TextDetail/NoteEditor.js","webpack://parkhang/./app/components/TextDetail/QuestionEditor.js","webpack://parkhang/./app/components/TextDetail/QuestionView.js","webpack://parkhang/./app/components/TextDetail/QuestionsLoading.js","webpack://parkhang/./app/components/TextDetail/SelectVersion.js","webpack://parkhang/./app/components/TextDetail/SplitText.js","webpack://parkhang/./app/components/TextDetail/TableOfContent/TableOfContent.js","webpack://parkhang/./app/components/TextDetail/Text.js","webpack://parkhang/./app/components/TextDetail/TextDetail.js","webpack://parkhang/./app/components/TextDetail/TextDetailContainer.js","webpack://parkhang/./app/components/TextDetail/TextDetailHeading.js","webpack://parkhang/./app/components/TextDetail/TextDetailHeadingContainer.js","webpack://parkhang/./app/components/TextDetail/TextList.js","webpack://parkhang/./app/components/TextDetail/TextListContainer.js","webpack://parkhang/./app/components/TextDetail2/HeaderMenu/HighlightedString.js","webpack://parkhang/./app/components/TextDetail2/HeaderMenu/Refresh.js","webpack://parkhang/./app/components/TextDetail2/HeaderMenu/Search.js","webpack://parkhang/./app/components/TextDetail2/HeaderMenu/SearchList.js","webpack://parkhang/./app/components/TextDetail2/HeaderMenu/Settings.js","webpack://parkhang/./app/components/TextDetail2/HeaderMenu/TableOfContent.js","webpack://parkhang/./app/components/TextDetail2/SelectVersion.js","webpack://parkhang/./app/components/TextDetail2/SplitText.js","webpack://parkhang/./app/components/TextDetail2/TableOfContent/TableOfContent.js","webpack://parkhang/./app/components/TextDetail2/Text.js","webpack://parkhang/./app/components/TextDetail2/TextDetail.js","webpack://parkhang/./app/components/TextDetail2/TextDetailContainer.js","webpack://parkhang/./app/components/TextDetail2/TextDetailHeading.js","webpack://parkhang/./app/components/TextDetail2/TextDetailHeadingContainer.js","webpack://parkhang/./app/components/TextDetail2/TextList.js","webpack://parkhang/./app/components/TextDetail2/TextListContainer.js","webpack://parkhang/./app/components/TextList/HighlightedString.js","webpack://parkhang/./app/components/TextList/LoadMore.js","webpack://parkhang/./app/components/TextList/ResultCount.js","webpack://parkhang/./app/components/TextList/TextList.js","webpack://parkhang/./app/components/TextList/TextListTab.js","webpack://parkhang/./app/components/TextList/TextListTabContainer.js","webpack://parkhang/./app/components/TextsSearch/TextsSearch.js","webpack://parkhang/./app/components/TextsSearch/TextsSearchContainer.js","webpack://parkhang/./app/components/UI/Accessory.js","webpack://parkhang/./app/components/UI/ApplyTooltip.js","webpack://parkhang/./app/components/UI/Button.js","webpack://parkhang/./app/components/UI/Slider.js","webpack://parkhang/./app/components/utility/Placeholder.js","webpack://parkhang/./app/components/utility/discourseForum.js","webpack://parkhang/./app/components/utility/useLocalStorage.js","webpack://parkhang/./app/containers/TextListContainer.js","webpack://parkhang/./app/lib/SplitText.js","webpack://parkhang/./app/lib/shallowEqual.js","webpack://parkhang/./app/lib/text_splitters/positionSplitter.js","webpack://parkhang/./app/state_helpers/TextStore2.js","webpack://parkhang/./app/images/lopenling_logo.png","webpack://parkhang/./app/images/lopenling_logo_173x.png","webpack://parkhang/./app/components/Editors/EditorContainer.css","webpack://parkhang/./app/components/Editors/resizerStyle.css","webpack://parkhang/./app/components/Header/Header.css","webpack://parkhang/./app/components/MediaComponent/Image.css","webpack://parkhang/./app/components/MediaComponent/MediaOptions.css","webpack://parkhang/./app/components/Sidebar/Sidebar.css","webpack://parkhang/./app/components/Sidebar/SidebarOptions/About.css","webpack://parkhang/./app/components/Sidebar/SidebarOptions/ResourceOption.css","webpack://parkhang/./app/components/Sidebar/SidebarOptions/Resources.css","webpack://parkhang/./app/components/TextDetail/AddButton.css","webpack://parkhang/./app/components/TextDetail/AnnotationControls.css","webpack://parkhang/./app/components/TextDetail/AnnotationControlsHeader.css","webpack://parkhang/./app/components/TextDetail/AnnotationControlsHeading.css","webpack://parkhang/./app/components/TextDetail/AnnotationDetail.css","webpack://parkhang/./app/components/TextDetail/AnswerView.css","webpack://parkhang/./app/components/TextDetail/Button.css","webpack://parkhang/./app/components/TextDetail/HeaderMenu/SearchStyle.css","webpack://parkhang/./app/components/TextDetail/Note.css","webpack://parkhang/./app/components/TextDetail/NoteEditor.css","webpack://parkhang/./app/components/TextDetail/QuestionEditor.css","webpack://parkhang/./app/components/TextDetail/QuestionView.css","webpack://parkhang/./app/components/TextDetail/QuestionsLoading.css","webpack://parkhang/./app/components/TextDetail/SelectVersion.css","webpack://parkhang/./app/components/TextDetail/SplitText.css","webpack://parkhang/./app/components/TextDetail/TableOfContent/TableOfContent.css","webpack://parkhang/./app/components/TextDetail/Text.css","webpack://parkhang/./app/components/TextDetail/TextDetail.css","webpack://parkhang/./app/components/TextDetail/TextDetailHeading.css","webpack://parkhang/./app/components/TextDetail/TextList.css","webpack://parkhang/./app/components/TextDetail2/HeaderMenu/SearchStyle.css","webpack://parkhang/./app/components/TextDetail2/SelectVersion.css","webpack://parkhang/./app/components/TextDetail2/TextList.css","webpack://parkhang/./app/components/TextDetail2/textDetailHeading.css","webpack://parkhang/./app/components/TextList/LoadMore.css","webpack://parkhang/./app/components/TextList/TextList.css","webpack://parkhang/./app/components/TextList/TextListTab.css","webpack://parkhang/./app/components/TextsSearch/TextsSearch.css","webpack://parkhang/./app/components/UI/Accessory.css","webpack://parkhang/./app/components/UI/Button.css","webpack://parkhang/./app/components/UI/Slider.css","webpack://parkhang/./app/components/utility/Placeholder.css","webpack://parkhang/./app/css/colour.css"],"sourcesContent":["var _path;\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport * as React from \"react\";\n\nvar SvgPencilAltIcon = function SvgPencilAltIcon(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 512 512\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props), _path || (_path = /*#__PURE__*/React.createElement(\"path\", {\n    d: \"m497.9 142.1-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3 0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9 0l60.1 60.1c18.8 18.7 18.8 49.1 0 67.9zM284.2 99.8 21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3 0-17l-111-111c-4.8-4.7-12.4-4.7-17.1 0zM124.1 339.9c-5.5-5.5-5.5-14.3 0-19.8l154-154c5.5-5.5 14.3-5.5 19.8 0s5.5 14.3 0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8 0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z\"\n  })));\n};\n\nexport default SvgPencilAltIcon;","var _path, _path2;\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport * as React from \"react\";\n\nvar SvgCheckCircle = function SvgCheckCircle(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 24 24\"\n  }, props), _path || (_path = /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M0 0h24v24H0z\",\n    fill: \"none\"\n  })), _path2 || (_path2 = /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"\n  })));\n};\n\nexport default SvgCheckCircle;","var _path, _path2;\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport * as React from \"react\";\n\nvar SvgNote = function SvgNote(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 24 24\"\n  }, props), _path || (_path = /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M3 18h12v-2H3v2zM3 6v2h18V6H3zm0 7h18v-2H3v2z\"\n  })), _path2 || (_path2 = /*#__PURE__*/React.createElement(\"path\", {\n    fill: \"none\",\n    d: \"M0 0h24v24H0V0z\"\n  })));\n};\n\nexport default SvgNote;","function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport * as React from \"react\";\n\nvar SvgOptions = function SvgOptions(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 52.93 52.93\",\n    style: {\n      enableBackground: \"new 0 0 52.93 52.93\"\n    },\n    xmlSpace: \"preserve\"\n  }, props), /*#__PURE__*/React.createElement(\"circle\", {\n    style: {\n      fill: \"#010002\"\n    },\n    cx: 26.465,\n    cy: 25.59,\n    r: 4.462\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#010002\"\n    },\n    d: \"M52.791 32.256c-.187-1.034-1.345-2.119-2.327-2.492l-2.645-1.004c-.982-.373-1.699-1.237-1.651-1.935.029-.417.046-.838.046-1.263 0-.284-.008-.566-.021-.846-.023-.467.719-1.193 1.677-1.624l2.39-1.074c.958-.432 2.121-1.565 2.194-2.613.064-.929-.047-2.196-.648-3.765a8.336 8.336 0 0 0-2.779-3.718c-.839-.633-2.423-.595-3.381-.163l-2.08.936c-.958.431-2.274.119-3.025-.616a17.282 17.282 0 0 0-.54-.509c-.778-.705-1.17-2-.796-2.983l.819-2.162c.373-.982.368-2.594-.322-3.385-.635-.728-1.643-1.579-3.215-2.281-1.764-.788-3.346-.811-4.483-.639-1.039.158-2.121 1.331-2.494 2.312l-.946 2.491c-.373.982-.798 1.775-.949 1.771a6.289 6.289 0 0 0-.274-.005c-.622 0-1.238.03-1.846.09-1.016.1-2.176-.507-2.607-1.465l-1.124-2.5c-.431-.959-1.538-2.21-2.589-2.227-.916-.016-2.207.209-3.936 1.028-1.874.889-2.971 1.742-3.611 2.437-.712.771-.554 2.416-.122 3.374l1.481 3.296c.431.958.256 2.266-.324 2.979-.579.714-1.786 1.033-2.768.661l-3.598-1.365c-.982-.373-2.65-.476-3.406.256-.658.637-1.412 1.709-2.056 3.51-.696 1.954-.867 3.332-.83 4.276.042 1.05 1.317 2.101 2.3 2.474l4.392 1.667c.982.373 1.782 1.244 1.839 1.941.055.699-.635 1.61-1.593 2.042l-4.382 1.97c-.958.431-2.211 1.539-2.227 2.589-.015.916.21 2.208 1.028 3.935.89 1.874 1.742 2.971 2.437 3.611.773.713 2.417.554 3.375.123l4.698-2.112c.958-.432 2.076-.412 2.525.013s.535 1.541.162 2.524L12.743 46.6c-.373.982-.476 2.65.256 3.404.638.659 1.709 1.414 3.51 2.057 1.954.697 3.333.868 4.277.831 1.05-.042 2.1-1.318 2.473-2.3l1.693-4.46c.373-.982 1.058-1.742 1.531-1.719a17.414 17.414 0 0 0 1.255.016c.219-.007.747.762 1.178 1.721l1.963 4.364c.431.958 1.605 1.986 2.653 2.038 1.121.056 2.669-.062 4.43-.734 1.685-.645 2.659-1.604 3.219-2.442.584-.873.388-2.517-.044-3.475l-1.606-3.573c-.431-.958-.169-2.191.527-2.824.693-.633 2-.9 2.981-.526l3.432 1.303c.982.373 2.64.489 3.478-.145.738-.56 1.591-1.49 2.281-3.034.827-1.854.785-3.605.561-4.846zM26.465 39.79c-7.844 0-14.201-6.357-14.201-14.2s6.357-14.2 14.201-14.2c7.842 0 14.2 6.357 14.2 14.2.001 7.843-6.358 14.2-14.2 14.2z\"\n  }));\n};\n\nexport default SvgOptions;","var _style, _path, _path2, _path3;\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport * as React from \"react\";\n\nvar SvgPageBreakIcon = function SvgPageBreakIcon(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 30 40\",\n    style: {\n      fill: \"currentColor\"\n    }\n  }, props), _style || (_style = /*#__PURE__*/React.createElement(\"style\", null, \".page_break_icon_svg__line{stroke:currentColor;stroke-width:3px}\")), _path || (_path = /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M3 0h24v15H3z\"\n  })), _path2 || (_path2 = /*#__PURE__*/React.createElement(\"path\", {\n    className: \"page_break_icon_svg__line\",\n    d: \"M0 20h8M11 20h8M22 20h8\"\n  })), _path3 || (_path3 = /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M3 25h24v15H3z\"\n  })));\n};\n\nexport default SvgPageBreakIcon;","var _path, _path2;\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport * as React from \"react\";\n\nvar SvgQuestionAnswer = function SvgQuestionAnswer(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 24 24\",\n    fill: \"currentColor\"\n  }, props), _path || (_path = /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M0 0h24v24H0z\",\n    fill: \"none\"\n  })), _path2 || (_path2 = /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z\"\n  })));\n};\n\nexport default SvgQuestionAnswer;","var _path;\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport * as React from \"react\";\n\nvar SvgSearch = function SvgSearch(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: 24,\n    height: 24\n  }, props), _path || (_path = /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M9 2C5.146 2 2 5.146 2 9s3.146 7 7 7a6.959 6.959 0 0 0 4.574-1.719l.426.426V16l6 6 2-2-6-6h-1.293l-.426-.426A6.959 6.959 0 0 0 16 9c0-3.854-3.146-7-7-7zm0 2c2.773 0 5 2.227 5 5s-2.227 5-5 5-5-2.227-5-5 2.227-5 5-5z\"\n  })));\n};\n\nexport default SvgSearch;","var _path;\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport * as React from \"react\";\n\nvar SvgWrench = function SvgWrench(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 512 512\"\n  }, props), _path || (_path = /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M507.73 109.1c-2.24-9.03-13.54-12.09-20.12-5.51l-74.36 74.36-67.88-11.31-11.31-67.88 74.36-74.36c6.62-6.62 3.43-17.9-5.66-20.16-47.38-11.74-99.55.91-136.58 37.93-39.64 39.64-50.55 97.1-34.05 147.2L18.74 402.76c-24.99 24.99-24.99 65.51 0 90.5 24.99 24.99 65.51 24.99 90.5 0l213.21-213.21c50.12 16.71 107.47 5.68 147.37-34.22 37.07-37.07 49.7-89.32 37.91-136.73zM64 472c-13.25 0-24-10.75-24-24 0-13.26 10.75-24 24-24s24 10.74 24 24c0 13.25-10.75 24-24 24z\"\n  })));\n};\n\nexport default SvgWrench;","import React, { useState, useEffect } from \"react\";\nimport TextsSearchContainer from \"components/TextsSearch/TextsSearchContainer\";\nimport TextListContainer from \"containers/TextListContainer\";\nimport TextListTabContainer from \"components/TextList/TextListTabContainer\";\nimport * as constants from \"app_constants\";\nimport lopenlingLogo from \"images/lopenling_logo.png\";\nimport headerStyles from \"components/Header/Header.css\";\nimport Sidebar from \"components/Sidebar\";\nimport SplitPane, { Pane } from \"react-split-pane\";\nimport styles from \"./EditorContainer.css\";\nimport classnames from \"classnames\";\nimport utilStyles from \"css/util.css\";\nimport TextSheet from \"./TextSheet\";\nimport {\n    SpeedDial,\n    SpeedDialAction,\n    SpeedDialIcon,\n    Snackbar,\n    Alert,\n    Collapse,\n} from \"@mui/material\";\n\nimport { Edit, Share, VerticalSplit, SyncAlt } from \"@mui/icons-material\";\nimport { Box } from \"@mui/system\";\nconst Editor = (props) => {\n    let textListClassnames = [styles.listContainer];\n    let bodyHeight;\n    let minSize = constants.MIN_TEXT_LIST_WIDTH;\n    let maxSize = constants.MAX_TEXT_LIST_WIDTH;\n\n    const [open, setOpen] = useState(false);\n\n    let defaultSize = constants.DEFAULT_TEXT_LIST_WIDTH;\n    let size = props.textListWidth;\n    if (props.textListIsVisible) {\n        textListClassnames.push(styles.showListContainer);\n    } else {\n        size = 0;\n        textListClassnames.push(styles.hideListContainer);\n    }\n\n    bodyHeight = \"calc(100vh - \" + headerStyles.headerHeight + \")\";\n\n    const image_location = lopenlingLogo;\n    const handleClose = (event, reason) => {\n        if (reason === \"clickaway\") {\n            return;\n        }\n        setOpen(false);\n    };\n    const handleShare = () => {\n        let textid = props.selectedText;\n        let textid2 = props.selectedText2;\n        let witnessid = props.selectedWitness;\n        let witnessid2 = props.selectedWitness2;\n        let url = \"\";\n        if (textid2 && witnessid2) {\n            url =\n                window.location.origin +\n                `/texts/${textid.id}/witnesses/${witnessid?.id}/texts2/${textid2.id}/witnesses2/${witnessid2.id}`;\n        } else {\n            url =\n                window.location.origin +\n                `/texts/${textid.id}/witnesses/${witnessid?.id}`;\n        }\n        navigator.clipboard\n            .writeText(url)\n            .then()\n            .catch((e) => console.log(e.message))\n            .finally(() => setOpen(true));\n    };\n    const actions = [\n        {\n            icon: (\n                <Edit htmlColor={props.isAnnotating ? \"#ff7961\" : undefined} />\n            ),\n            name: \"Annotate\",\n            condition: props.isAnnotating,\n            function: () => props.changeIsAnnotating(!props.isAnnotating),\n        },\n        {\n            icon: (\n                <SyncAlt\n                    htmlColor={props.isPanelLinked ? \"#ff7961\" : undefined}\n                />\n            ),\n            name: \"Link Panel\",\n            condition: props.isPanelLinked,\n            function: () => props.onChangePanelLink(!props.isPanelLinked),\n        },\n        {\n            icon: <Share />,\n            name: \"Share\",\n            function: handleShare,\n        },\n        {\n            icon: (\n                <VerticalSplit\n                    htmlColor={props.isSecondWindowOpen ? \"#ff7961\" : undefined}\n                />\n            ),\n            name: \"Split Window\",\n            condition: props.isSecondWindowOpen,\n            function: () =>\n                props.onChangeWindowOpen(!props.isSecondWindowOpen, 140),\n        },\n    ];\n    useEffect(() => {\n        let timer = setTimeout(() => {\n            window.dispatchEvent(new Event(\"resize\"));\n        }, 1000);\n        return () => clearTimeout(timer);\n    }, [props.textListIsVisible]);\n    return (\n        <div className={classnames(styles.interface, utilStyles.flex)}>\n            <SplitPane\n                size=\"fit-content\"\n                onDragFinished={(width: number) => {\n                    if (width > 0) window.dispatchEvent(new Event(\"resize\"));\n                }}\n                resizerStyle={{ display: \"none\" }}\n                style={{ height: \"auto\", position: \"static\" }}\n            >\n                <Collapse\n                    sx={{ height: \"100%\", position: \"absolute\", left: 0 }}\n                    orientation=\"horizontal\"\n                    in={props.textListIsVisible}\n                    mountOnEnter\n                    unmountOnExit\n                >\n                    <Sidebar />\n                </Collapse>\n                <Box sx={{ height: \"100vh\", width: \"100%\" }}>\n                    <TextSheet bodyHeight={bodyHeight} />\n                </Box>\n            </SplitPane>\n            <SpeedDial\n                ariaLabel=\"SpeedDial basic\"\n                sx={{ position: \"absolute\", bottom: 60, right: 16 }}\n                icon={<SpeedDialIcon />}\n            >\n                {actions.map((action) => (\n                    <SpeedDialAction\n                        key={action.name}\n                        icon={action.icon}\n                        tooltipTitle={action.name}\n                        onClick={action.function}\n                        open={action.condition}\n                    />\n                ))}\n            </SpeedDial>\n            <Snackbar open={open} autoHideDuration={6000} onClose={handleClose}>\n                <Alert\n                    onClose={handleClose}\n                    severity=\"success\"\n                    sx={{ width: \"100%\" }}\n                >\n                    The Url Copied to Clipboard !\n                </Alert>\n            </Snackbar>\n        </div>\n    );\n};\n\nexport default Editor;\n\n// return (\n//     <div className={classnames(styles.interface, utilStyles.flex)}>\n//         <SplitPane\n//             split=\"vertical\"\n//             minSize={minSize}\n//             maxSize={maxSize}\n//             defaultSize={defaultSize}\n//             size={size}\n//             paneStyle={{\n//                 display: \"flex\",\n//             }}\n//             style={{\n//                 height: bodyHeight,\n//             }}\n//             onDragFinished={(width: number) => {\n//                 if (width > 0) {\n//                     props.onChangedTextWidth(width);\n//                     if (!props.textListIsVisible) {\n//                         props.onChangedTextListVisible(true);\n//                     }\n//                 }\n//                 window.dispatchEvent(new Event(\"resize\"));\n//             }}\n//         >\n//             <div className={classnames(...textListClassnames)}>\n//                 <Resources />\n//             </div>\n\n//             <TextSheet bodyHeight={bodyHeight} />\n//         </SplitPane>\n//     </div>\n// );\n","import Editor from \"./Editor\";\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport * as reducers from \"reducers\";\nimport * as actions from \"actions\";\n\nconst mapStateToProps = (state) => {\n    const selectedText = reducers.getSelectedText(state);\n    const selectedText2 = reducers.getSelectedText2(state);\n\n    let selectedWitness;\n    let selectedWitness2;\n    let witnesses;\n    let witnesses2;\n    if (selectedText) {\n        witnesses = reducers.getTextWitnesses(state, selectedText.id);\n        const selectedWitnessId = reducers.getSelectedTextWitnessId(\n            state,\n            selectedText.id\n        );\n        if (selectedWitnessId) {\n            selectedWitness = reducers.getWitness(state, selectedWitnessId);\n        } else {\n            selectedWitness = reducers.getWorkingWitness(\n                state,\n                selectedText.id\n            );\n        }\n    }\n    if (selectedText2) {\n        witnesses2 = reducers.getTextWitnesses2(state, selectedText2.id);\n        const selectedWitnessId2 = reducers.getSelectedTextWitnessId2(\n            state,\n            selectedText2.id\n        );\n        if (selectedWitnessId2) {\n            selectedWitness2 = reducers.getWitness2(state, selectedWitnessId2);\n        } else {\n            selectedWitness2 = reducers.getWorkingWitness2(\n                state,\n                selectedText2.id\n            );\n        }\n    }\n\n    if (!state.user.userId === -1) {\n        user = state.user;\n    }\n    return {\n        selectedText,\n        selectedWitness,\n        selectedText2,\n        selectedWitness2,\n        title: reducers.getTranslation(state, \"header.title\"),\n        page: state.page,\n        isAnnotating: reducers.isAnnotating(state),\n        isSecondWindowOpen: reducers.isSecondWindowOpen(state),\n        theme: reducers.getTheme(state),\n        isPanelLinked: reducers.isPanelLinked(state),\n        textListIsVisible: reducers.getTextListVisible(state),\n    };\n};\n\nconst matchDispatchToProps = (dispatch) => {\n    return {\n        onChangedTextWidth: (width: number) => {\n            dispatch(actions.changedTextListWidth(width));\n        },\n        onChangedTextListVisible: (isVisible: boolean) => {\n            dispatch(actions.changedTextListVisible(isVisible));\n        },\n        changeIsAnnotating: (payload) => {\n            dispatch(actions.changeIsAnnotating(payload));\n            if (payload === false) {\n                const dismissTextAnnotation =\n                    actions.changedActiveTextAnnotation(null);\n                dispatch(dismissTextAnnotation);\n                dispatch(actions.changedActiveTextAnnotation(null));\n            }\n        },\n        onChangeWindowOpen: (data: boolean, textId) => {\n            dispatch(actions.toggleSecondWindow(data, textId));\n        },\n        onChangePanelLink: (data: boolean) => {\n            dispatch(actions.changePanelLink(data));\n        },\n    };\n};\n\nconst EditorContainer = connect(mapStateToProps, matchDispatchToProps)(Editor);\n\nexport default EditorContainer;\n","import React, { useEffect, useRef, useState } from \"react\";\nimport { connect } from \"react-redux\";\nimport * as reducers from \"reducers\";\nimport * as actions from \"actions\";\nimport MediaComponent from \"components/MediaComponent\";\nimport { batchActions } from \"redux-batched-actions\";\nimport { Box, Divider } from \"@mui/material\";\nimport Loader from \"react-loader\";\nimport ErrorBoundary from \"components/ErrorBoundary/ErrorBoundary\";\nimport SplitPane from \"react-split-pane\";\nimport styles from \"./resizerStyle.css\";\nimport classnames from \"classnames\";\nimport TextDetailContainer2 from \"components/TextDetail2/TextDetailContainer\";\nimport TextDetailContainer from \"components/TextDetail/TextDetailContainer\";\n\nfunction TextSheet(props) {\n    let [landScape, setLandScape] = useState(true);\n    let editorRef = useRef(null);\n    const handleResize = (e) => {\n        let width = editorRef.current.clientWidth;\n        let height = editorRef.current.clientHeight;\n        if (width > height) {\n            setLandScape(true);\n        } else {\n            setLandScape(false);\n        }\n    };\n    useEffect(() => {\n        handleResize();\n        window.addEventListener(\"resize\", handleResize);\n        return () => window.removeEventListener(\"resize\", handleResize);\n    }, []);\n\n    return (\n        <Box\n            ref={editorRef}\n            sx={{\n                display: \"flex\",\n                flexDirection: \"column\",\n                bgcolor: \"#d4dde5\",\n                width: \"100%\",\n                height: \"100%\",\n                overflow: \"hidden\",\n                position: \"relative\",\n            }}\n        >\n            {/* <SplitPane\n                defaultSize={props.Media.isPanelVisible ? \"35vh\" : 0}\n                size={props.Media.isPanelVisible ? \"35vh\" : 0}\n                split=\"horizontal\"\n                resizerClassName={classnames(styles.Resizer, styles.horizontal)}\n                resizerStyle={{\n                    display: !props.Media.isPanelVisible ? \"none\" : \"block\",\n                }}\n            >\n                {props.Media.isPanelVisible ? <MediaComponent /> : <div />} */}\n            <SplitPane\n                split={landScape ? \"vertical\" : \"horizontal\"}\n                size={\n                    props.isSecondWindowOpen && props.selectedText\n                        ? \"50%\"\n                        : \"70%\"\n                }\n                style={\n                    !props.isSecondWindowOpen && {\n                        marginLeft: \"20%\",\n                        marginTop: 10,\n                    }\n                }\n                resizerStyle={!props.isSecondWindowOpen && { display: \"none\" }}\n                resizerClassName={\n                    !props.isSecondWindowOpen\n                        ? classnames(\n                              styles.Resizer,\n                              { [styles.vertical]: landScape },\n                              { [styles.horizontal]: !landScape }\n                          )\n                        : null\n                }\n                onDragFinished={(width: number) => {\n                    if (width > 0) window.dispatchEvent(new Event(\"resize\"));\n                }}\n            >\n                <ErrorBoundary>\n                    <TextDetailContainer />\n                </ErrorBoundary>\n                <ErrorBoundary>\n                    {props.isSecondWindowOpen && props.selectedText && (\n                        <TextDetailContainer2 />\n                    )}\n                </ErrorBoundary>\n            </SplitPane>\n            {props.Media.isPanelVisible && (\n                <ErrorBoundary>\n                    <MediaComponent />\n                </ErrorBoundary>\n            )}\n            {/* </SplitPane> */}\n        </Box>\n    );\n}\n\nconst mapStateToProps = (state: AppState): { user: User } => {\n    const isSecondWindowOpen = reducers.isSecondWindowOpen(state);\n    const Media = reducers.getMediaData(state);\n    const selectedText = reducers.getSelectedText(state);\n    return {\n        selectedText,\n        isSecondWindowOpen,\n        Media,\n    };\n};\n\nconst mergeProps = (stateProps, dispatchProps, ownProps) => {\n    const { dispatch } = dispatchProps;\n\n    return {\n        ...ownProps,\n        ...stateProps,\n    };\n};\nconst TextSheetContainer = connect(\n    mapStateToProps,\n    null,\n    mergeProps\n)(TextSheet);\n\nexport default TextSheetContainer;\n","import React from \"react\";\n\nclass ErrorBoundary extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = { hasError: false };\n    }\n\n    static getDerivedStateFromError(error) {\n        // Update state so the next render will show the fallback UI.\n        return { hasError: true };\n    }\n\n    componentDidCatch(error, errorInfo) {\n        // You can also log the error to an error reporting service\n        console.log(error, errorInfo);\n    }\n\n    render() {\n        if (this.state.hasError) {\n            // You can render any custom fallback UI\n            return <h1>Something went wrong.</h1>;\n        }\n\n        return this.props.children;\n    }\n}\n\nexport default ErrorBoundary;\n","import { Collapse } from \"@mui/material\";\nimport React from \"react\";\nimport Player from \"react-howler-player\";\nimport { useTheme } from \"@mui/material/styles\";\nfunction Audio(props) {\n    const theme = useTheme();\n    let url = \"https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3\";\n    let playerRef = React.useRef(null);\n    const handleSeek = (e) => {\n        console.log(e);\n    };\n    const onPlayerReady = (data) => {\n        console.log(data);\n    };\n\n    return (\n        <Collapse in={props.open}>\n            <Player\n                profile=\"top_progress\"\n                src={[url]}\n                isDark={theme.palette.mode === \"dark\" ? true : false}\n                onLoad={onPlayerReady}\n                speedPanel={\"bottom\"}\n                ref={playerRef}\n                onPlay={handleSeek}\n            />\n        </Collapse>\n    );\n}\n\nexport default Audio;\n","import React from \"react\";\nimport Draggable from \"react-draggable\";\nimport CloseIcon from \"@mui/icons-material/Close\";\nimport Paper, { PaperProps } from \"@mui/material/Paper\";\nimport { ResizableBox } from \"react-resizable\";\nimport Video from \"./Video\";\nimport Audio from \"./Audio\";\nimport Box from \"@mui/material/Box\";\nimport { IconButton } from \"@mui/material\";\nfunction PaperComponent(props: PaperProps) {\n    return (\n        <Draggable handle=\"#draggable-dialog-title\" bounds=\"parent\">\n            <Paper {...props} />\n        </Draggable>\n    );\n}\n\nfunction DraggableMedia(props) {\n    const [hide, setHide] = React.useState(true);\n\n    const handleClose = () => {\n        props.changeMediaSelection(null);\n    };\n    const toggleHide = () => {\n        setHide((prev) => !prev);\n    };\n    if (props.selectedMedia.isImageVisible) return null;\n\n    return (\n        <PaperComponent\n            sx={{ position: \"absolute\", zIndex: 1, right: 0 }}\n\n            // onClose={handleClose}\n        >\n            {/* <ResizableBox height={350} width={400}> */}\n            <div className=\"Resizable-media-div\">\n                <div\n                    style={{\n                        cursor: \"move\",\n                        paddingInline: 20,\n                        paddingTop: 10,\n                        display: \"flex\",\n                        justifyContent: \"space-between\",\n                        alignItems: \"center\",\n                    }}\n                    id=\"draggable-dialog-title\"\n                >\n                    <h3>{props.selectedMedia.isVideoVisible && \"VIDEO\"}</h3>\n                    <h3>{props.selectedMedia.isAudioVisible && \"AUDIO\"}</h3>\n                    <div className=\"buttons-hide-close\">\n                        <IconButton onClick={toggleHide} disableRipple>\n                            {hide ? \"-\" : \"+\"}\n                        </IconButton>\n                        <IconButton onClick={handleClose} disableRipple>\n                            <CloseIcon />\n                        </IconButton>\n                    </div>\n                </div>\n                <>\n                    {props.selectedMedia.isVideoVisible && (\n                        <Video {...props} open={hide} setOpen={setHide} />\n                    )}\n                    {props.selectedMedia.isAudioVisible && (\n                        <Audio open={hide} setOpen={setHide} />\n                    )}\n                </>\n            </div>\n            {/* </ResizableBox> */}\n        </PaperComponent>\n    );\n}\n\nexport default DraggableMedia;\n","import React, { useState, useRef, useEffect, memo, useCallback } from \"react\";\nimport styles from \"./Image.css\";\nimport { TransformWrapper, TransformComponent } from \"react-zoom-pan-pinch\";\nimport _ from \"lodash\";\nimport { LazyLoadImage } from \"react-lazy-load-image-component\";\nimport {\n    IconButton,\n    NativeSelect,\n    MenuItem,\n    FormControl,\n    Box,\n    InputLabel,\n    AppBar,\n} from \"@mui/material\";\nimport classnames from \"classnames\";\nimport ChevronRightIcon from \"@mui/icons-material/ChevronRight\";\nimport ChevronLeftIcon from \"@mui/icons-material/ChevronLeft\";\nimport CircularProgress from \"@mui/material/CircularProgress\";\nimport CancelIcon from \"@mui/icons-material/Cancel\";\nfunction HttpUrl(data = \"\") {\n    if (data.includes(\"https\")) return data;\n    return \"https://\" + data;\n}\nasync function fetchImage(url) {\n    const res = await fetch(url);\n    const imageBlob = await res.blob();\n    const imageObjectURL = URL.createObjectURL(imageBlob);\n    return imageObjectURL;\n}\n\nfunction Image(props) {\n    const selectRef = useRef(null);\n    let imageList = props.imageData?.alignment;\n    let message = props.imageData?.message;\n    let imageRef = React.useRef(\"\");\n    let textIdfromAlignment = props.alignmentData.text;\n    let imageAlignmentById = props.imageAlignmentById;\n    let imageScrollId = props.imageScrollId;\n    let isPortraitImage = props.isImagePortrait;\n    let [imageSelected, SetSelected] = useState(0);\n    let [imageHeight, setImageHeight] = useState(\"50vh\");\n    let imageIdList = [];\n    let syncIdOnClick = props.syncIdOnClick;\n    let [loading, setLoading] = useState(false);\n    const [img, setImg] = useState();\n\n    useEffect(() => {\n        setLoading(true);\n        if (!_.isEmpty(imageList)) {\n            let url = HttpUrl(imageList[imageSelected].target_segment);\n            let imageObjectURL = fetchImage(url, imageList);\n            imageObjectURL\n                .then((data) => {\n                    setImg(data);\n                    setLoading(false);\n                })\n                .catch((e) => console.log(e));\n\n            let image = imageList[imageSelected];\n            props.changeSelectedImage(image);\n            let imageDocId = image.source_segment.start;\n        }\n    }, [imageList, imageSelected]);\n\n    if (!_.isEmpty(imageList)) {\n        imageIdList = imageList.map((l) => parseInt(l.source_segment.start));\n    }\n\n    useEffect(() => {\n        let IDtoSync = parseInt(imageScrollId.id.start);\n        if (\n            textIdfromAlignment === props.selectedText.id &&\n            imageScrollId.from === 1\n        ) {\n            if (!_.isEmpty(imageList)) {\n                let findSegment = imageList.find(\n                    (l) =>\n                        l.source_segment.start <= IDtoSync &&\n                        l.source_segment.end > IDtoSync\n                );\n                let index = imageList.findIndex(\n                    (l) => l?.source_segment === findSegment.source_segment\n                );\n                if (parseInt(index) >= 0) {\n                    SetSelected(index);\n                }\n            }\n        }\n    }, [imageScrollId]);\n\n    useEffect(() => {\n        selectRef.current.value = props.witness;\n        setLoading(true);\n        fetchImage();\n    }, [props.witness]);\n\n    useEffect(() => {\n        if (textIdfromAlignment === props.selectedText.id) {\n            let ClickId = syncIdOnClick.toString().replace(\"s_\", \"\");\n            if (imageList?.length > 0 && ClickId > 0) {\n                let findSegment = imageList.find(\n                    (l) =>\n                        l.source_segment.start < ClickId &&\n                        l.source_segment.end > ClickId\n                );\n                let index = imageList.findIndex(\n                    (l) => l?.source_segment === findSegment?.source_segment\n                );\n                if (index >= 0) {\n                    SetSelected(index);\n                }\n            }\n        }\n    }, [syncIdOnClick]);\n\n    const isPortrait = ({ target: img }) => {\n        //this Check if the provided Image is a portrait or a landScape\n        let tempHeight = img.naturalHeight;\n        setImageHeight(img.naturalHeight);\n        let tempWIdth = img.naturalWidth;\n        if (tempHeight === 0 || tempWIdth === 0) return null;\n        props.changeIsImagePortrait(tempHeight >= tempWIdth);\n        setLoading(false);\n    };\n    const handleChangeImage = (data) => {\n        let currentid = imageAlignmentById.find((l) => {\n            return l.id === imageSelected;\n        });\n        console.log(currentid);\n        if (data === \"prev\" && imageSelected > 0) {\n            SetSelected((prev) => prev - 1);\n        }\n        if (data === \"next\" && imageSelected < imageIdList.length) {\n            SetSelected((prev) => prev + 1);\n        }\n    };\n\n    return (\n        <div\n            className={\n                isPortraitImage\n                    ? styles.ThirdWindowPortrait\n                    : styles.ThirdWindow\n            }\n            // onResize={handleResize}\n        >\n            <Box\n                className={styles.header}\n                sx={{\n                    boxShadow: 1,\n                    bgcolor: \"primary\",\n                }}\n            >\n                <Box position=\"relative\" zIndex={2}>\n                    <FormControl sx={{ m: 1, minWidth: 120 }} size=\"small\">\n                        <NativeSelect\n                            labelid=\"demo-select-small\"\n                            inputRef={selectRef}\n                            onChange={(e) =>\n                                props.changeImageVersion(e.target.value)\n                            }\n                            inputProps={{\n                                name: \"age\",\n                                id: \"uncontrolled-native\",\n                            }}\n                        >\n                            {props.witnesses.map((witness) => {\n                                return (\n                                    <option\n                                        key={witness.id}\n                                        value={witness.id}\n                                        style={{ textAlign: \"center\" }}\n                                    >\n                                        {witness.source.name}\n                                    </option>\n                                );\n                            })}\n                        </NativeSelect>\n                    </FormControl>\n                </Box>\n                <IconButton\n                    aria-label=\"close\"\n                    style={{ position: \"absolute\", right: 10 }}\n                    onClick={() => props.changeMediaSelection(null)}\n                >\n                    <CancelIcon />\n                </IconButton>\n            </Box>\n            <Box className={styles.imageSection}>\n                {_.isEmpty(imageList) ? (\n                    <>\n                        {message ? (\n                            <h1>{message}</h1>\n                        ) : (\n                            <Box sx={{ height: \"30vh\" }}>\n                                <CircularProgress color=\"secondary\" />\n                            </Box>\n                        )}\n                    </>\n                ) : (\n                    <>\n                        <center height=\"100%\">\n                            {!loading ? (\n                                <TransformWrapper>\n                                    <TransformComponent>\n                                        <LazyLoadImage\n                                            itemRef={imageRef}\n                                            className={styles.ImageStyle}\n                                            src={img}\n                                            alt=\"imagepecha\"\n                                            onLoad={isPortrait}\n                                        />\n                                    </TransformComponent>\n                                </TransformWrapper>\n                            ) : (\n                                <Box sx={{ height: \"30vh\" }}>\n                                    <CircularProgress color=\"secondary\" />\n                                </Box>\n                            )}\n                        </center>\n                        <IconButton\n                            onClick={() => handleChangeImage(\"prev\")}\n                            sx={{\n                                position: \"absolute\",\n                                left: 20,\n                                top: 100,\n                            }}\n                            color=\"primary\"\n                        >\n                            <ChevronLeftIcon fill=\"currentColor\" />\n                        </IconButton>\n                        <IconButton\n                            color=\"primary\"\n                            onClick={() => handleChangeImage(\"next\")}\n                            sx={{\n                                position: \"absolute\",\n                                right: 20,\n                                top: 100,\n                            }}\n                        >\n                            <ChevronRightIcon fill=\"currentColor\" />\n                        </IconButton>\n                    </>\n                )}\n            </Box>\n        </div>\n    );\n}\n\nexport default memo(Image);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport * as reducers from \"reducers\";\nimport * as actions from \"actions\";\nimport MediaOptions from \"./MediaOptions\";\nimport DraggableMedia from \"./DraggableMedia\";\nconst mapStateToProps = (state) => {\n    const scrollToId = reducers.getScrollToId(state);\n    const syncIdOnClick = reducers.getSyncIdOnClick(state);\n    const imageData = reducers.getImageData(state);\n    const videoData = reducers.getVideoData(state);\n    let Media = reducers.getMediaData(state);\n    const selectedText = reducers.getSelectedText(state);\n    const isImagePortrait = reducers.isImagePortrait(state);\n    const alignmentData = reducers.getAlignment(state);\n    const witness = reducers.getSelectedTextWitnessId(state, selectedText.id);\n    const witnesses = reducers.getTextWitnesses(state, selectedText.id);\n    const ImageVersion = reducers.getSelectedImageVersion(state);\n    const selectedImage = reducers.getSelectedImage(state);\n    const imageScrollId = reducers.getImageScrollId(state);\n    const imageAlignmentById = reducers.getImageAlignmentById(state);\n    //  const selectedSegmentId=reducers.getSelectedSegmentId(state);\n\n    return {\n        scrollToId,\n        syncIdOnClick,\n        imageData,\n        videoData,\n        selectedMedia: Media,\n        selectedText,\n        isImagePortrait,\n        // selectedSegmentId,\n        alignmentData,\n        witness,\n        witnesses,\n        ImageVersion,\n        selectedImage,\n        imageScrollId,\n        imageAlignmentById,\n    };\n};\n\nconst matchDispatchToProps = (dispatch) => {\n    const toggleImage = (data) => dispatch(actions.changedShowPageImages(data));\n    const changeMediaSelection = (data) =>\n        dispatch(actions.mediaSelection(data));\n    const changeIsImagePortrait = (payload) =>\n        dispatch(actions.setIsImagePortrait(payload));\n    const changeImageVersion = (imageVersionId) =>\n        dispatch(actions.selectImageVersion(imageVersionId));\n    const changeSelectedImage = (payload) =>\n        dispatch(actions.selectImage(payload));\n    const onSelectedSearchResult = (\n        text: api.TextData,\n        start: number,\n        length: number,\n        selectedText: api.TextData | null\n    ) => {\n        if (!selectedText || selectedText.id !== text.id) {\n            dispatch(\n                batchActions([\n                    actions.selectedSearchResult(text.id, start, length),\n                    actions.selectedText(text),\n                ])\n            );\n        } else {\n            dispatch(actions.selectedSearchResult(text.id, start, length));\n        }\n    };\n    return {\n        toggleImage,\n        onSelectedSearchResult,\n        changeMediaSelection,\n        changeIsImagePortrait,\n        changeImageVersion,\n        changeSelectedImage,\n        changeSelectedRange: (payload) => {\n            dispatch(actions.changeSelectedRange(payload));\n        },\n        changeScrollToId: (payload) =>\n            dispatch(actions.changeScrollToId(payload)),\n    };\n};\n\nconst MediaContainer = connect(\n    mapStateToProps,\n    matchDispatchToProps\n)(DraggableMedia);\n\nexport default MediaContainer;\n","import React from \"react\";\nimport ImageComponent from \"./Image\";\nimport AudioComponent from \"./Audio\";\nimport VideoComponent from \"./Video\";\nimport styles from \"./MediaOptions.css\";\nimport CancelIcon from \"@mui/icons-material/Cancel\";\nimport { Box, IconButton } from \"@mui/material\";\n\nfunction MediaOptions(props) {\n    // if (props.selectedMedia.isImageVisible)\n    //     return <ImageComponent {...props} />;\n\n    return (\n        <Box\n            className={styles.MediaOption}\n            sx={{\n                boxShadow: 2,\n                width: \"100%\",\n                height: \"100%\",\n            }}\n        >\n            <Box\n                className={styles.header}\n                sx={{ bgcolor: \"heading.main\", color: \"text.primary\" }}\n            >\n                <h3>\n                    {props.selectedMedia.isVideoVisible && \"VIDEO\"}\n                    {props.selectedMedia.isAudioVisible && \"AUDIO\"}\n                    {/* {isPortraitImage?\"portrait\":\"landscape\"} */}\n                </h3>\n                <IconButton\n                    className={styles.closeBtn}\n                    onClick={() => props.changeMediaSelection(null)}\n                >\n                    <CancelIcon />\n                </IconButton>\n            </Box>\n            <Box\n                sx={{\n                    height: \"100%\",\n                    paddingInline: 2,\n                    bgcolor: \"navbar.main\",\n                    color: \"texts.main\",\n                }}\n            >\n                {/* {props.selectedMedia.isVideoVisible && (\n                    <VideoComponent {...props} />\n                )}\n                {props.selectedMedia.isAudioVisible && (\n                    <AudioComponent {...props} />\n                )} */}\n            </Box>\n        </Box>\n    );\n}\n\nexport default MediaOptions;\n","import React, { useRef, useEffect, useState, useCallback } from \"react\";\nimport ReactPlayer from \"react-player\";\nimport _ from \"lodash\";\nimport { Collapse } from \"@mui/material\";\n\nfunction toHMS(seconds) {\n    var date = new Date(null);\n    date.setSeconds(seconds);\n    return date.toISOString().substr(11, 8);\n}\nfunction toSec(hms = \"\") {\n    var a = hms.split(\":\"); // split it at the colons\n    // minutes are worth 60 seconds. Hours are worth 60 minutes.\n    var seconds = +a[0] * 60 * 60 + +a[1] * 60 + +a[2];\n    return seconds;\n}\nfunction calTimeToSeek(maxValue, currentTime) {\n    let i = toSec(currentTime) / maxValue;\n    return parseFloat(i);\n}\nfunction getClosestNumber(arr, d) {\n    return arr.reduce((a, b) => (b <= d && a < b ? b : a), 0);\n}\nfunction Video(props) {\n    let textIdfromAlignment = props.alignmentData.text;\n    let sourceId = props?.videoData?.source?.text;\n    const VideoData = props?.videoData?.alignment || [];\n    const url = \"https://www.youtube.com/watch?v=2MMM_ggekfE\";\n    const [interval, setInterval] = useState({});\n    let VideoIdListRange = [];\n    let closestID = [];\n    // const syncIdOnScroll = props.syncIdOnScroll;\n    const syncIdOnClick = props.syncIdOnClick;\n    const [state, setState] = useState({\n        played: 0,\n        duration: 0,\n        playing: true,\n    });\n    if (!_.isEmpty(VideoData)) {\n        VideoIdListRange = VideoData.map((l) => [\n            parseInt(l.source_segment.start),\n            parseInt(l.source_segment.end),\n        ]);\n    }\n\n    useEffect(() => {\n        if (textIdfromAlignment === props.selectedText.id) {\n            //     let intersection = syncIdOnScroll.filter(element => VideoIdList.includes(element));\n            //     newList= VideoData.filter(d=>d.source_segment===intersection[0]);\n            //     jumpToTime(newList[0]?.target_segment.start)\n            let ClickId = syncIdOnClick;\n\n            closestID = VideoIdListRange.find(\n                ([start, end]) => ClickId > start && ClickId < end\n            );\n            if (closestID) {\n                let data = VideoData.find(\n                    (l) => l.source_segment.start === closestID[0]?.toString()\n                );\n\n                if (!_.isEmpty(data)) {\n                    jumpToTime(data.target_segment.start);\n                }\n            }\n        }\n    }, [syncIdOnClick]);\n\n    const changeTextBackground = useCallback(() => {\n        let current = interval;\n        if (textIdfromAlignment === props.selectedText.id) {\n            for (let i = current.start; i < current.end; i++) {\n                let currentIds = document.getElementById(`s_${i}`);\n                if (currentIds) {\n                    currentIds.style.fontWeight = \"bold\";\n                }\n            }\n        }\n    }, [interval.start]);\n\n    useEffect(() => {\n        let timer = setTimeout(() => changeTextBackground(), 800);\n        let current = interval;\n        if (interval.start) {\n            props.changeScrollToId({\n                id: current.start || null,\n                from: \"video\",\n            });\n        }\n        return () => {\n            clearTimeout(timer);\n            for (let i = current.start; i < current.end; i++) {\n                let currentIds = document.getElementById(`s_${i}`);\n                if (currentIds) {\n                    currentIds.style.fontWeight = \"normal\";\n                }\n            }\n        };\n    }, [interval.start]);\n\n    const videoRef = useRef();\n\n    const jumpToTime = (time) => {\n        let newData = calTimeToSeek(state.duration, time);\n        videoRef.current.seekTo(parseFloat(newData));\n    };\n\n    const handleProgress = (e) => {\n        const played = e.playedSeconds;\n        const Interval = VideoData.find(\n            (time) =>\n                toSec(time.target_segment.start) < played &&\n                toSec(time.target_segment.end) > played\n        );\n        if (!_.isEmpty(Interval)) {\n            let source_segment = Interval.source_segment;\n            changeTextBackground();\n            setInterval({ ...source_segment });\n        }\n    };\n    if (VideoData.length === 0) return <div />;\n    if (sourceId !== props.selectedText.id) return <div />;\n    return (\n        <Collapse in={props.open}>\n            <ReactPlayer\n                url={url}\n                style={{ maxWidth: \"100%\" }}\n                ref={videoRef}\n                controls={true}\n                onDuration={(duration) =>\n                    setState({ ...state, duration: duration })\n                }\n                light\n                playing\n                onPlay={() => setState({ ...state, playing: true })}\n                onPause={() => setState({ ...state, playing: false })}\n                onProgress={handleProgress}\n                onError={() => console.log(\"error in media sec\")}\n            />\n        </Collapse>\n    );\n}\n\nexport default Video;\n","import React from \"react\";\nimport styles from \"./Sidebar.css\";\nimport InfoIcon from \"@mui/icons-material/Info\";\nimport PermMediaIcon from \"@mui/icons-material/PermMedia\";\nimport BookIcon from \"@mui/icons-material/Book\";\nimport FeedbackIcon from \"@mui/icons-material/Feedback\";\nimport YoutubeSearchedForIcon from \"@mui/icons-material/YoutubeSearchedFor\";\nimport Index from \"./SidebarOptions\";\nimport { NavLink } from \"redux-first-router-link\";\nimport lopenling_logo from \"images/lopenling_logo_173x.png\";\nimport useLocalStorage from \"components/utility/useLocalStorage\";\nimport { Tabs, Tab, Typography, Box } from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\nfunction Resources() {\n  const [value, setValue] = useLocalStorage(\"selectedResources\", 0);\n  const handleChange = (event: React.SyntheticEvent, newValue: number) => {\n    setValue(newValue);\n  };\n  const theme = useTheme();\n  return (\n    <Box\n      sx={{\n        width: \"100%\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        bgcolor: \"background.default\",\n        height: \"100%\",\n        maxWidth: \"250px\",\n        zIndex: 10,\n        position: \"relative\",\n        borderRight:\n          theme.palette.mode === \"light\" ? \"2px solid lightgray\" : \"0\",\n      }}\n    >\n      <Box\n        sx={{\n          borderBottom: 1,\n          borderColor: \"divider\",\n          display: \"flex\",\n        }}\n        className={styles.optionlist}\n      >\n        <Tabs\n          value={value}\n          style={{ flex: 1 }}\n          onChange={handleChange}\n          aria-label=\"basic tabs example\"\n        >\n          <Tab\n            style={{ minWidth: 0, flex: 1 }}\n            icon={<InfoIcon />}\n            {...a11yProps(0)}\n          ></Tab>\n\n          <Tab\n            style={{ minWidth: 0, flex: 1 }}\n            icon={<PermMediaIcon />}\n            {...a11yProps(1)}\n          ></Tab>\n          <Tab\n            style={{ minWidth: 0, flex: 1 }}\n            icon={<BookIcon />}\n            {...a11yProps(2)}\n          ></Tab>\n          <Tab\n            style={{ minWidth: 0, flex: 1 }}\n            icon={<FeedbackIcon />}\n            {...a11yProps(3)}\n          ></Tab>\n        </Tabs>\n      </Box>\n      <>\n        <TabPanel value={value} index={0}>\n          <Index.About />\n        </TabPanel>\n        <TabPanel value={value} index={1}>\n          <Index.Resources />\n        </TabPanel>\n        <TabPanel value={value} index={2}>\n          <Index.Dictionary />\n        </TabPanel>\n        <TabPanel value={value} index={3}>\n          <Index.Commentary />\n        </TabPanel>\n      </>\n      <Box alignSelf=\"center\" sx={{ position: \"absolute\", bottom: 0 }}>\n        <NavLink to=\"/\">\n          <div className={styles.logo}>\n            <img\n              src={lopenling_logo}\n              alt={\"lopenling-logo\"}\n              height={37}\n              width={172}\n            />\n          </div>\n        </NavLink>\n      </Box>\n    </Box>\n  );\n}\n\nexport default Resources;\n\ninterface TabPanelProps {\n  children?: React.ReactNode;\n  index: number;\n  value: number;\n}\n\nfunction a11yProps(index: number) {\n  return {\n    id: `simple-tab-${index}`,\n    \"aria-controls\": `simple-tabpanel-${index}`,\n  };\n}\n\nfunction TabPanel(props: TabPanelProps) {\n  const { children, value, index, ...other } = props;\n\n  return (\n    <div\n      role=\"tabpanel\"\n      hidden={value !== index}\n      id={`simple-tabpanel-${index}`}\n      aria-labelledby={`simple-tab-${index}`}\n      {...other}\n      style={{ paddingInline: 5 }}\n    >\n      {value === index && <Box pt={2}>{children}</Box>}\n    </div>\n  );\n}\n","import React, { useState } from \"react\";\nimport styles from \"./About.css\";\nimport * as reducers from \"reducers\";\nimport * as actions from \"actions\";\nimport {\n    Typography,\n    Accordion,\n    AccordionDetails,\n    AccordionSummary,\n} from \"@mui/material\";\nimport { connect } from \"react-redux\";\nimport { text } from \"@fortawesome/fontawesome-svg-core\";\nimport { FormattedMessage } from \"react-intl\";\nimport { ExpandMore } from \"@mui/icons-material\";\nfunction About(props) {\n    const { Textdata, selectedText } = props;\n\n    if (!selectedText) return <div>no selected Text available</div>;\n\n    let selected = Textdata.detail.find((l) => l.text === selectedText.id);\n    if (!selected) return <div>No about info</div>;\n    return (\n        <>\n            <Typography variant=\"h4\" component=\"div\" mb={3}>\n                <FormattedMessage id=\"Resource.About\" />\n            </Typography>\n            <Accordion TransitionProps={{ unmountOnExit: true }}>\n                <AccordionSummary\n                    sx={{ fontWeight: \"bold\" }}\n                    expandIcon={<ExpandMore />}\n                >\n                    <FormattedMessage id=\"text.title\" />\n                </AccordionSummary>\n                <AccordionDetails>{selected.title}</AccordionDetails>\n            </Accordion>\n            <Accordion TransitionProps={{ unmountOnExit: true }}>\n                <AccordionSummary expandIcon={<ExpandMore />}>\n                    <FormattedMessage id=\"text.description\" />\n                </AccordionSummary>\n                <AccordionDetails>{selected.description}</AccordionDetails>\n            </Accordion>\n        </>\n    );\n}\n\nconst mapStateToProps = (state: AppState): {} => {\n    return {\n        Textdata: reducers.getTextTitle(state),\n        selectedText: reducers.getSelectedText(state),\n    };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n    return {};\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(About);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport * as actions from \"actions\";\nimport * as reducers from \"reducers\";\nimport { Typography, Box } from \"@mui/material\";\nfunction Commentary({ alignmentData, text, selectSecondWindowText }) {\n    let targetWitness = alignmentData.target;\n    let textAlignments = alignmentData?.alignments.text || [];\n    const handleSelectText = (text) => {\n        selectSecondWindowText(text);\n    };\n\n    return (\n        <Box>\n            <Typography variant=\"h6\" gutterBottom component=\"div\">\n                Commentary\n            </Typography>\n            {textAlignments.length > 0 &&\n                textAlignments.map((alignment, index) => {\n                    return (\n                        <ul\n                            style={{ paddingLeft: 18 }}\n                            key={`commentary-${index}`}\n                        >\n                            <li\n                                style={{ cursor: \"pointer\" }}\n                                onClick={() =>\n                                    handleSelectText({\n                                        id: 140,\n                                        name: \"བྱང་ཆུབ་སེམས་དཔའི་སྤྱོད་པ་ལ་འཇུག་པ་བཞུགས་པའི་འགྲེལ་པ།\",\n                                    })\n                                }\n                            >\n                                {alignment.target}\n                            </li>\n                        </ul>\n                    );\n                })}\n        </Box>\n    );\n}\n\nconst mapStateToProps = (state: AppState): {} => {\n    let selectedMedia = reducers.getMediaData(state);\n    const alignmentData = reducers.getAlignment(state);\n    let text = reducers.getText(state, alignmentData.target);\n    return {\n        alignmentData,\n        selectedMedia,\n        text,\n    };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n    const changeMediaSelection = (data) =>\n        dispatch(actions.mediaSelection(data));\n    return {\n        changeMediaSelection,\n        onChangeWindowOpen: (data: boolean) => {\n            dispatch(actions.toggleSecondWindow(data));\n        },\n        onSelectedSearchResult: (\n            text: number,\n            start: number,\n            length: number\n        ) => {\n            dispatch(actions.selectedSearchResult(text, start, length));\n        },\n        selectSecondWindowText: (data) => {\n            dispatch(actions.selectedText2(data));\n        },\n    };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Commentary);\n","import React from \"react\";\nimport styles from \"./ResourceOption.css\";\nimport { Typography, Box } from \"@mui/material\";\nimport DiscourseForum from \"components/utility/discourseForum\";\nfunction Dictionary() {\n    return (\n        <>\n            <Typography variant=\"h6\" gutterBottom component=\"div\">\n                Dictionary\n            </Typography>\n            <Box p={2}>\n                <input type=\"text\" placeholder=\"search Terms\"></input>\n            </Box>\n            <DiscourseForum  topicId={1433}/>\n        </>\n    );\n}\n\nexport default Dictionary;\n","import React, { useEffect } from \"react\";\nimport { connect } from \"react-redux\";\nimport styles from \"./Resources.css\";\nimport ImageIcon from \"@mui/icons-material/Image\";\nimport OndemandVideoIcon from \"@mui/icons-material/OndemandVideo\";\nimport AudiotrackIcon from \"@mui/icons-material/Audiotrack\";\nimport * as actions from \"actions\";\nimport * as reducers from \"reducers\";\nimport {\n  List,\n  ListItem,\n  ListItemButton,\n  ListItemIcon,\n  ListItemText,\n  Typography,\n} from \"@mui/material\";\nfunction Resources(props) {\n  const handleMediaToggle = (data) => {\n    props.changeMediaSelection(data);\n  };\n\n  return (\n    <>\n      <Typography variant=\"h6\" gutterBottom component=\"div\">\n        Media\n      </Typography>\n      <List\n        sx={{\n          width: \"100%\",\n          maxWidth: 360,\n          bgcolor: \"background.paper\",\n        }}\n      >\n        <ListItemButton\n          selected={props.showPageImages}\n          onClick={() => props.changedShowPageImages(!props.showPageImages)}\n        >\n          <ListItemIcon>\n            <ImageIcon />\n          </ListItemIcon>\n          <ListItemText primary=\"Image\" />\n        </ListItemButton>\n        <ListItemButton\n          selected={props.selectedMedia.isVideoVisible}\n          onClick={() => handleMediaToggle(\"VIDEO\")}\n        >\n          <ListItemIcon>\n            <OndemandVideoIcon />\n          </ListItemIcon>\n          <ListItemText primary=\"Video\" />\n        </ListItemButton>\n        <ListItemButton\n          selected={props.selectedMedia.isAudioVisible}\n          onClick={() => handleMediaToggle(\"AUDIO\")}\n        >\n          <ListItemIcon>\n            <AudiotrackIcon />\n          </ListItemIcon>\n          <ListItemText primary=\"Audio\" />\n        </ListItemButton>\n      </List>\n    </>\n  );\n}\n\nconst mapStateToProps = (state: AppState): {} => {\n  let selectedMedia = reducers.getMediaData(state);\n  const alignmentData = reducers.getAlignment(state);\n  const showPageImages = reducers.showPageImages(state);\n  return {\n    alignmentData,\n    selectedMedia,\n    showPageImages,\n  };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  const changeMediaSelection = (data) => dispatch(actions.mediaSelection(data));\n  return {\n    changedShowPageImages: (data) => {\n      dispatch(actions.changedShowPageImages(data));\n    },\n    changeMediaSelection,\n    onSelectedSearchResult: (text: number, start: number, length: number) => {\n      dispatch(actions.selectedSearchResult(text, start, length));\n    },\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Resources);\n","import About from \"./About\";\nimport Resources from \"./Resources\";\nimport Commentary from \"./Commentary\";\nimport Dictionary from \"./Dictionary\";\nexport default { About, Resources, Commentary, Dictionary };\n","import React from \"react\";\nimport styles from \"./AddButton.css\";\n\ntype Props = {\n    title?: string,\n    onClick?: () => void\n};\n\nconst AddButton = (props: Props) => {\n    return (\n        <div className={styles.button} title={props.title} onClick={props.onClick}>\n            +\n        </div>\n    );\n};\n\nexport default AddButton;\n","// @flow\nimport * as React from \"react\";\nimport ReactDom from \"react-dom\";\nimport classnames from \"classnames\";\nimport AnnotationDetail from \"./AnnotationDetail\";\nimport AnnotationDetailEdit from \"./AnnotationDetailEdit\";\nimport styles from \"./AnnotationControls.css\";\nimport colours from \"css/colour.css\";\nimport User from \"lib/User\";\nimport Witness from \"lib/Witness\";\nimport Annotation, { ANNOTATION_TYPES } from \"lib/Annotation\";\nimport AnnotationControlsHeading from \"./AnnotationControlsHeading\";\nimport NoteEditor from \"./NoteEditor\";\nimport QuestionView from \"./QuestionView\";\nimport QuestionEditor from \"./QuestionEditor\";\nimport QuestionsLoading from \"./QuestionsLoading\";\nimport { FormattedMessage } from \"react-intl\";\nimport Note from \"./Note\";\nimport Button from \"components/UI/Button\";\nimport PageBreakIcon from \"images/page_break_icon.svg\";\nimport { List } from \"react-virtualized/dist/es/List\";\nimport AnnotationControlsHeader from \"./AnnotationControlsHeader\";\nimport Question from \"lib/Question\";\nimport { FAKE_LOGIN } from \"app_constants\";\n\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\nimport { Snackbar } from \"@mui/material\";\nexport const CONTROLS_MARGIN_LEFT = 10;\nexport type QuestionData = {\n    loading: boolean,\n    questions: Question[],\n};\n\nexport type Props = {\n    inline: boolean,\n    user: User,\n    annotationsData: null,\n    activeAnnotation: null,\n    baseAnnotation: null,\n    availableAnnotations: Annotation[] | null,\n    temporaryAnnotation: null,\n    inline: null,\n    firstSelectedSegment: null,\n    splitTextRect: ClientRect | null,\n    selectedWitness: Witness,\n    selectedElementId: string | null,\n    selectedElementIds: string[] | null,\n    pechaImageClass: string,\n    notes: Annotation[],\n    temporaryNotes: Annotation[],\n    questions: Annotation[],\n    questionsData: { [annotationId: AnnotationUniqueId]: QuestionData },\n    temporaryQuestions: Annotation[],\n    questionQuote: React.Element<typeof React.Component> | null,\n    addNote: () => void,\n    editNote: (annotation: Annotation) => void,\n    saveAnnotation: (annotation: Annotation, content: string) => void,\n    cancelEditAnnotation: (annotation: Annotation) => void,\n    deleteAnnotation: (annotation: Annotation) => void,\n    addPageBreak: () => void,\n    addLineBreak: () => void,\n    addQuestion: () => void,\n    saveQuestion: (\n        question: Annotation,\n        title: string,\n        content: string\n    ) => void,\n    list: List | null,\n    closeAnnotation: () => void,\n};\n\ntype AnchorPoint = \"top\" | \"left\" | \"bottom\" | \"right\";\n\nconst anchorPoints = {\n    top: 1,\n    left: 2,\n    bottom: 3,\n    right: 4,\n};\n\nclass AnnotationControls extends React.Component<Props> {\n    controls: HTMLDivElement | null;\n    arrow: HTMLDivElement | null;\n    arrowDs: HTMLDivElement | null;\n    annotation: null;\n    constructor(props: Props) {\n        super(props);\n\n        this.controls = null;\n        this.arrow = null;\n        this.arrowDs = null;\n    }\n\n    componentDidMount() {\n        this.updatePosition();\n    }\n\n    componentDidUpdate() {\n        // Need to delay calling this because the browser\n        // may not have finished rendering when first called.\n\n        setTimeout(this.updatePosition.bind(this), 0);\n    }\n\n    updatePosition() {\n        const measurements = this.getMeasurements();\n        if (\n            !this.props.inline ||\n            !this.controls ||\n            !this.arrow ||\n            !measurements\n        ) {\n            return;\n        }\n        const controls = this.controls;\n        const height = controls.offsetHeight;\n        const width = controls.offsetWidth;\n        const arrow = this.arrow;\n        const bottomGap = measurements.bottomGap;\n        const offScreen = bottomGap < 0 || bottomGap > height;\n\n        let top = measurements.top;\n        const viewPortWidth = measurements.viewPortWidth || 0;\n        let selectedLeft = measurements.left;\n        let selectedRight = selectedLeft + measurements.width;\n\n        arrow.style.display = \"none\";\n        if (this.props.selectedElementIds) {\n            let lines = 1;\n            let prevSegmentLeft = 0;\n            let lastLineLeft = 0;\n            let lastLineRight = 0;\n            let lastLineBottom = 0;\n            for (let i = 0; i < this.props.selectedElementIds.length; i++) {\n                const segmentId = this.props.selectedElementIds[i];\n                const segment = document.getElementById(segmentId);\n                if (segment) {\n                    const segmentLeft = segment.offsetLeft;\n                    const segmentRight = segmentLeft + segment.offsetWidth;\n                    if (segmentLeft < prevSegmentLeft) {\n                        lines++;\n                        lastLineLeft = segmentLeft;\n                        lastLineRight = segmentRight;\n                        lastLineBottom =\n                            segment.offsetTop + segment.offsetHeight;\n                        selectedLeft = segmentLeft;\n                        selectedRight = segmentRight;\n                    } else if (segmentRight > lastLineRight) {\n                        lastLineRight = segmentRight;\n                        // selectedRight = segmentRight;\n                    }\n                    if (segmentLeft < selectedLeft) selectedLeft = segmentLeft;\n                    if (segmentRight > selectedRight)\n                        selectedRight = segmentRight;\n                    prevSegmentLeft = segmentLeft;\n                }\n            }\n        }\n        let selectedWidth = selectedRight - selectedLeft;\n        let anchorPoint = anchorPoints.bottom;\n        let moveToSide = false;\n        let moveRight = 0;\n        console.log(bottomGap, offScreen, height);\n        if (!offScreen && bottomGap < height) {\n            moveToSide = true;\n        }\n\n        if (moveToSide) {\n            arrow.className = styles.arrowLeft;\n            if (selectedLeft - width - arrow.offsetWidth < 0) {\n                anchorPoint = anchorPoints.right;\n            } else {\n                anchorPoint = anchorPoints.left;\n            }\n        } else {\n            let controlOverhang = width / 2 - selectedWidth / 2;\n            if (selectedLeft - controlOverhang < 0) {\n                moveRight = Math.abs(selectedLeft - controlOverhang);\n            }\n            if (selectedRight + controlOverhang > viewPortWidth) {\n                moveRight = viewPortWidth - (selectedRight + controlOverhang);\n            }\n        }\n\n        if (anchorPoint === anchorPoints.bottom) {\n            let arrowHeight = 0;\n            let arrowLeft = 0;\n            if (this.arrow) {\n                this.arrow.className = styles.arrowTop;\n                arrowLeft = width / 2 - this.arrow.offsetWidth / 2 - moveRight;\n                if (arrowLeft < 0) arrowLeft = 0;\n                this.arrow.style.left = arrowLeft + \"px\";\n                arrowHeight = this.arrow.offsetHeight;\n                this.arrow.style.top = 0 - arrowHeight + \"px\";\n            }\n            // controls.style.top = top + measurements.height + arrowHeight + \"px\";\n            controls.style.top = top - measurements.height + 20 + \"px\"; // 20 added due to 30 px padding on splitTextRow first child\n            // controls.style.left =\n            // selectedLeft + selectedWidth / 2 - width / 2 + moveRight + \"px\";\n            controls.style.left = measurements.left + \"px\";\n        } else if (moveToSide) {\n            console.log(\"moveToSide\");\n\n            arrow.className = styles.arrowRight;\n            let arrowHeight = arrow.offsetHeight;\n            let controlsTop =\n                measurements.top + measurements.height / 2 - arrowHeight / 2;\n            if (\n                measurements.top +\n                    measurements.height +\n                    bottomGap -\n                    controlsTop <\n                height\n            ) {\n                controlsTop =\n                    measurements.top + measurements.height + bottomGap - height;\n            }\n            if (anchorPoint === anchorPoints.left) {\n                // left side of selection\n\n                arrow.style.left = width - 2 + \"px\";\n                controls.style.left =\n                    selectedLeft - width - arrow.offsetWidth + \"px\";\n            } else {\n                // right-side of selection\n                arrow.className = styles.arrowLeft;\n                arrow.style.left = -arrow.offsetWidth + \"px\";\n                controls.style.left =\n                    selectedLeft + selectedWidth + arrow.offsetWidth + \"px\";\n\n                // controls.style.right = 0 + \"px\";\n            }\n            arrow.style.top =\n                measurements.top -\n                controlsTop +\n                measurements.height / 2 -\n                arrowHeight / 2 +\n                \"px\";\n\n            controls.style.top = controlsTop + \"px\";\n        } else {\n            console.log(\"last\");\n            controls.style.top = top + \"px\";\n        }\n    }\n\n    getMeasurements(): {\n        top: number,\n        textTop: number,\n        rowTop: number,\n        left: number,\n        width: number,\n        height: number,\n        topGap: number,\n        bottomGap: number,\n        viewPortWidth: number | null,\n    } | null {\n        if (!this.props.selectedElementIds) {\n            return null;\n        }\n\n        const lastSelectedElementId =\n            this.props.selectedElementIds[\n                this.props.selectedElementIds.length - 1\n            ];\n        const lastElement = document.getElementById(lastSelectedElementId);\n        const firstSelectedElementId = this.props.selectedElementIds[0];\n        const firstElement = document.getElementById(firstSelectedElementId);\n\n        const splitTextRect = this.props.splitTextRect;\n        let extraTop = 0;\n        let scrollTop = 0;\n\n        if (this.props.list) {\n            scrollTop = this.props.list.Grid.state.scrollTop;\n        }\n        if (this.props.pechaImageClass) {\n            const pechaImage = document.getElementsByClassName(\n                this.props.pechaImageClass\n            )[0];\n            extraTop = pechaImage.offsetHeight;\n        }\n        if (!firstElement) {\n            console.warn(\n                \"no valid element found in getMeasurements, elementId: %s\",\n                this.props.selectedElementId\n            );\n            return {\n                top: 0,\n                textTop: 0,\n                rowTop: 0,\n                left: 0,\n                width: 1,\n                height: 1,\n                topGap: 0,\n                bottomGap: 0,\n                viewPortWidth: 1,\n            };\n        }\n        const top = firstElement.offsetTop + extraTop;\n        const textTop = firstElement.offsetTop;\n        const left = firstElement.offsetLeft;\n        const width = firstElement.offsetWidth;\n        const height = firstElement.offsetHeight;\n        let rowTop = top;\n\n        let viewPortWidth = null;\n        let topGap = 0;\n        let bottomGap = 0;\n\n        if (firstElement && splitTextRect) {\n            const elRect = firstElement.getBoundingClientRect();\n            topGap = splitTextRect.height - elRect.top;\n        }\n        if (lastElement && splitTextRect) {\n            const elRect = lastElement.getBoundingClientRect();\n\n            bottomGap =\n                splitTextRect.height + splitTextRect.top - elRect.bottom;\n            viewPortWidth = splitTextRect.width;\n        }\n\n        return {\n            top: top,\n            textTop: textTop,\n            rowTop: rowTop,\n            left: left,\n            width: width,\n            height: height,\n            topGap: topGap,\n            bottomGap: bottomGap,\n            viewPortWidth: viewPortWidth,\n        };\n    }\n\n    render() {\n        const props = this.props;\n        let annotations = [];\n        let temporaryAnnotations = [];\n        let anonymousUserMessage = null;\n        let nothingSelected = null;\n        const isLoggedIn = props.user.isLoggedIn || FAKE_LOGIN;\n\n        let breakSelected = false;\n        if (\n            props.activeAnnotation &&\n            (props.activeAnnotation.isType(ANNOTATION_TYPES.pageBreak) ||\n                props.activeAnnotation.isType(ANNOTATION_TYPES.lineBreak))\n        ) {\n            breakSelected = true;\n        }\n        // the selected word/sentence is props.anotationsData\n\n        if (props.annotationsData) {\n            props.annotationsData.map((annotationData) => {\n                let isEditing = false;\n                let isActive = false;\n                if (annotationData.isTemporary) {\n                    isEditing = true;\n                    isActive = true;\n                } else if (\n                    !props.temporaryAnnotation &&\n                    annotationData.annotation.uniqueId ==\n                        props.activeAnnotation.uniqueId\n                ) {\n                    isActive = true;\n                }\n\n                if (isEditing) {\n                    let annotationDetail = (\n                        <AnnotationDetailEdit\n                            annotationData={annotationData}\n                            key={annotationData.annotation.uniqueId}\n                            isActive={isActive}\n                            saveAnnotationHandler={(content) => {\n                                props.saveAnnotation(\n                                    annotationData.annotation,\n                                    content\n                                );\n                            }}\n                            cancelAnnotationHandler={() => {\n                                props.cancelEditAnnotation(\n                                    annotationData.annotation\n                                );\n                            }}\n                            isLoggedIn={isLoggedIn}\n                            selectAnnotationHandler={() => {}}\n                            editAnnotationHandler={() => {}}\n                        />\n                    );\n                    temporaryAnnotations.push(annotationDetail);\n                } else {\n                    let annotationDetail = (\n                        <AnnotationDetail\n                            isWorkingSection={false}\n                            fontSize={props.fontSize}\n                            annotationData={annotationData}\n                            key={annotationData.annotation.uniqueId}\n                            isActive={isActive}\n                            selectAnnotationHandler={() => {\n                                if (isLoggedIn && !isEditing) {\n                                    props.didSelectAnnotation(\n                                        annotationData.annotation\n                                    );\n                                }\n                            }}\n                            editAnnotationHandler={() => {\n                                if (isLoggedIn && !isEditing) {\n                                    this.annotation = annotationData.annotation;\n\n                                    props.editAnnotation(\n                                        annotationData.annotation\n                                    );\n                                }\n                            }}\n                            isLoggedIn={isLoggedIn}\n                        />\n                    );\n                    annotations.push(annotationDetail);\n                }\n            }, this);\n            if (!props.user.isLoggedIn === !FAKE_LOGIN) {\n                // NOTE: FormattedMessage cannot take a child when using\n                // the values option, so need to wrap it in a div\n                anonymousUserMessage = (\n                    <div\n                        className={styles.anonymousMessage}\n                        style={{\n                            position: \"relative\",\n                            width: \"fit-content\",\n                            border: \"1px solid gray\",\n                            paddingInline: 10,\n                        }}\n                    >\n                        <FormattedMessage\n                            id=\"annotations.loginMessage\"\n                            values={{\n                                loginLink: (\n                                    <>\n                                        <FormattedMessage id=\"annotations.loginLink\" />\n                                    </>\n                                ),\n                            }}\n                        />\n                    </div>\n                );\n            }\n        } else {\n            nothingSelected = (\n                <div className={styles.nothingSelected}>Nothing Selected</div>\n            );\n        }\n\n        let pageBreaksButton = null;\n        let allowPageBreak = !this.props.selectedWitness.isWorking;\n        let lineBreaksButton = null;\n        let allowLineBreak = !this.props.selectedWitness.isWorking;\n        if (isLoggedIn && !this.props.selectedWitness.isWorking) {\n            let pageBreaks = [];\n            let lineBreaks = [];\n            if (this.props.availableAnnotations) {\n                pageBreaks = this.props.availableAnnotations.filter(\n                    (annotation: Annotation) =>\n                        annotation.type === ANNOTATION_TYPES.pageBreak &&\n                        annotation.creatorWitness.id ===\n                            this.props.selectedWitness.id\n                );\n                lineBreaks = this.props.availableAnnotations.filter(\n                    (annotation: Annotation) =>\n                        annotation.type === ANNOTATION_TYPES.lineBreak &&\n                        annotation.creatorWitness.id ===\n                            this.props.selectedWitness.id\n                );\n            }\n\n            if (pageBreaks.length > 0) {\n                pageBreaksButton = (\n                    <div className={styles.breakButtons}>\n                        <Button\n                            title=\"Page Break\"\n                            accessoryType=\"DELETE\"\n                            icon={<PageBreakIcon width={20} height={20} />}\n                            onClick={() => {\n                                this.props.deleteAnnotation(pageBreaks[0]);\n                            }}\n                            isActive={true}\n                            backgroundColor={colours.activeButton}\n                        />\n                    </div>\n                );\n                allowPageBreak = false;\n            }\n\n            if (lineBreaks.length > 0) {\n                lineBreaksButton = (\n                    <div className={styles.breakButtons}>\n                        <Button\n                            title=\"Line Break\"\n                            accessoryType=\"DELETE\"\n                            icon=\"&#182;\"\n                            onClick={() => {\n                                this.props.deleteAnnotation(lineBreaks[0]);\n                            }}\n                            isActive={true}\n                            backgroundColor={colours.activeButton}\n                        />\n                    </div>\n                );\n                allowLineBreak = false;\n            }\n\n            // Can't have line break and page break in same place.\n            if (!allowPageBreak) allowLineBreak = false;\n            if (!allowLineBreak) allowPageBreak = false;\n        }\n\n        let tempNotes = null;\n        let tempNoteIds = {};\n        if (props.temporaryNotes && props.temporaryNotes.length > 0) {\n            tempNotes = props.temporaryNotes.map((note: Annotation) => {\n                let key = \"NOTE_\" + note.uniqueId;\n                // The note is being edited\n                if (note.basedOn) {\n                    tempNoteIds[note.basedOn.uniqueId] = note.uniqueId;\n                }\n                return (\n                    <NoteEditor\n                        note={note}\n                        key={key}\n                        saveNote={props.saveAnnotation}\n                        cancel={() => props.cancelEditAnnotation(note)}\n                    />\n                );\n            });\n        }\n\n        let notes = null;\n        if (props.notes && props.notes.length > 0) {\n            // Filter out notes that are being edited\n            const validNotes = props.notes.filter(\n                (note: Annotation) => !tempNoteIds.hasOwnProperty(note.uniqueId)\n            );\n            notes = validNotes.map((note: Annotation) => {\n                let key = \"NOTE_\" + note.uniqueId;\n                return (\n                    <Note\n                        note={note}\n                        key={key}\n                        delete={this.props.deleteAnnotation}\n                        edit={this.props.editNote}\n                    />\n                );\n            });\n        }\n\n        let tempQuestions = null;\n        let tempQuestionIds = {};\n        if (\n            props.temporaryQuestions &&\n            props.temporaryQuestions.length > 0 &&\n            props.questionQuote\n        ) {\n            tempQuestions = props.temporaryQuestions.map(\n                (question: Annotation) => {\n                    tempQuestionIds[question.uniqueId] = question.uniqueId;\n                    let key = \"QUESTION_\" + question.uniqueId;\n\n                    return (\n                        <QuestionEditor\n                            question={question}\n                            questionQuote={props.questionQuote}\n                            defaultTitle={props.selectedWitness.text.name}\n                            key={key}\n                            saveQuestion={props.saveQuestion}\n                            cancel={() => props.cancelEditAnnotation(question)}\n                        />\n                    );\n                }\n            );\n        }\n\n        let questionLoadingIndicators = null;\n        let questionViews: Array<QuestionView> = [];\n        let questionsAreLoading = false;\n        if (props.questions && props.questions.length > 0) {\n            let questions: Question[] = [];\n            for (let i = 0; i < props.questions.length; i++) {\n                const question = props.questions[i];\n                let isValid = !tempQuestionIds.hasOwnProperty(\n                    question.uniqueId\n                );\n                if (isValid) {\n                    if (props.questionsData.hasOwnProperty(question.uniqueId)) {\n                        if (props.questionsData[question.uniqueId].loading) {\n                            questionsAreLoading = true;\n                        }\n                        questions = questions.concat(\n                            props.questionsData[question.uniqueId].questions\n                        );\n                    }\n                }\n            }\n\n            questionViews = questions.map((question: Question) => {\n                let key = \"QUESTION_\" + question.annotationUniqueId;\n                return (\n                    <QuestionView\n                        question={question}\n                        key={\"question_\" + question.annotationUniqueId}\n                    />\n                );\n            });\n        }\n        let questionHeading = null;\n        if (questionViews.length > 0) {\n            questionHeading = (\n                <h3 className={styles.sectionHeading}>Questions</h3>\n            );\n        }\n\n        let questionsLoading = null;\n        if (questionsAreLoading) {\n            questionsLoading = <QuestionsLoading />;\n        }\n\n        let allowQuestion =\n            props.questions?.length === 0 &&\n            props.temporaryQuestions.length === 0;\n\n        let classes = [styles.annotationControls];\n        if (props.inline) {\n            classes.push(styles.inline);\n        }\n\n        let showHeader = true;\n        if (anonymousUserMessage || breakSelected) showHeader = false;\n        const annotationBody = ReactDom.createPortal(\n            <div className={styles.annotationContent}>\n                {anonymousUserMessage}\n                {nothingSelected}\n                {!breakSelected && annotations}\n                {pageBreaksButton}\n                {lineBreaksButton}\n                {tempNotes}\n                {notes}\n                {questionHeading}\n                {tempQuestions}\n                {questionsLoading}\n                {questionViews}\n            </div>,\n            document.getElementById(\"annotation-portal\")\n        );\n        return (\n            <div\n                className={classnames(...classes)}\n                ref={(controls: HTMLDivElement | null) =>\n                    (this.controls = controls)\n                }\n            >\n                {showHeader && (\n                    <AnnotationControlsHeader\n                        addPageBreak={\n                            allowPageBreak ? props.addPageBreak : null\n                        }\n                        addLineBreak={\n                            allowLineBreak ? props.addLineBreak : null\n                        }\n                        addNote={\n                            isLoggedIn && !tempNotes\n                                ? () => props.addNote()\n                                : null\n                        }\n                        addQuestion={allowQuestion ? props.addQuestion : null}\n                        closeAnnotation={props.closeAnnotation}\n                        editAnnotationHandler={() => {\n                            let editBtn = document.getElementById(\"editBtn\");\n                            editBtn?.click();\n                        }}\n                        userLoggedIn={isLoggedIn}\n                    />\n                )}\n                {!breakSelected && temporaryAnnotations}\n\n                {annotationBody}\n                <div\n                    className={styles.arrow}\n                    ref={(div) => (this.arrow = div)}\n                />\n            </div>\n        );\n    }\n}\n\nexport default React.memo(AnnotationControls);\n","// @flow\nimport React from \"react\";\nimport { connect, useStore } from \"react-redux\";\nimport { batchActions } from \"redux-batched-actions\";\nimport AnnotationControls from \"./AnnotationControls\";\nimport type { Props as ControlsProps } from \"./AnnotationControls\";\nimport addTibetanShay from \"lib/addTibetanShay\";\nimport * as reducers from \"reducers\";\nimport type { AppState } from \"reducers\";\nimport * as actions from \"actions\";\nimport { BASE_ANNOTATION_ID } from \"lib/AnnotatedText\";\nimport Annotation, {\n    ANNOTATION_TYPES,\n    TemporaryAnnotation,\n} from \"lib/Annotation\";\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\nimport AnnotatedText from \"lib/AnnotatedText\";\nimport User from \"lib/User\";\nimport Witness from \"lib/Witness\";\nimport TextSegment from \"lib/TextSegment\";\nimport SplitText from \"lib/SplitText\";\nimport _ from \"lodash\";\nimport { changedActiveTextAnnotation } from \"actions\";\nimport ReactDOMServer from \"react-dom/server\";\nimport Question from \"lib/Question\";\nimport type { QuestionData } from \"./AnnotationControls\";\nimport { getTextFontSize } from \"reducers\";\n\nconst TEMPORARY_ANNOTATION_ID = -3;\nconst BASE_NAME = \"Working\";\n\ntype AnnotationData = {\n    name: string,\n    content: string,\n    id: AnnotationUniqueId,\n    isTemporary: boolean,\n    annotation: Annotation,\n    userCreated: boolean,\n};\nconst getAnnotationsData = (\n    annotations,\n    sources,\n    workingSourceName,\n    selectedText\n): AnnotationData[] => {\n    let annotationsData = [];\n    let baseSources = sources.filter(\n        (source) => source.isWorking || source.isBase\n    );\n    let baseSourceNames = baseSources.map((source) => source.name);\n    if (annotations) {\n        let annotationsById = {};\n        for (let i = 0; i < annotations.length; i++) {\n            let annotation = annotations[i];\n            let id = annotation.content + annotation.start;\n            if (annotation.isTemporary) {\n                annotationsById[TEMPORARY_ANNOTATION_ID] = {\n                    name: annotation.getSourceName(),\n                    content: annotation.content,\n                    id: annotation.uniqueId,\n                    isTemporary: true,\n                    annotation: annotation,\n                };\n                baseSourceNames = baseSourceNames.filter(\n                    (a) => a !== annotation.getSourceName()\n                );\n                id = TEMPORARY_ANNOTATION_ID;\n            } else if (annotationsById[id]) {\n                let existingAnnotation = annotationsById[id];\n                existingAnnotation.name +=\n                    \" \" + addTibetanShay(annotation.getSourceName());\n                baseSourceNames = baseSourceNames.filter(\n                    (a) => a !== annotation.getSourceName()\n                );\n            } else {\n                annotationsById[id] = {\n                    name: addTibetanShay(annotation.getSourceName()),\n                    content: annotation.content,\n                    id: annotation.uniqueId,\n                    userCreated: annotation.userCreated,\n                    annotation: annotation,\n                };\n                baseSourceNames = baseSourceNames.filter(\n                    (a) => a !== annotation.getSourceName()\n                );\n            }\n            if (\n                !annotation.userCreated &&\n                annotation.creatorWitness.isWorking\n            ) {\n                annotationsById[id].isWorking = true;\n            } else {\n                annotationsById[id].isWorking = false;\n            }\n        }\n        // Make sure Working source is first\n        baseSourceNames.unshift(workingSourceName);\n        let Base = baseSourceNames;\n        if (\n            selectedText?.name !==\n            \"བྱང་ཆུབ་སེམས་དཔའི་སྤྱོད་པ་ལ་འཇུག་པ་བཞུགས་སོ།\"\n        ) {\n            //Dominant only awailable for chojuk text\n            Base = baseSourceNames.filter((l) => l !== \"Dominant\");\n        }\n\n        annotationsData = Object.keys(annotationsById).reduce((arr, key) => {\n            const annotationData = annotationsById[key];\n\n            if (annotationData.isWorking) {\n                annotationData.name = Base.reduce(\n                    (prev, cur) => (prev += \" \" + addTibetanShay(cur, \";\")),\n                    \"\"\n                );\n            }\n            arr.push(annotationData);\n            return arr;\n        }, []);\n    }\n\n    return annotationsData;\n};\n\nconst getAvailableAnnotations = (\n    annotatedText: AnnotatedText,\n    activeAnnotation: Annotation,\n    temporaryAnnotation: TemporaryAnnotation | null,\n    annotationPositions: { [string]: Annotation[] }\n): Annotation[] => {\n    let availableAnnotations = [];\n    if (\n        !temporaryAnnotation ||\n        activeAnnotation.naturalId !== temporaryAnnotation.naturalId\n    ) {\n        availableAnnotations.push(activeAnnotation);\n    }\n    if (temporaryAnnotation) {\n        availableAnnotations.push(temporaryAnnotation);\n    }\n    let [start, length] =\n        annotatedText.getPositionOfAnnotation(activeAnnotation);\n\n    if (!start) {\n        return availableAnnotations;\n    }\n\n    let end = start + length;\n\n    let possibleAnnotations = [];\n\n    if (activeAnnotation.isInsertion) {\n        const insertionAnnotations = annotationPositions[\"i\" + start];\n        if (insertionAnnotations) {\n            possibleAnnotations =\n                possibleAnnotations.concat(insertionAnnotations);\n        }\n        const activeInsertionAnnotations = annotationPositions[String(start)];\n        if (activeInsertionAnnotations) {\n            possibleAnnotations = possibleAnnotations.concat(\n                activeInsertionAnnotations\n            );\n        }\n    } else {\n        // Only include annotations if they encompass the whole annotation\n        // i.e. not if activeAnnotation is a user annotation and combines\n        // annotated text with normal text.\n        let startAnnotations = annotationPositions[String(start)];\n        let endAnnotations = annotationPositions[String(end)];\n\n        if (startAnnotations) {\n            possibleAnnotations = startAnnotations;\n        }\n        if (endAnnotations) {\n            possibleAnnotations = possibleAnnotations.concat(endAnnotations);\n        }\n    }\n\n    for (let i = 0; i < possibleAnnotations.length; i++) {\n        const annotation = possibleAnnotations[i];\n        if (\n            annotation.start === activeAnnotation.start &&\n            annotation.length === activeAnnotation.length\n        ) {\n            // If an annotation is being edited, there will be a temporary annotation\n            // with the same natural id. If so, don't show the orignal version.\n            //\n            // We use natualId, as it normalises the id regardless of the original's\n            // save state. e.g. Upon editing a witness variant, a new annotation will be\n            // created. If the user is offline, that will not have been saved via the\n            // API yet. The user could then edit this new annotation, creating a temporary\n            // annotation based upon it. While this is being edited, the user could come\n            // back online and the save operation will succeed. This will mean the id of\n            // the temporary annotation will be different to the original edit, but naturalId\n            // will be the same.\n            if (\n                !temporaryAnnotation ||\n                annotation.naturalId !== temporaryAnnotation.naturalId\n            ) {\n                availableAnnotations.push(annotation);\n            }\n        } else if (!annotatedText.activeWitness.isWorking) {\n            if (\n                annotation.type === ANNOTATION_TYPES.pageBreak ||\n                annotation.type === ANNOTATION_TYPES.lineBreak\n            ) {\n                availableAnnotations.push(annotation);\n            }\n        }\n    }\n\n    availableAnnotations = _.uniqWith(\n        availableAnnotations,\n        (a, b) => a.id === b.id\n    );\n\n    return availableAnnotations;\n};\n\nconst getTemporaryAnnotation = (\n    state: AppState,\n    type: string,\n    user: User,\n    witness: Witness,\n    start: number,\n    length: number\n): TemporaryAnnotation | null => {\n    const annotations = reducers.getTemporaryAnnotations(\n        state,\n        witness.id,\n        start,\n        length,\n        type\n    );\n    if (annotations.length > 0) {\n        return annotations[0];\n    } else {\n        return null;\n    }\n};\n\ntype StateProps = ControlsProps & {\n    questionsData: { [annotationId: AnnotationUniqueId]: Question[] },\n};\n\n// These are the props that are expected to be set and available in ownProps\ntype ContainerProps = {\n    annotationPositions: { [string]: Annotation[] },\n    annotatedText: AnnotatedText,\n    activeAnnotation: Annotation | null,\n    inline?: boolean,\n    firstSelectedSegment: TextSegment,\n    splitTextRect: ClientRect | null,\n    splitText: SplitText | null,\n};\n\nexport const mapStateToProps = (state: AppState, ownProps: ContainerProps) => {\n    const user = reducers.getUser(state);\n    const selectedText = reducers.getSelectedText(state);\n    const activeAnnotation = ownProps.activeAnnotation;\n    const inline = ownProps.inline;\n    let selectedWitness = reducers.getSelectedTextWitness(state);\n    if (!selectedWitness) {\n        if (selectedText) {\n            selectedWitness = reducers.getWorkingWitness(\n                state,\n                selectedText.id\n            );\n        }\n    }\n\n    if (!activeAnnotation || !selectedWitness) {\n        return {\n            annotationsData: null,\n            activeAnnotation: null,\n            baseAnnotation: null,\n            availableAnnotations: null,\n            user: user,\n            temporaryAnnotation: null,\n            inline: null,\n            firstSelectedSegment: null,\n            splitTextRect: null,\n            selectedWitness: null,\n        };\n    }\n\n    const temporaryVariant = getTemporaryAnnotation(\n        state,\n        ANNOTATION_TYPES.variant,\n        user,\n        selectedWitness,\n        activeAnnotation.start,\n        activeAnnotation.length\n    );\n\n    const annotations = getAvailableAnnotations(\n        ownProps.annotatedText,\n        activeAnnotation,\n        temporaryVariant,\n        ownProps.annotationPositions\n    );\n    const variants = annotations.filter(\n        (annotation: Annotation) => annotation.type === ANNOTATION_TYPES.variant\n    );\n    const sources = reducers.getSources(state);\n    const workingSourceName = reducers.getTranslation(\n        state,\n        \"annotation.workingEdition\",\n        BASE_NAME\n    );\n    let variantsData = getAnnotationsData(\n        variants,\n        sources,\n        workingSourceName,\n        selectedText\n    );\n\n    let baseAnnotation = null;\n    if (activeAnnotation.id == BASE_ANNOTATION_ID) {\n        baseAnnotation = activeAnnotation;\n    } else {\n        const [start, length] =\n            ownProps.annotatedText.getPositionOfAnnotation(activeAnnotation);\n        if (start === null || length === null) {\n            variantsData = null;\n        } else {\n            baseAnnotation = ownProps.annotatedText.getBaseAnnotation(\n                start,\n                length\n            );\n            const baseAnnotationData = getAnnotationsData(\n                [baseAnnotation],\n                sources,\n                workingSourceName\n            );\n            variantsData = [...baseAnnotationData, ...variantsData];\n        }\n    }\n\n    // make sure temporary annotation is first, then user created, then base annotation\n    if (variantsData) {\n        variantsData.sort((a, b) => {\n            if (a.isTemporary) {\n                return -1;\n            } else if (b.isTemporary) {\n                return 1;\n            } else if (a.userCreated) {\n                return -1;\n            } else if (b.userCreated) {\n                return 1;\n            } else if (a.annotation.id && b.annotation.id) {\n                return a.annotation.id - b.annotation.id;\n            } else {\n                return 1;\n            }\n        });\n    }\n\n    const notes: Array<Annotation> = annotations.filter(\n        (annotation: Annotation) => annotation.type === ANNOTATION_TYPES.note\n    );\n\n    const temporaryNotes = reducers.getTemporaryAnnotations(\n        state,\n        selectedWitness.id,\n        activeAnnotation.start,\n        activeAnnotation.length,\n        ANNOTATION_TYPES.note\n    );\n\n    const questionAnnotations: Array<Annotation> = annotations.filter(\n        (annotation: Annotation): boolean =>\n            annotation.type === ANNOTATION_TYPES.question\n    );\n    let questionsData = {};\n    if (questionAnnotations.length > 0) {\n        for (var i = 0; i < questionAnnotations.length; i++) {\n            const question = questionAnnotations[i];\n            questionsData[question.uniqueId] = {};\n            const isLoading = reducers.questionIsLoading(state, question);\n            questionsData[question.uniqueId][\"loading\"] = isLoading;\n            const questions = reducers.getQuestions(state, question.uniqueId);\n            questionsData[question.uniqueId][\"questions\"] = questions;\n        }\n    }\n\n    const temporaryQuestions = reducers.getTemporaryAnnotations(\n        state,\n        selectedWitness.id,\n        activeAnnotation.start,\n        activeAnnotation.length,\n        ANNOTATION_TYPES.question\n    );\n\n    let questionQuote = null;\n    if (temporaryQuestions.length > 0) {\n        const firstQuestion = temporaryQuestions[0];\n\n        let [start, end] =\n            ownProps.annotatedText.getPositionOfAnnotation(firstQuestion);\n        if (start) {\n            if (!end) {\n                end = start + 1;\n            }\n            const [startText, mainText, endText] =\n                ownProps.annotatedText.segmentedText.extractTextAroundPosition(\n                    start,\n                    end,\n                    [\"།\", \" \"]\n                );\n\n            const linkUrl = document.location.href;\n            questionQuote = (\n                <blockquote>\n                    {startText}\n                    <a href={linkUrl}>{mainText}</a>\n                    {endText}\n                </blockquote>\n            );\n        }\n    }\n    let fontSize = getTextFontSize(state);\n\n    return {\n        annotationsData: variantsData,\n        activeAnnotation: activeAnnotation,\n        baseAnnotation: baseAnnotation,\n        availableAnnotations: annotations,\n        user: user,\n        temporaryAnnotation: temporaryVariant,\n        inline: inline,\n        firstSelectedSegment: ownProps.firstSelectedSegment,\n        splitTextRect: ownProps.splitTextRect,\n        selectedWitness: selectedWitness,\n        notes: notes,\n        temporaryNotes: temporaryNotes,\n        questions: questionAnnotations,\n        temporaryQuestions: temporaryQuestions,\n        questionsData: questionsData,\n        questionQuote: questionQuote,\n        fontSize,\n    };\n};\n\nconst mergeProps = (stateProps: StateProps, dispatchProps, ownProps) => {\n    const { dispatch } = dispatchProps;\n\n    if (stateProps.questions.length > 0) {\n        for (var i = 0; i < stateProps.questions.length; i++) {\n            const question = stateProps.questions[i];\n            let loadQuestionData = true;\n            if (stateProps.questionsData.hasOwnProperty(question.uniqueId)) {\n                if (\n                    stateProps.questionsData[question.uniqueId].questions\n                        .length > 0 ||\n                    stateProps.questionsData[question.uniqueId].loading\n                ) {\n                    loadQuestionData = false;\n                }\n            }\n            if (loadQuestionData) {\n                dispatch(new actions.loadQuestion(question));\n            }\n        }\n    }\n\n    const addBreak = (\n        breakType: string,\n        selectBreak: boolean = false\n    ): (() => void) => {\n        return () => {\n            const location = ownProps.activeAnnotation;\n\n            const breakAnnotation = new Annotation(\n                null,\n                location.witness,\n                location.end + 1,\n                0,\n                null,\n                breakType,\n                stateProps.selectedWitness,\n                stateProps.user\n            );\n            let selectedWitnessData = reducers.dataFromWitness(\n                stateProps.selectedWitness\n            );\n\n            let actionsBatch = [];\n\n            actionsBatch.push(actions.createdAnnotation(breakAnnotation));\n            actionsBatch.push(\n                actions.appliedAnnotation(\n                    breakAnnotation.uniqueId,\n                    selectedWitnessData\n                )\n            );\n            if (selectBreak) {\n                actionsBatch.push(\n                    actions.changedActiveTextAnnotation(breakAnnotation)\n                );\n            } else {\n                actionsBatch.push(actions.changedActiveTextAnnotation(null));\n            }\n\n            dispatch(batchActions(actionsBatch));\n        };\n    };\n\n    const saveAnnotation = (\n        selectedAnnotation: TemporaryAnnotation,\n        content: string\n    ) => {\n        if (!selectedAnnotation.isTemporary) {\n            console.warn(\n                \"Tried to save a non-temporary annotation: %o\",\n                selectedAnnotation\n            );\n            return;\n        }\n\n        let selectedWitness = stateProps.selectedWitness;\n        let selectedWitnessData = reducers.dataFromWitness(selectedWitness);\n\n        const newAnnotation = new Annotation(\n            selectedAnnotation.id,\n            selectedAnnotation.witness,\n            selectedAnnotation.start,\n            selectedAnnotation.length,\n            content,\n            selectedAnnotation.type,\n            selectedAnnotation.creatorWitness,\n            stateProps.user,\n            selectedAnnotation.uniqueId,\n            selectedAnnotation.basedOn\n        );\n        newAnnotation.isSaved = selectedAnnotation.isSaved;\n        let actionsBatch = [];\n        let action = null;\n        if (newAnnotation.isSaved) {\n            action = actions.updatedAnnotation;\n        } else {\n            action = actions.createdAnnotation;\n        }\n        actionsBatch.push(action(newAnnotation));\n        actionsBatch.push(\n            actions.removedTemporaryAnnotation(selectedAnnotation)\n        );\n        // TODO: figure out what needs changing to handle note annotations\n        actionsBatch.push(\n            actions.appliedAnnotation(\n                newAnnotation.uniqueId,\n                selectedWitnessData\n            )\n        );\n        if (newAnnotation.type === ANNOTATION_TYPES.variant) {\n            actionsBatch.push(\n                actions.changedActiveTextAnnotation(newAnnotation)\n            );\n        }\n        dispatch(batchActions(actionsBatch));\n    };\n\n    return {\n        ...stateProps,\n        ...ownProps,\n        closeAnnotation: () => {\n            const activeAnnotation = stateProps.activeAnnotation;\n            if (activeAnnotation) {\n                const dismissTextAnnotation =\n                    actions.changedActiveTextAnnotation(null);\n                dispatch(dismissTextAnnotation);\n            }\n        },\n        didSelectAnnotation: (annotation: Annotation) => {\n            let selectedAnnotation: Annotation | null = null;\n            if (annotation.id == BASE_ANNOTATION_ID) {\n                selectedAnnotation = stateProps.baseAnnotation;\n            } else {\n                selectedAnnotation =\n                    _.find(\n                        stateProps.availableAnnotations,\n                        (value) => value.uniqueId == annotation.uniqueId\n                    ) || null;\n            }\n            let actionsBatch = [];\n            let selectedWitness = stateProps.selectedWitness;\n            // let selectedWitnessData = reducers.getWitnessData(\n            //     state,\n            //     selectedWitness.id\n            // );\n            let selectedWitnessData = reducers.dataFromWitness(selectedWitness);\n\n            if (annotation.uniqueId != stateProps.activeAnnotation.uniqueId) {\n                if (selectedWitness.isWorking) {\n                    if (annotation.id != BASE_ANNOTATION_ID) {\n                        actionsBatch.push(\n                            actions.appliedAnnotation(\n                                selectedAnnotation.uniqueId,\n                                selectedWitnessData\n                            )\n                        );\n                    }\n                    if (stateProps.activeAnnotation.id != BASE_ANNOTATION_ID) {\n                        actionsBatch.push(\n                            actions.removedAppliedAnnotation(\n                                stateProps.activeAnnotation.uniqueId,\n                                selectedWitnessData\n                            )\n                        );\n                    }\n                } else {\n                    if (\n                        stateProps.activeAnnotation.creatorWitness.id ===\n                        selectedWitness.id\n                    ) {\n                        // Replacing a default annotation\n\n                        // Currently selected annotation is a default\n                        // annotation. So need to remove that then\n                        // apply the newly selected annotation.\n\n                        actionsBatch.push(\n                            actions.removedDefaultAnnotation(\n                                stateProps.activeAnnotation.uniqueId,\n                                selectedWitnessData\n                            )\n                        );\n\n                        if (selectedAnnotation.id !== BASE_ANNOTATION_ID) {\n                            actionsBatch.push(\n                                actions.appliedAnnotation(\n                                    selectedAnnotation.uniqueId,\n                                    selectedWitnessData\n                                )\n                            );\n                        }\n                    } else {\n                        if (\n                            selectedAnnotation.creatorWitness.id ===\n                            selectedWitness.id\n                        ) {\n                            actionsBatch.push(\n                                actions.appliedDefaultAnnotation(\n                                    selectedAnnotation.uniqueId,\n                                    selectedWitnessData\n                                )\n                            );\n                        } else if (\n                            selectedAnnotation.id !== BASE_ANNOTATION_ID\n                        ) {\n                            actionsBatch.push(\n                                actions.appliedAnnotation(\n                                    selectedAnnotation.uniqueId,\n                                    selectedWitnessData\n                                )\n                            );\n                        }\n\n                        if (\n                            stateProps.activeAnnotation.id !==\n                            BASE_ANNOTATION_ID\n                        ) {\n                            actionsBatch.push(\n                                actions.removedAppliedAnnotation(\n                                    stateProps.activeAnnotation.uniqueId,\n                                    selectedWitnessData\n                                )\n                            );\n                        }\n                    }\n                }\n\n                actionsBatch.push(\n                    actions.changedActiveTextAnnotation(selectedAnnotation)\n                );\n\n                dispatch(batchActions(actionsBatch));\n            }\n        },\n        editAnnotation: (selectedAnnotation: Annotation) => {\n            const basedOn =\n                selectedAnnotation.isWorkingAnnotation ||\n                selectedAnnotation.userCreated ||\n                selectedAnnotation.id === BASE_ANNOTATION_ID\n                    ? null\n                    : selectedAnnotation;\n            const temporaryAnnotation = new TemporaryAnnotation(\n                basedOn,\n                selectedAnnotation.witness,\n                selectedAnnotation.start,\n                selectedAnnotation.length,\n                selectedAnnotation.content,\n                selectedAnnotation.type,\n                stateProps.selectedWitness,\n                stateProps.user\n            );\n            if (selectedAnnotation.userCreated) {\n                // user annotations are updated\n                temporaryAnnotation.uniqueId = selectedAnnotation.uniqueId;\n                temporaryAnnotation.isSaved = selectedAnnotation.isSaved;\n            }\n\n            dispatch(\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\n            );\n        },\n        saveAnnotation: saveAnnotation,\n        cancelEditAnnotation: (selectedAnnotation: TemporaryAnnotation) => {\n            if (!selectedAnnotation.isTemporary) {\n                console.warn(\n                    \"Tried to call cancelEditAnnotation on a non-temporary annotation: %o\",\n                    selectedAnnotation\n                );\n                return;\n            }\n\n            const cancelAction =\n                actions.removedTemporaryAnnotation(selectedAnnotation);\n            dispatch(cancelAction);\n        },\n        deleteAnnotation: (annotation: Annotation) => {\n            let selectedWitness = stateProps.selectedWitness;\n            let selectedWitnessData = reducers.dataFromWitness(selectedWitness);\n            let actionsBatch = [];\n            if (annotation.userCreated) {\n                const deleteAction = actions.deletedAnnotation(\n                    annotation,\n                    selectedWitness\n                );\n                const removeAppliedAction = actions.removedAppliedAnnotation(\n                    annotation.uniqueId,\n                    selectedWitnessData\n                );\n                actionsBatch = [deleteAction, removeAppliedAction];\n            } else {\n                // Assume this is a default annotation that was\n                // automatically imported from external data\n                const removeDefaultAnnotation =\n                    actions.removedDefaultAnnotation(\n                        annotation.uniqueId,\n                        selectedWitnessData\n                    );\n                actionsBatch = [removeDefaultAnnotation];\n            }\n\n            if (stateProps.activeAnnotation.uniqueId === annotation.uniqueId) {\n                actionsBatch.push(actions.changedActiveTextAnnotation(null));\n            }\n\n            dispatch(batchActions(actionsBatch));\n        },\n        addNote: () => {\n            const activeAnnotation = ownProps.activeAnnotation;\n            const temporaryAnnotation = new TemporaryAnnotation(\n                null,\n                activeAnnotation.witness,\n                activeAnnotation.start,\n                activeAnnotation.length,\n                \"\",\n                ANNOTATION_TYPES.note,\n                stateProps.selectedWitness,\n                stateProps.user\n            );\n\n            dispatch(\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\n            );\n        },\n        editNote: (note: Annotation) => {\n            const temporaryAnnotation = new TemporaryAnnotation(\n                note,\n                note.witness,\n                note.start,\n                note.length,\n                note.content,\n                ANNOTATION_TYPES.note,\n                stateProps.selectedWitness,\n                stateProps.user\n            );\n\n            dispatch(\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\n            );\n        },\n        addPageBreak: addBreak(ANNOTATION_TYPES.pageBreak),\n        addLineBreak: addBreak(ANNOTATION_TYPES.lineBreak),\n        addQuestion: () => {\n            const activeAnnotation = ownProps.activeAnnotation;\n            const temporaryAnnotation = new TemporaryAnnotation(\n                null,\n                activeAnnotation.witness,\n                activeAnnotation.start,\n                activeAnnotation.length,\n                \"\",\n                ANNOTATION_TYPES.question,\n                stateProps.selectedWitness,\n                stateProps.user\n            );\n\n            dispatch(\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\n            );\n        },\n        saveQuestion: (\n            question: TemporaryAnnotation,\n            title: string,\n            content: string\n        ) => {\n            let [start, end] =\n                ownProps.annotatedText.getPositionOfAnnotation(question);\n\n            const questionQuoteText = ReactDOMServer.renderToStaticMarkup(\n                stateProps.questionQuote\n            );\n            let questionText = questionQuoteText + content;\n\n            saveAnnotation(question, content);\n            const createdQuestionAction = actions.createdQuestion(\n                question,\n                title,\n                questionText\n            );\n            dispatch(createdQuestionAction);\n        },\n    };\n};\n\nconst AnnotationControlsContainer = connect(\n    mapStateToProps,\n    null,\n    mergeProps\n)(AnnotationControls);\n\nexport default AnnotationControlsContainer;\n","// @flow\nimport React from \"react\";\nimport Button from \"components/UI/Button\";\nimport styles from \"./AnnotationControlsHeader.css\";\nimport PageBreakIcon from \"images/page_break_icon.svg\";\nimport NoteIcon from \"images/note.svg\";\nimport QuestionIcon from \"images/question_answer.svg\";\n\nimport PencilAltIcon from \"images/PencilAltIcon.svg\";\ntype Props = {\n    addPageBreak: null | (() => void),\n    addLineBreak: null | (() => void),\n    addNote: null | (() => void),\n    addQuestion: null | (() => void),\n    closeAnnotation: null | (() => void),\n    editAnnotationHandler: null | (() => void),\n    userLoggedIn: Boolean,\n};\nconst ICON_SIZE = 15;\nclass AnnotationControlsHeader extends React.Component<Props> {\n    // keyHandler;\n    constructor() {\n        super();\n    }\n    componentDidMount() {\n        this.keyHandler = (evtobj) => {\n            var e = window.event ? event : evtobj;\n            let condition = e.ctrlKey;\n            if (condition && e.keyCode != 67) {\n                evtobj.preventDefault();\n            }\n            if (condition && e.keyCode == 69) {\n                this.props.editAnnotationHandler();\n            }\n            if (condition && e.keyCode == 81) {\n                this.props?.addQuestion();\n            }\n            if (condition && e.keyCode == 76) {\n                this.props?.addLineBreak();\n            }\n            if (condition && e.keyCode == 78) {\n                this.props?.addNote();\n            }\n            if (condition && e.keyCode == 80) {\n                this.props?.addPageBreak();\n            }\n        };\n        document.addEventListener(\"keydown\", this.keyHandler, { once: false });\n    }\n    componentWillUnmount() {\n        document.removeEventListener(\"keydown\", this.keyHandler);\n    }\n    render() {\n        const allowPageBreak = this.props.addPageBreak != null;\n        const allowLineBreak = this.props.addLineBreak != null;\n        return (\n            <>\n                <div className={styles.header}>\n                    <Button\n                        noBezel={true}\n                        icon={\n                            <NoteIcon\n                                width={ICON_SIZE}\n                                height={ICON_SIZE}\n                                style={{ fill: \"#fff\" }}\n                            />\n                        }\n                        backgroundColor=\"transparent\"\n                        // accessoryType={this.props.addNote ? \"ADD\" : null}\n                        onClick={this.props.addNote}\n                        disabled={this.props.addNote ? false : true}\n                        align=\"center\"\n                        tooltipTitle=\"Note\"\n                        shortcut=\"n\"\n                    />\n                    <Button\n                        noBezel={true}\n                        icon={\n                            <QuestionIcon\n                                width={ICON_SIZE}\n                                height={ICON_SIZE}\n                                style={{ fill: \"#fff\" }}\n                            />\n                        }\n                        // accessoryType={this.props.addQuestion ? \"ADD\" : null}\n                        onClick={this.props.addQuestion}\n                        disabled={this.props.addQuestion ? false : true}\n                        align=\"left\"\n                        backgroundColor=\"transparent\"\n                        tooltipTitle=\"Question\"\n                        shortcut=\"q\"\n                    />\n                    <Button\n                        noBezel={true}\n                        color=\"#fff\"\n                        fontSize={`${ICON_SIZE}px`}\n                        icon=\"&#182;\"\n                        // accessoryType={allowLineBreak ? \"ADD\" : null}\n                        onClick={this.props.addLineBreak}\n                        disabled={!allowLineBreak}\n                        align=\"left\"\n                        backgroundColor=\"transparent\"\n                        tooltipTitle=\"LineBreak\"\n                        shortcut=\"l\"\n                    />\n                    <Button\n                        noBezel={true}\n                        icon={\n                            <PageBreakIcon\n                                width={ICON_SIZE}\n                                height={ICON_SIZE}\n                                style={{ fill: \"#fff\" }}\n                            />\n                        }\n                        // accessoryType={allowPageBreak ? \"ADD\" : null}\n                        onClick={this.props.addPageBreak}\n                        disabled={!allowPageBreak}\n                        align=\"left\"\n                        backgroundColor=\"transparent\"\n                        tooltipTitle=\"PageBreak\"\n                        shortcut=\"p\"\n                    />\n\n                    <Button\n                        onClick={this.props.editAnnotationHandler}\n                        // className={styles.edit}\n                        backgroundColor=\"transparent\"\n                        noBezel={true}\n                        icon={\n                            <PencilAltIcon\n                                width={ICON_SIZE}\n                                height={ICON_SIZE}\n                                style={{ fill: \"#fff\" }}\n                            />\n                        }\n                        tooltipTitle=\"Edit\"\n                        shortcut=\"e\"\n                    />\n                </div>\n                {/* <div\n                    onClick={() => this.props.closeAnnotation()}\n                    className={styles.Anotation_closeBtn}\n                >\n                    x\n                </div> */}\n            </>\n        );\n    }\n}\n\nexport default AnnotationControlsHeader;\n","import React from \"react\";\nimport { FormattedMessage } from \"react-intl\";\nimport { injectIntl } from \"react-intl\";\nimport styles from \"./AnnotationControlsHeading.css\";\nimport AddButton from \"./AddButton\";\n\ntype Props = {\n    titleId: string,\n    buttonOnClick?: () => void,\n    buttonTitleId?: string,\n    intl: { formatMessage: ({ [id: string]: string }) => string }\n};\n\nclass AnnotationControlsHeading extends React.Component<Props> {\n    render() {\n        let button = null;\n        if (this.props.buttonOnClick) {\n            const title = this.props.buttonTitleId\n                ? this.props.intl.formatMessage({\n                      id: this.props.buttonTitleId\n                  })\n                : \"\";\n            button = (\n                <AddButton title={title} onClick={this.props.buttonOnClick} />\n            );\n        }\n        return (\n            <h3 className={styles.heading}>\n                <span className={styles.title}>\n                    <FormattedMessage id={this.props.titleId} />\n                </span>\n                {button && <div className={styles.button}>{button}</div>}\n            </h3>\n        );\n    }\n}\n\nexport default injectIntl(AnnotationControlsHeading);\n","// @flow\nimport React, { useState } from \"react\";\nimport classnames from \"classnames\";\nimport { FormattedMessage } from \"react-intl\";\nimport styles from \"./AnnotationDetail.css\";\nimport type { AnnotationData } from \"api\";\nimport CheckIcon from \"images/check_circle.svg\";\nimport colours from \"css/colour.css\";\nimport ApplyTooltip from \"../UI/ApplyTooltip\";\nexport type Props = {\n    annotationData: AnnotationData,\n    isActive: boolean,\n    selectAnnotationHandler: () => void,\n    isLoggedIn: boolean,\n    editAnnotationHandler: () => void,\n    fontSize: Number,\n    isWorkingSection: boolean,\n};\nconst MAXIMUM_TEXT_LENGTH = 250;\n\nconst AnnotationDetail = (props: Props) => {\n    const [imageUrl, setImageUrl] = useState(null);\n\n    function longest_str_in_array(arra) {\n        var max_str = arra[0].length;\n        var ans = arra[0].length;\n        for (var i = 0; i < arra.length; i++) {\n            var maxi = arra[i].length;\n            if (maxi > max_str) {\n                ans = arra[i].length;\n                max_str = maxi;\n            }\n        }\n        return ans;\n    }\n    function mergeArray(arr) {\n        var textCount = arr.length;\n        var maxPerLine = 55;\n\n        for (\n            var i = 0;\n            i < Math.ceil(arr.join().length / maxPerLine) + 1;\n            i++\n        ) {\n            if (arr[i] && arr[i + 1] && arr[i].length < maxPerLine) {\n                arr[i] = arr[i] + \" \" + arr[i + 1];\n                arr.splice(i + 1, 1);\n                mergeArray(arr);\n            } else if (arr[i] && arr[i + 1] && arr[i].length > maxPerLine) {\n                // code to cut selected text should be here\n            }\n        }\n        return arr;\n    }\n\n    let desc = (\n        <p>\n            &lt;\n            <FormattedMessage id=\"annotation.delete\" />\n            &gt;\n        </p>\n    );\n\n    let content = props.annotationData.content;\n\n    if (content.trim() !== \"\") {\n        if (content.length > MAXIMUM_TEXT_LENGTH) {\n            content = content.substr(0, MAXIMUM_TEXT_LENGTH) + \"…\";\n        }\n        // content variable is the selected trimmed context\n        desc = <p>{content}</p>;\n    }\n\n    let classes = [styles.annotationDetail];\n\n    if (props.isActive) {\n        classes.push(styles.active);\n    }\n\n    let className = classnames(...classes);\n    return (\n        <div className={className} onClick={props.selectAnnotationHandler}>\n            <div className={styles.annotationHeader}>\n                {props.isActive && (\n                    <div className={styles.activeIcon}>\n                        <CheckIcon\n                            style={{ fill: colours.activeButton }}\n                            width={15}\n                            height={15}\n                        />\n                    </div>\n                )}\n                <h3>{props.annotationData.name}</h3>\n                {props.isLoggedIn && props.isActive && (\n                    <button\n                        style={{ display: \"none\" }}\n                        className={styles.edit}\n                        onClick={props.editAnnotationHandler}\n                        id=\"editBtn\"\n                    ></button>\n                )}\n            </div>\n\n            {!props.isWorkingSection && desc}\n\n            {/* {props.isWorkingSection  && <ShareButton props={props}/>} */}\n        </div>\n    );\n};\n\nexport default AnnotationDetail;\n","// @flow\nimport React from \"react\";\nimport classnames from \"classnames\";\nimport { FormattedMessage } from \"react-intl\";\nimport styles from \"./AnnotationDetail.css\";\nimport type { Props as AnnotationDetailProps } from \"./AnnotationDetail\";\nimport PencilAltIcon from \"images/PencilAltIcon.svg\";\n\nexport type Props = AnnotationDetailProps & {\n    saveAnnotationHandler: (text: string) => void,\n    cancelAnnotationHandler: () => void,\n};\n\nconst AnnotationDetailEdit = (props: Props) => {\n    let content = props.annotationData.content;\n    let classes = [styles.annotationDetail];\n    let textarea = null;\n\n    if (props.isActive) {\n        classes.push(styles.active);\n    }\n    let auto_grow = (element) => {\n        textarea.style.height = \"5px\";\n        textarea.style.height = textarea.scrollHeight + \"px\";\n    };\n    let className = classnames(...classes);\n    return (\n        <div className={className}>\n            <h3>{props.annotationData.name}</h3>\n\n            <div className={styles.editing}>\n                <textarea\n                    defaultValue={content}\n                    autoFocus={true}\n                    onInput={auto_grow}\n                    ref={(ta) => (textarea = ta)}\n                />\n                <div className={styles.actionButtons}>\n                    <div\n                        className={styles.save}\n                        onClick={() => {\n                            if (textarea) {\n                                props.saveAnnotationHandler(textarea.value);\n                            }\n                        }}\n                    >\n                         <PencilAltIcon\n                         height='12px'\n                         width='12px'\n                                style={{ fill: \"#fff\",marginRight:10 }}\n                            />\n                        <FormattedMessage id=\"annotation.save\" />\n                    </div>\n                    {/* <div\n                        className={styles.cancel}\n                        onClick={props.cancelAnnotationHandler}\n                    >\n                        <FormattedMessage id=\"annotation.cancel\" />\n                    </div> */}\n                </div>\n            </div>\n        </div>\n    );\n};\n\nexport default AnnotationDetailEdit;\n","import React from \"react\";\nimport styles from \"./AnswerView.css\";\nimport controlStyles from \"./AnnotationControls.css\";\nimport buttonStyles from \"./Button.css\";\nimport Annotation from \"lib/Annotation\";\nimport Answer from \"lib/Answer\";\nimport { FormattedMessage, FormattedDate } from \"react-intl\";\nimport classnames from \"classnames\";\n\ntype Props = {\n    answer: Answer\n};\n\nexport default class AnswerView extends React.Component<Props> {\n    render() {\n        return (\n            <div className={styles.answer}>\n                <p\n                    className={controlStyles.text}\n                    dangerouslySetInnerHTML={{\n                        __html: this.props.answer.content\n                    }}\n                />\n                <p className={controlStyles.subTitle}>\n                    <FormattedMessage id=\"question.answeredBy\" />{\" \"}\n                    {this.props.answer.name},{\" \"}\n                    <FormattedDate value={this.props.answer.created} />\n                </p>\n            </div>\n        );\n    }\n}\n","// @flow\nimport * as React from \"react\";\nimport GraphemeSplitter from \"grapheme-splitter\";\nimport reactStringReplace from \"react-string-replace\";\n\ntype Props = {\n    string: string,\n    highlightClass: string,\n    stringClass?: string,\n    searchTerm?: string\n};\n\nexport default class HighlightedString extends React.Component<Props> {\n    constructor(props: Props) {\n        super(props);\n    }\n\n    render() {\n        const string = this.props.string;\n        let nameHtml = string;\n        let stringClass = this.props.stringClass || \"\";\n        if (this.props.searchTerm) {\n            const searchTerm = this.props.searchTerm;\n            const splitter = new GraphemeSplitter();\n            const graphemes = splitter.splitGraphemes(string);\n            const start = string.indexOf(searchTerm);\n            const end = start + searchTerm.length;\n            let position = 0;\n            let foundGraphemes = \"\";\n            if (start > -1) {\n                for (let i = 0; i < graphemes.length; i++) {\n                    let grapheme = graphemes[i];\n                    if (position >= start && position < end) {\n                        foundGraphemes += grapheme;\n                    }\n                    position += grapheme.length;\n                }\n            }\n            if (foundGraphemes.length > 0) {\n                nameHtml = reactStringReplace(\n                    string,\n                    foundGraphemes,\n                    (match, i) => (\n                        <span className={this.props.highlightClass} key={`highlight-${i}`}>\n                            {match}\n                        </span>\n                    )\n                );\n            }\n        }\n        return <span className={stringClass}>{nameHtml}</span>;\n    }\n}\n","import React, { useCallback, useEffect } from \"react\";\nimport RefreshIcon from \"@mui/icons-material/Refresh\";\nimport { IconButton } from \"@mui/material\";\nfunction Refresh({ isSecondWindowOpen }) {\n    const handleRefresh = useCallback(() => {\n        let updatelistBtn = document.getElementById(\"updateList\");\n\n        if (updatelistBtn) updatelistBtn.click();\n    }, [isSecondWindowOpen]);\n\n    useEffect(() => {\n        let timer = setTimeout(() => {\n            handleRefresh();\n        }, 500);\n        return () => clearTimeout(timer);\n    }, [isSecondWindowOpen]);\n\n    return (\n        <IconButton\n            variant=\"text\"\n            size=\"small\"\n            disableRipple\n            onClick={handleRefresh}\n        >\n            <RefreshIcon />\n        </IconButton>\n    );\n}\n\nexport default Refresh;\n","import React from \"react\";\nimport SearchIcon from \"@mui/icons-material/Search\";\nimport { IconButton } from \"@mui/material\";\n\nfunction Search({ handleWindowSearch }) {\n    return (\n        <IconButton size=\"small\" variant=\"text\" onClick={handleWindowSearch}>\n            <SearchIcon />\n        </IconButton>\n    );\n}\n\nexport default Search;\n","import React, { useRef } from \"react\";\nimport {\n    AutoSizer,\n    CellMeasurer,\n    CellMeasurerCache,\n    List,\n} from \"react-virtualized\";\nimport HighlightedString from \"./HighlightedString\";\nimport styles from \"./SearchStyle.css\";\n\nfunction SearchList(props) {\n    const { handleListItemClick, searchValue, results, selectedText } = props;\n    let listRef = useRef();\n    let cache = useRef(\n        new CellMeasurerCache({\n            fixedWidth: true,\n            defaultHeight: 100,\n        })\n    );\n    let rowRenderer = ({ key, index, parent, style }) => {\n        let result = results[index];\n        return (\n            <CellMeasurer\n                key={`listkeys2-${key}`}\n                cache={cache.current}\n                parent={parent}\n                columnIndex={0}\n                rowIndex={index}\n            >\n                <div style={style}>\n                    {results.length > 0 && (\n                        <div\n                            className={styles.searchListItem}\n                            onClick={() => handleListItemClick(result[0])}\n                        >\n                            <HighlightedString\n                                string={result[1]}\n                                highlightClass={styles.highlight}\n                                searchTerm={searchValue}\n                            />\n                        </div>\n                    )}\n                </div>\n            </CellMeasurer>\n        );\n    };\n\n    if (!results) return null;\n    return (\n        <>\n            <AutoSizer>\n                {({ height, width }) => (\n                    <List\n                        ref={listRef}\n                        height={height}\n                        rowCount={results?.length}\n                        rowHeight={cache.current.rowHeight}\n                        deferredMeasurementCache={cache.current}\n                        rowRenderer={rowRenderer}\n                        width={width}\n                        overscanRowCount={1}\n                    ></List>\n                )}\n            </AutoSizer>\n        </>\n    );\n}\n\nexport default SearchList;\n","import React, { useState, useEffect } from \"react\";\nimport WrenchIcon from \"images/wrench.svg\";\nimport Slider from \"../../UI/Slider\";\nimport CheckIcon from \"@mui/icons-material/Check\";\nimport useLocalStorage from \"components/utility/useLocalStorage\";\nimport {\n    IconButton,\n    MenuList,\n    MenuItem,\n    Grow,\n    Divider,\n    Typography,\n    Box,\n    ClickAwayListener,\n} from \"@mui/material\";\nimport { FONT_LIST } from \"app_constants\";\nfunction Settings(props) {\n    let [showOption, setShowOption] = useState(false);\n    let [fontSelect, setFontSelect] = useLocalStorage(\n        \"WindowOneFont\",\n        \"Tibetan\"\n    );\n    useEffect(() => {\n        document.body.style.setProperty(\"--tibetan-fonts\", fontSelect);\n    }, []);\n    const handleClick = () => {\n        setShowOption((prev) => !prev);\n    };\n    const handlefont = (value) => {\n        setFontSelect(value);\n        document.body.style.setProperty(\"--tibetan-fonts\", `${value}`);\n        let update = document.getElementById(\"updateList\");\n\n        setTimeout(() => {\n            update.click();\n        }, 800);\n        setShowOption(false);\n    };\n\n    return (\n        <ClickAwayListener onClickAway={() => setShowOption(false)}>\n            <Box position=\"relative\">\n                <IconButton onClick={handleClick} size=\"small\" variant=\"text\">\n                    <WrenchIcon height={20} width={20} fill=\"currentColor\" />\n                </IconButton>\n                <Grow in={showOption}>\n                    <MenuList\n                        dense\n                        sx={{\n                            position: \"absolute\",\n                            right: 0,\n                            zIndex: 2,\n                            top: 40,\n                            bgcolor: \"heading.main\",\n                        }}\n                    >\n                        <Slider\n                            max={20}\n                            min={7}\n                            initialvalue={props.textFontSize}\n                            changeSize={props.onChangedFontSize}\n                        />\n                        <Divider />\n                        <FontSelection\n                            selectFont={handlefont}\n                            selectedfont={fontSelect}\n                        />\n                        <MenuItem onClick={() => props.onExport()}>\n                            <Typography variant=\"subtitle2\">\n                                Export Document\n                            </Typography>\n                        </MenuItem>\n                    </MenuList>\n                </Grow>\n            </Box>\n        </ClickAwayListener>\n    );\n}\n\nexport default Settings;\n\nconst FontSelection = ({ selectFont, selectedfont }) => {\n    let fontAvailable = FONT_LIST || [];\n\n    return (\n        <Box textAlign={\"center\"}>\n            <span>Font:</span>{\" \"}\n            <select\n                onChange={(e) => selectFont(e.target.value)}\n                value={selectedfont}\n            >\n                {fontAvailable.map((font, index) => {\n                    return (\n                        <option key={index + \"-fontselect\"} value={font}>\n                            {font}\n                        </option>\n                    );\n                })}\n            </select>\n        </Box>\n    );\n};\n","import React from \"react\";\nimport { IconButton } from \"@mui/material\";\nimport MenuIcon from \"@mui/icons-material/Menu\";\nimport ClearIcon from \"@mui/icons-material/Clear\";\nfunction TableOfContent({ changeShowTableContent, showTableContent }) {\n    function handleClick() {\n        changeShowTableContent(!showTableContent);\n    }\n    return (\n        <React.Fragment>\n            <IconButton onClick={handleClick}>\n                {showTableContent ? <ClearIcon /> : <MenuIcon />}\n            </IconButton>\n        </React.Fragment>\n    );\n}\n\nexport default TableOfContent;\n","import React from \"react\";\nimport styles from \"./Note.css\";\nimport Annotation from \"lib/Annotation\";\nimport FormattedDate from \"react-intl\";\nimport { Box, IconButton } from \"@mui/material\";\nimport DeleteIcon from \"@mui/icons-material/Delete\";\ntype Props = {\n    note: Annotation,\n    delete?: (note: Annotation) => void,\n    edit?: (note: Annotation) => void,\n};\n\nexport default class Note extends React.Component<Props> {\n    delete() {\n        if (this.props.delete) {\n            this.props.delete(this.props.note);\n        }\n    }\n\n    edit() {\n        if (this.props.edit) {\n            this.props.edit(this.props.note);\n        }\n    }\n\n    render() {\n        return (\n            <Box className={styles.note} sx={{ boxShadow: 2 }}>\n                <p>Note:</p>\n                <div className={styles.header}>\n                    <h4 className={styles.info}>\n                        {this.props.note.creatorUser.name}\n                    </h4>\n                    {this.props.delete && (\n                        <div\n                            className={styles.delete}\n                            onClick={this.delete.bind(this)}\n                        >\n                            <IconButton aria-label=\"delete\" size=\"small\">\n                                <DeleteIcon fontSize=\"inherit\" />\n                            </IconButton>\n                        </div>\n                    )}\n                </div>\n                <div className={styles.content} onClick={this.edit.bind(this)}>\n                    {this.props.note.content}\n                </div>\n            </Box>\n        );\n    }\n}\n","//@flow\nimport React from \"react\";\nimport Annotation from \"lib/Annotation\";\nimport styles from \"./NoteEditor.css\";\nimport buttonStyles from \"./Button.css\";\nimport { FormattedMessage } from \"react-intl\";\n\ntype Props = {\n    note: Annotation,\n    saveNote: (note: Annotation, content: string) => void,\n    cancel: () => void\n};\n\ntype State = {\n    content: string\n};\n\nexport default class NoteEditor extends React.Component<Props, State> {\n    textarea: HTMLTextAreaElement | null;\n\n    constructor(props: Props) {\n        super(props);\n\n        this.state = {\n            content: props.note.content\n        };\n    }\n\n    save() {\n        const content = this.textarea ? this.textarea.value : \"\";\n        this.props.saveNote(this.props.note, content);\n    }\n\n    cancel() {\n        this.props.cancel();\n    }\n\n    handleChange(e: Event) {\n        const content =\n            e.target instanceof HTMLTextAreaElement ? e.target.value : \"\";\n        this.setState((prevState, props) => {\n            return {\n                content: content\n            };\n        });\n    }\n\n    render() {\n        return (\n            <div className={styles.editorContainer}>\n                <textarea\n                    className={styles.textEditor}\n                    ref={(textarea: HTMLTextAreaElement | null) =>\n                        (this.textarea = textarea)\n                    }\n                    value={this.state.content}\n                    onChange={this.handleChange.bind(this)}\n                />\n                <div className={buttonStyles.buttonContainer}>\n                    <div\n                        className={buttonStyles.save}\n                        onClick={this.save.bind(this)}\n                    >\n                        <FormattedMessage id=\"annotation.save\" />\n                    </div>\n                    <div\n                        className={buttonStyles.cancel}\n                        onClick={this.cancel.bind(this)}\n                    >\n                        <FormattedMessage id=\"annotation.cancel\" />\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n","import React from \"react\";\nimport styles from \"./QuestionEditor.css\";\nimport buttonStyles from \"./Button.css\";\nimport Annotation from \"lib/Annotation\";\nimport { FormattedMessage } from \"react-intl\";\n\ntype Props = {\n    question: Annotation,\n    questionQuote: React.Element<typeof React.Component>,\n    defaultTitle: string,\n    saveQuestion: (\n        question: Annotation,\n        title: string,\n        content: string\n    ) => void,\n    cancel: () => void\n};\n\ntype State = {\n    content: string\n};\n\nexport default class QuestionEditor extends React.Component<Props> {\n    textarea: HTMLTextAreaElement | null;\n\n    constructor(props: Props) {\n        super(props);\n\n        this.state = {\n            content: props.question.content\n        };\n    }\n\n    save() {\n        const content = this.textarea ? this.textarea.value : \"\";\n\n        this.props.saveQuestion(\n            this.props.question,\n            this.props.defaultTitle,\n            content\n        );\n    }\n\n    cancel() {\n        this.props.cancel();\n    }\n\n    handleChange(e: Event) {\n        const content =\n            e.target instanceof HTMLTextAreaElement ? e.target.value : \"\";\n        this.setState((prevState, props) => {\n            return {\n                content: content\n            };\n        });\n    }\n\n    render() {\n        return (\n            <div className={styles.editorContainer}>\n                <div>{this.props.questionQuote}</div>\n                <textarea\n                    className={styles.textEditor}\n                    ref={(textarea: HTMLTextAreaElement | null) =>\n                        (this.textarea = textarea)\n                    }\n                    value={this.state.content}\n                    onChange={this.handleChange.bind(this)}\n                />\n                <div className={buttonStyles.buttonContainer}>\n                    <div\n                        className={buttonStyles.save}\n                        onClick={this.save.bind(this)}\n                    >\n                        <FormattedMessage id=\"annotation.save\" />\n                    </div>\n                    <div\n                        className={buttonStyles.cancel}\n                        onClick={this.cancel.bind(this)}\n                    >\n                        <FormattedMessage id=\"annotation.cancel\" />\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n","import React from \"react\";\nimport styles from \"./QuestionView.css\";\nimport controlStyles from \"./AnnotationControls.css\";\nimport buttonStyles from \"./Button.css\";\nimport Annotation from \"lib/Annotation\";\nimport Question from \"lib/Question\";\nimport AnswerView from \"./AnswerView\";\nimport { FormattedMessage, FormattedDate } from \"react-intl\";\nimport classnames from \"classnames\";\nimport { QUESTION_URL } from \"app_constants\";\nimport { Box } from \"@mui/material\";\n\ntype Props = {\n    question: Question,\n};\n\nexport default class QuestionView extends React.Component<Props> {\n    render() {\n        const topicUrl = QUESTION_URL + this.props.question.topicId;\n        let answerViews = [];\n        let answers = this.props.question.answers;\n        for (let i = 0; i < answers.length; i++) {\n            const answer = answers[i];\n            answerViews.push(\n                <AnswerView answer={answer} key={\"answer_\" + answer.created} />\n            );\n        }\n        const name =\n            this.props.question.name.length > 0\n                ? this.props.question.name\n                : this.props.question.username;\n\n        return (\n            <Box\n                className={classnames(styles.question, controlStyles.padding)}\n                sx={{ boxShadow: 2 }}\n            >\n                <p\n                    className={controlStyles.text}\n                    dangerouslySetInnerHTML={{\n                        __html: this.props.question.content,\n                    }}\n                />\n\n                <span\n                    className={classnames(\n                        styles.threadLink,\n                        controlStyles.text\n                    )}\n                >\n                    <a href={topicUrl} target=\"_blank\">\n                        <FormattedMessage id=\"question.viewThread\" />\n                    </a>\n                </span>\n                <p className={controlStyles.subTitle}>\n                    {name}\n                    <FormattedDate value={this.props.question.created} />\n                </p>\n                {answerViews}\n            </Box>\n        );\n    }\n}\n","import React from \"react\";\nimport classnames from \"classnames\";\nimport styles from \"./QuestionsLoading.css\";\nimport controlStyles from \"./AnnotationControls.css\";\nimport buttonStyles from \"./Button.css\";\nimport { FormattedMessage } from \"react-intl\";\nimport Loader from \"react-loader\";\n\nexport default class QuestionsLoading extends React.Component<Props> {\n    render() {\n        return (\n            <div className={classnames(styles.loading, controlStyles.text)}>\n                <Loader\n                    loaded={false}\n                    scale={0.25}\n                    position=\"relative\"\n                    top=\"50%\"\n                    left=\"50%\"\n                    lines={9}\n                    width={8}\n                    length={8}\n                    radius={14}\n                />\n                Loading questions...\n            </div>\n        );\n    }\n}\n","// @flow\nimport React, { useState, useEffect, memo } from \"react\";\nimport _ from \"lodash\";\nimport classnames from \"classnames\";\nimport { FormattedMessage, injectIntl } from \"react-intl\";\nimport styles from \"./SelectVersion.css\";\nimport Witness from \"lib/Witness\";\nimport { NativeSelect } from \"@mui/material\";\nexport type Props = {\n    witnesses: Witness[],\n    activeWitness: Witness | null,\n    onSelectedWitness: (witness: Witness) => void,\n    user: {},\n};\n\nconst SelectVersion = (props: Props) => {\n    let witnesses = [];\n    let tabName = \"\";\n    let r = \"\";\n    let classes = [];\n    if (props.witnesses && props.activeWitness) {\n        r = props.witnesses.findIndex((l) => l.id === props.activeWitness.id);\n        witnesses = props.witnesses.map((witness) => witness);\n        witnesses.sort((a, b) => {\n            if (a.isWorking) {\n                return -1;\n            }\n            if (b.isWorking) {\n                return 1;\n            }\n            if (a.isBase) {\n                return -1;\n            }\n            if (b.isBase) {\n                return 1;\n            }\n            return 0;\n        });\n        witnesses = witnesses.sort((a, b) => a.id - b.id);\n    }\n\n    const handleChangeWitness = (e) => {\n        if (!_.isEmpty(witnesses)) {\n            props.onSelectedWitness(witnesses[e.target.value]);\n        }\n    };\n\n    if (witnesses.length === 0) return null;\n\n    return (\n        <NativeSelect\n            onChange={handleChangeWitness}\n            className={styles.selectVersion}\n            value={r}\n            label=\"Version\"\n            classes={{\n                root: styles.selectEmpty,\n                select: styles.selectOptions,\n            }}\n        >\n            {witnesses.map((witness, key) => {\n                if (witness.id === props.activeWitness.id)\n                    classes.push(styles.selected);\n                tabName = witness.source.name;\n\n                if (witness.isWorking) {\n                    tabName =\n                        props.intl.locale === \"en\"\n                            ? props.user?.name === \"User\"\n                                ? \"Working\"\n                                : \"My Edition\"\n                            : \"མཉམ་འབྲེལ་པར་མ།\";\n                }\n\n                return (\n                    <option\n                        key={`versionSelect-${key}`}\n                        value={key}\n                        className={styles.selectOptions}\n                    >\n                        {tabName}\n                    </option>\n                );\n            })}\n        </NativeSelect>\n    );\n};\n\nexport default memo(injectIntl(SelectVersion));\n","// @flow\nimport * as React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { AutoSizer } from \"react-virtualized/dist/es/AutoSizer\";\nimport { List } from \"react-virtualized/dist/es/List\";\nimport lopenlinglogo from \"images/lopenling_logo.png\";\nimport {\n    CellMeasurer,\n    CellMeasurerCache,\n} from \"react-virtualized/dist/es/CellMeasurer\";\nimport \"react-virtualized/styles.css\";\nimport Text, {\n    idForSegment,\n    idForDeletedSegment,\n    idForInsertion,\n    idForPageBreak,\n    idForLineBreak,\n} from \"./Text\";\nimport SplitText from \"lib/SplitText\";\nimport SegmentedText from \"lib/SegmentedText\";\nimport shallowEqual from \"lib/shallowEqual\";\nimport { CONTROLS_MARGIN_LEFT } from \"./AnnotationControls\";\nimport AnnotationControlsContainer from \"./AnnotationControlsContainer\";\nimport styles from \"./SplitText.css\";\nimport annotationControlsStyles from \"./AnnotationControls.css\";\nimport controlStyles from \"./AnnotationControls.css\";\nimport _ from \"lodash\";\nimport TextSegment from \"lib/TextSegment\";\nimport Annotation, { ANNOTATION_TYPES } from \"lib/Annotation\";\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\nimport Witness from \"lib/Witness\";\nimport GraphemeSplitter from \"grapheme-splitter\";\nimport { TransformWrapper, TransformComponent } from \"react-zoom-pan-pinch\";\nimport ReactImageZoom from \"react-image-zoom\";\nconst MIN_SPACE_RIGHT =\n    parseInt(controlStyles.inlineWidth) + CONTROLS_MARGIN_LEFT;\n\nconst IMAGE_URL_PREFIX = \"//iiif.bdrc.io/\";\nconst IMAGE_URL_SUFFIX = \"/full/full/0/default.jpg\";\nconst IMAGE_START_PRE_KEY = \"bdrcimg_pre\";\nconst IMAGE_START_NUMBER_KEY = \"bdrcimg_number\";\nconst IMAGE_START_SUFFIX_KEY = \"bdrcimg_suffix\";\n\nlet _searchResultsCache: {\n    [splitTextUniqueId: string]: {\n        [searchTerm: string]: {\n            [index: number]: { [position: number]: [number, number] },\n        },\n    },\n} = {};\nfunction HttpUrl(data = \"\") {\n    if (data.includes(\"https\")) return data;\n    return \"https://\" + data;\n}\nexport type Props = {\n    textListVisible: boolean,\n    editMenuVisible: Boolean,\n    imagesBaseUrl: string,\n    splitText: SplitText,\n    didSelectSegmentIds: (segmentIds: string[]) => void,\n    limitWidth: boolean,\n    activeAnnotation: Annotation | null,\n    selectedAnnotatedSegments: Array<TextSegment | number>,\n    showImages: boolean,\n    annotationPositions: { [string]: Annotation[] },\n    annotations: Annotation[],\n    activeAnnotations: { [AnnotationUniqueId]: Annotation } | null,\n    selectedSegmentId: (segmentId: string) => void,\n    selectedWitness: Witness | null,\n    selectedWitness2: Witness | null,\n    selectedSearchResult: {\n        textId: number,\n        start: number,\n        length: number,\n    } | null,\n    searchValue: string | null,\n    fontSize: number,\n    isSecondWindowOpen: Boolean,\n    changeScrollToId: () => void,\n    changeSyncIdOnClick: () => void,\n    closeAnnotation: () => void,\n    imageData: {},\n    syncIdOnClick: Number,\n    isPanelLinked: Boolean,\n    isPanelVisible: Boolean,\n    textAlignment: {},\n    textAlignmentById: {},\n    selectedWindow: Boolean,\n    scrollToId: Number,\n    selectedTargetRange: [],\n    selectedSourceRange: [],\n    searchResults: [],\n    showTableContent: Boolean,\n    syncIdOnSearch: String,\n    imageAlignmentById: [],\n    changeImageScrollId: () => void,\n    condition: Boolean,\n};\n\nexport default class SplitTextComponent extends React.PureComponent<Props> {\n    isSecondWindowOpen: Boolean;\n    list: List | null;\n    splitText: HTMLDivElement | null;\n    cache: CellMeasurerCache;\n    rowRenderer: (params: {\n        key: string,\n        index: number,\n        parent: {},\n        style: {},\n    }) => React.Element<CellMeasurer>;\n    resizeHandler: () => void;\n    selectionHandler: (e: Event) => void;\n    textListVisible: boolean;\n    editMenuVisible: Boolean;\n    activeSelection: Selection | null;\n    selectedNodes: Node[] | null;\n    // Whether the mouse button is down\n    _mouseDown: boolean;\n    _activeWitness: Witness | null;\n    _didSetInitialScrollPosition: boolean;\n    _filteredSelectedAnnotatedSegments: TextSegment[];\n    _modifyingSelection: boolean;\n    selectedTextIndex: number | null;\n    splitTextRect: ClientRect | null;\n    firstSelectedSegment: TextSegment | null;\n    selectedElementId: string | null;\n    selectedElementIds: string[] | null;\n    imageWidth: number | null;\n    imageHeight: number | null;\n    calculatedImageHeight: number | null;\n    changeScrollToId: () => void;\n    changeImageScrollId: () => void;\n    changeSyncIdOnClick: () => void;\n    wheelScrolling: () => void;\n    closeAnnotation: () => void;\n    textlines: Node[] | null;\n    jump: number;\n    isPanelLinked: Boolean;\n    splitTextRef;\n    textAlignmentById;\n    scrollEvent: () => void;\n    selectedWindow;\n    debouncedScroll;\n    targetId;\n    condition;\n    imageAlignmentById;\n    changeImageScrollId;\n    imageData;\n    constructor(props: Props) {\n        super(props);\n        this.textAlignmentById = [];\n        this.childRef = React.createRef(\"0\");\n        this.list = null;\n        this.splitText = null;\n        this.cache = new CellMeasurerCache({\n            fixedWidth: true,\n        });\n        this.imageAlignmentById = this.props.imageAlignmentById;\n        this.changeImageScrollId = this.props.changeImageScrollId;\n        this.splitTextRef = React.createRef(null);\n        this.rowRenderer = this.rowRenderer.bind(this);\n        this.textListVisible = props.textListVisible;\n        this.editMenuVisible = props.editMenuVisible;\n        this.isPanelLinked = props.isPanelLinked;\n        this.activeSelection = null;\n        this.selectedNodes = null;\n        this._mouseDown = false;\n        this._activeWitness = null;\n        this._didSetInitialScrollPosition = false;\n        this._modifyingSelection = false;\n        this.imageHeight = null;\n        this.imageWidth = null;\n        this.calculatedImageHeight = null;\n        this.processProps(props);\n        this.changeScrollToId = props.changeScrollToId;\n        this.changeSyncIdOnClick = props.changeSyncIdOnClick;\n        this.closeAnnotation = props.closeAnnotation;\n        this.scrollJump = props.scrollJump;\n        this.textAlignmentById = [];\n        this.scrollEvent = this.scrollEvent.bind(this);\n        this.selectedWindow = props.selectedWindow;\n        this.changeImageScrollId = props.changeImageScrollId;\n        this.imageData = props.imageData;\n        this.condition = props.condition;\n    }\n\n    scrollEvent(e) {\n        if (this.selectedWindow === 2) return null;\n        if (this.selectedWindow === 1) {\n            let list = [];\n            let imageIdList = [];\n            this.textAlignmentById.map((l) => {\n                let number = document.getElementById(\"s_\" + l.start);\n                if (number) {\n                    let position = number.getBoundingClientRect();\n                    if (position.top > 102) {\n                        list.push({\n                            id: l.id,\n                            start: l.start,\n                            target: l.TStart,\n                        });\n                    }\n                }\n            });\n            // this.imageAlignmentById.map((l) => {\n            //     let number = document.getElementById(\"s_\" + l?.start);\n            //     if (number) {\n            //         let position = number.getBoundingClientRect();\n            //         if (position.top > 102) {\n            //             imageIdList.push({\n            //                 id: l.id,\n            //                 start: l.start,\n            //                 end: l.end,\n            //             });\n            //         }\n            //     }\n            // });\n            if (!_.isEmpty(list) || !_.isEmpty(imageIdList)) {\n                if (this.selectedWindow === 1) {\n                    this.debouncedScroll(list);\n                }\n            }\n        }\n    }\n\n    updateList(\n        resetCache: boolean = true,\n        resetRows: number | number[] | null = null\n    ) {\n        if (\n            this.props.showImages &&\n            !this.calculatedImageHeight &&\n            this.imageHeight &&\n            this.imageWidth\n        ) {\n            this.calculatedImageHeight = this.calculateImageHeight();\n        }\n        if (this.list) {\n            const list = this.list;\n            if (resetCache) {\n                if (resetRows !== null) {\n                    if (!Array.isArray(resetRows)) {\n                        this.cache.clear(resetRows);\n                    } else if (Array.isArray(resetRows)) {\n                        for (let i = 0; i < resetRows.length; i++) {\n                            let resetRow = resetRows[i];\n                            this.cache.clear(resetRow);\n                        }\n                    }\n                } else {\n                    this.cache.clearAll();\n                    list.measureAllRows();\n                    list.recomputeRowHeights(0);\n                }\n            }\n            list.forceUpdateGrid();\n        }\n    }\n\n    mouseDown() {\n        this._mouseDown = true;\n    }\n\n    mouseUp() {\n        this._mouseDown = false;\n        if (this.activeSelection) {\n            let segmentIds = this.processSelection(this.activeSelection);\n            if (!segmentIds) {\n                segmentIds = [];\n            }\n            this.props.didSelectSegmentIds(segmentIds);\n            this.activeSelection = null;\n        }\n    }\n    handleSelection(e: Event) {\n        if (!this._modifyingSelection) {\n            this.activeSelection = document.getSelection();\n            if (!this._mouseDown) {\n                // sometimes, this gets called after the mouseDown event handler\n                this.mouseUp();\n            }\n        } else {\n            e.stopPropagation();\n            // Need to set this here. If set at callsite, the event will not\n            // have time to propagate.\n            this._modifyingSelection = false;\n        }\n    }\n\n    processSelection(selection: Selection): string[] | null {\n        if (\n            selection.rangeCount === 0 ||\n            selection.isCollapsed ||\n            selection.type === \"Caret\"\n        ) {\n            this.selectedNodes = null;\n            return null;\n        }\n\n        const range = selection.getRangeAt(0);\n        const start = range.startContainer;\n        const startSpan = this.getNodeSegmentSpan(start);\n        if (!(startSpan && startSpan.parentNode)) {\n            // If the selection is not a text segment, ignore.\n            // Assuming if the first node is a non-segment, they\n            // all are.\n            return null;\n        }\n\n        let nodes = this.getRangeNodes(range, startSpan.parentNode);\n        // Check if the selection starts after the end of a node, and\n        // if so remove that node.\n        if (nodes.length > 0) {\n            let firstNode = nodes[0];\n            if (range.startOffset === firstNode.textContent.length) {\n                nodes.shift();\n            }\n        }\n\n        const end = range.endContainer;\n        const endSpan = this.getNodeSegmentSpan(end);\n        if (!(endSpan && endSpan.parentNode)) {\n            return null;\n        }\n        if (endSpan && startSpan.parentNode !== endSpan.parentNode) {\n            // Selection is spanning Texts.\n            // We assume a selection can only run across a maximum\n            // of two Texts.\n            nodes = nodes.concat(this.getRangeNodes(range, endSpan.parentNode));\n        } else {\n            // Check if the selection ends before the start of a node, and\n            // if so remove that node.\n            if (range.endOffset === 0) {\n                nodes.pop();\n            }\n        }\n        this.selectedNodes = nodes;\n        let nodeIds = [];\n        nodes.reduce((accumulator: string[], current: Node) => {\n            if (current instanceof Element) {\n                accumulator.push(current.id);\n            }\n            return accumulator;\n        }, nodeIds);\n        return nodeIds;\n    }\n\n    getNodeSegmentSpan(node: Node): Element | null {\n        let currentNode = node;\n        let span = null;\n        const test = /^(i|s|ds)_/;\n        while (!span && currentNode.parentNode) {\n            if (currentNode instanceof Element && test.test(currentNode.id)) {\n                span = currentNode;\n            }\n            currentNode = currentNode.parentNode;\n        }\n\n        return span;\n    }\n\n    getRangeNodes(range: Range, parentNode: Node): Node[] {\n        let rangeSpans = [];\n        for (let i = 0, len = parentNode.childNodes.length; i < len; i++) {\n            const node = parentNode.childNodes[i];\n            // TODO: add polyfill for i.e.?\n            // e.g. https://gist.github.com/jonathansampson/6d09bd6d2e8c22c53868aec42e66b0f9\n            if (range.intersectsNode(node)) {\n                rangeSpans.push(node);\n            }\n        }\n        return rangeSpans;\n    }\n\n    getControlsMeasurements(props: Props): {\n        selectedTextIndex: number,\n        firstSelectedSegment: TextSegment,\n        selectedElementId: string,\n        splitTextRect: ClientRect,\n        selectedElementIds: string[],\n    } | null {\n        if (!this.splitText) {\n            return null;\n        }\n        let splitTextComponent = this.splitText;\n        let selectedTextIndex = null;\n        let firstSelectedSegment = null;\n        let selectedElementId = null;\n        let splitTextRect = null;\n        let segmentIdFunction: null | ((segment: TextSegment) => string) = null;\n        let selectedElementIds = [];\n        let startPos = 0;\n        if (props.activeAnnotation) {\n            let activeAnnotation = props.activeAnnotation;\n            [startPos] =\n                props.splitText.annotatedText.getPositionOfAnnotation(\n                    activeAnnotation\n                );\n            if (startPos === null) {\n                console.warn(\"No startPos in getControlsMeasurements\");\n                return null;\n            }\n            if (activeAnnotation.type === ANNOTATION_TYPES.pageBreak) {\n                startPos -= 1;\n            }\n            if (activeAnnotation.type === ANNOTATION_TYPES.lineBreak) {\n                startPos -= 1;\n            }\n\n            // Index of text containing end of annotation\n            let positionEnd = startPos + activeAnnotation.length;\n            if (activeAnnotation.length > 0) positionEnd -= 1;\n            selectedTextIndex =\n                // props.splitText.getTextIndexOfPosition(positionEnd);\n                props.splitText.getTextIndexOfPosition(startPos); //to position the control on start of selection\n\n            splitTextRect = splitTextComponent.getBoundingClientRect();\n        }\n        let selectedAnnotatedSegments = [];\n        if (\n            props.selectedAnnotatedSegments &&\n            props.selectedAnnotatedSegments.length > 0\n        ) {\n            selectedAnnotatedSegments = props.selectedAnnotatedSegments;\n            for (let i = 0; i < selectedAnnotatedSegments.length; i++) {\n                let segment = selectedAnnotatedSegments[i];\n                if (\n                    firstSelectedSegment === null &&\n                    segment instanceof TextSegment\n                ) {\n                    firstSelectedSegment = segment;\n                    break;\n                }\n            }\n            if (firstSelectedSegment) {\n                if (\n                    firstSelectedSegment.length === 0 &&\n                    props.activeAnnotation &&\n                    props.activeAnnotation.isInsertion\n                ) {\n                    selectedElementId = idForInsertion(firstSelectedSegment);\n                    segmentIdFunction = idForInsertion;\n                } else {\n                    selectedElementId = idForSegment(firstSelectedSegment);\n                    segmentIdFunction = idForSegment;\n                }\n            }\n        } else if (props.activeAnnotation) {\n            if (props.activeAnnotation.isDeletion) {\n                let segment = new TextSegment(startPos, \"\");\n                selectedElementId = idForDeletedSegment(segment);\n                segmentIdFunction = idForDeletedSegment;\n                firstSelectedSegment = segment;\n                selectedAnnotatedSegments = [firstSelectedSegment];\n            } else if (props.activeAnnotation.isInsertion) {\n                const [start] =\n                    props.splitText.annotatedText.getPositionOfAnnotation(\n                        props.activeAnnotation\n                    );\n                if (start) {\n                    let segment = new TextSegment(start, \"\");\n                    selectedElementId = idForInsertion(segment);\n                    segmentIdFunction = idForInsertion;\n                    firstSelectedSegment = segment;\n                    selectedAnnotatedSegments = [firstSelectedSegment];\n                }\n            } else if (\n                props.activeAnnotation.type === ANNOTATION_TYPES.pageBreak\n            ) {\n                let segment = new TextSegment(startPos + 1, \"\");\n                let prevSegment = new TextSegment(startPos, \"\");\n                selectedElementId = idForPageBreak(prevSegment);\n                firstSelectedSegment = segment;\n                selectedAnnotatedSegments = [segment];\n                selectedElementIds = [selectedElementId];\n            } else if (\n                props.activeAnnotation.type === ANNOTATION_TYPES.lineBreak\n            ) {\n                let segment = new TextSegment(startPos + 1, \"\");\n                let prevSegment = new TextSegment(startPos, \"\");\n                selectedElementId = idForLineBreak(prevSegment);\n                firstSelectedSegment = segment;\n                selectedAnnotatedSegments = [segment];\n                selectedElementIds = [selectedElementId];\n            }\n        }\n        if (segmentIdFunction) {\n            for (let i = 0; i < selectedAnnotatedSegments.length; i++) {\n                let segment = selectedAnnotatedSegments[i];\n                if (segment instanceof TextSegment) {\n                    const segmentId = segmentIdFunction(segment);\n                    selectedElementIds.push(segmentId);\n                }\n            }\n        }\n        if (\n            selectedTextIndex != null &&\n            firstSelectedSegment &&\n            selectedElementId &&\n            splitTextRect\n        ) {\n            return {\n                selectedTextIndex: selectedTextIndex,\n                firstSelectedSegment: firstSelectedSegment,\n                selectedElementId: selectedElementId,\n                splitTextRect: splitTextRect,\n                selectedElementIds: selectedElementIds,\n            };\n        } else {\n            return null;\n        }\n    }\n\n    shouldResetListCache(oldProps: Props, newProps: Props) {\n        let shouldReset = false;\n        if (\n            oldProps.showImages !== newProps.showImages ||\n            this.pageBreaksChanged(oldProps, newProps)\n        ) {\n            shouldReset = true;\n        }\n\n        return shouldReset;\n    }\n\n    pageBreaksChanged(oldProps: Props, newProps: Props) {\n        const oldTextBreaks = oldProps.splitText.getTextsFinalPositions();\n        const newTextBreaks = newProps.splitText.getTextsFinalPositions();\n\n        if (oldTextBreaks.length !== newTextBreaks.length) return true;\n\n        return JSON.stringify(oldTextBreaks) !== JSON.stringify(newTextBreaks);\n    }\n\n    lineBreaksChanges(oldProps: Props, newProps: Props) {\n        let oldActiveAnnotation = oldProps.activeAnnotation;\n        let newActiveAnnotation = newProps.activeAnnotation;\n        let hasChanged = false;\n\n        if (\n            oldActiveAnnotation &&\n            oldActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) &&\n            newProps.activeAnnotations &&\n            !newProps.activeAnnotations.hasOwnProperty(\n                oldActiveAnnotation.uniqueId\n            )\n        ) {\n            hasChanged = true;\n        }\n\n        if (\n            newActiveAnnotation &&\n            newActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) &&\n            oldProps.activeAnnotations &&\n            !oldProps.activeAnnotations.hasOwnProperty(\n                newActiveAnnotation.uniqueId\n            )\n        ) {\n            hasChanged = true;\n        }\n\n        return hasChanged;\n    }\n\n    selectedListRow(props: Props): number | null {\n        let row = null;\n        if (props.activeAnnotation) {\n            row = props.splitText.getTextIndexOfPosition(\n                props.activeAnnotation.start\n            );\n        }\n        return row;\n    }\n\n    processProps(props: Props) {\n        let changedWitness = false;\n        if (\n            !this.props.selectedWitness ||\n            (props.selectedWitness &&\n                props.selectedWitness.id !== this.props.selectedWitness.id)\n        ) {\n            changedWitness = true;\n            this._didSetInitialScrollPosition = false;\n        }\n\n        if (\n            props.selectedSearchResult &&\n            (!this.props.selectedSearchResult ||\n                props.selectedSearchResult.start !==\n                    this.props.selectedSearchResult.start ||\n                props.selectedSearchResult.textId !==\n                    this.props.selectedSearchResult.textId)\n        ) {\n            console.log(\"resetting scroll position from search result\");\n            this._didSetInitialScrollPosition = false;\n        }\n\n        // TODO: check if new selectedSearchResult and if so\n        // set this._didSetInitialScrollPosition = false\n\n        // make sure there's no numbers in selectedAnnotatedSegments\n        // as we want to pass it to Text which only expects TextSegments\n        this._filteredSelectedAnnotatedSegments =\n            props.selectedAnnotatedSegments.reduce(\n                (acc, current: TextSegment | number) => {\n                    if (current instanceof TextSegment) acc.push(current);\n                    return acc;\n                },\n                []\n            );\n\n        const controlsMeasurements = this.getControlsMeasurements(props);\n        if (controlsMeasurements) {\n            this.selectedTextIndex = controlsMeasurements.selectedTextIndex;\n            this.firstSelectedSegment =\n                controlsMeasurements.firstSelectedSegment;\n            this.splitTextRect = controlsMeasurements.splitTextRect;\n            this.selectedElementId = controlsMeasurements.selectedElementId;\n            this.selectedElementIds = controlsMeasurements.selectedElementIds;\n        }\n\n        if (\n            props.textListVisible !== this.textListVisible ||\n            props.editMenuVisible !== this.editMenuVisible\n        ) {\n            setTimeout(() => {\n                this.textListVisible = props.textListVisible;\n                this.editMenuVisible = props.editMenuVisible;\n                this.updateList(true);\n            }, 500);\n        } else {\n            if (changedWitness) {\n                this.updateList(true);\n            } else if (this.pageBreaksChanged(this.props, props)) {\n                let selectedRows = null;\n                let currentSelectedRow = this.selectedListRow(this.props);\n                let newSelectedRow = this.selectedListRow(props);\n                if (currentSelectedRow && newSelectedRow) {\n                    let firstChangedRow =\n                        currentSelectedRow > newSelectedRow\n                            ? newSelectedRow\n                            : currentSelectedRow;\n\n                    let splitRowTexts = this.props.splitText.texts;\n                    selectedRows = [];\n                    for (\n                        let i = firstChangedRow, len = splitRowTexts.length;\n                        i < len;\n                        i++\n                    ) {\n                        selectedRows.push(i);\n                    }\n                }\n                this.updateList(true, selectedRows);\n            } else if (this.lineBreaksChanges(this.props, props)) {\n                let selectedRow = this.selectedListRow(props);\n                if (!selectedRow)\n                    selectedRow = this.selectedListRow(this.props);\n                let splitRowTexts = this.props.splitText.texts;\n                let selectedRows = [];\n                if (selectedRow !== null) {\n                    for (\n                        let i = selectedRow, len = splitRowTexts.length;\n                        i < len;\n                        i++\n                    ) {\n                        selectedRows.push(i);\n                    }\n                    this.updateList(true, selectedRows);\n                }\n            } else if (this.props.fontSize !== props.fontSize) {\n                this.updateList(true);\n            } else if (\n                this.props.activeAnnotation &&\n                props.activeAnnotation &&\n                this.annotationsInSameLocation(\n                    this.props.activeAnnotation,\n                    props.activeAnnotation\n                )\n            ) {\n                this.updateList(true, this.selectedListRow(props));\n            } else {\n                this.updateList(this.shouldResetListCache(this.props, props));\n            }\n        }\n    }\n\n    annotationsInSameLocation(anno1: Annotation, anno2: Annotation): boolean {\n        if (anno1.start === anno2.start && anno1.length === anno2.length) {\n            return true;\n        }\n\n        return false;\n    }\n\n    UNSAFE_componentWillReceiveProps(props: Props) {\n        this.processProps(props);\n    }\n\n    scrollToIndex(selectedTextIndex) {\n        let list = this.list;\n\n        setTimeout(() => {\n            list.scrollToRow(selectedTextIndex);\n            setTimeout(() => {\n                list.scrollToPosition(list.props.scrollTop - 300);\n            }, 0);\n        }, 100);\n    }\n    componentDidMount() {\n        this.resizeHandler = _.throttle(() => {\n            this.calculatedImageHeight = null;\n            this.updateList();\n        }, 600).bind(this);\n        this.debouncedScroll = _.debounce((list) => {\n            if (list.length) {\n                this.changeScrollToId({ id: list[0]?.start, from: 1 });\n            }\n            // if (imagelist.length) {\n            //     this.changeImageScrollId({\n            //         id: {\n            //             start: imagelist[0]?.start,\n            //             end: imagelist[0]?.end,\n            //         },\n            //         from: 1,\n            //     });\n            // }\n        }, 1000);\n\n        window.addEventListener(\"resize\", this.resizeHandler);\n\n        this.selectionHandler = _.debounce((e) => {\n            this.handleSelection(e);\n        }, 200).bind(this);\n\n        document.addEventListener(\"selectionchange\", this.selectionHandler);\n        document.addEventListener(\"mousedown\", this.mouseDown.bind(this), true);\n        document.addEventListener(\"mouseup\", this.mouseUp.bind(this), true);\n        this.processProps(this.props);\n        this.timer = setTimeout(() => {\n            this.resizeHandler();\n        }, 2000);\n        this.splitText.style.scrollBehavior = \"smooth\";\n\n        this.componentDidUpdate();\n    }\n\n    componentDidUpdate(prevProps) {\n        this.imageData = this.props.imageData;\n        if (this.imageData !== prevProps?.imageData) {\n            this.calculatedImageHeight = null;\n\n            this.updateList(true);\n        }\n        let Alignment = this.props.textAlignment;\n        this.imageAlignmentById = this.props.imageAlignmentById;\n        this.SearchSyncId = this.props.syncIdOnSearch || null;\n        this.condition = this.props.condition;\n\n        let scrollToId = this.props.scrollToId;\n        let list = this.list;\n\n        let con =\n            prevProps?.searchResults !== this.props?.searchResults ||\n            prevProps?.syncIdOnSearch !== this.props?.syncIdOnSearch;\n\n        // scroll to word searched using search input\n        if (con && this.props.searchResults) {\n            if (this.SearchSyncId) {\n                let selectedTextIndex =\n                    this.props.splitText.getTextIndexOfPosition(\n                        this.SearchSyncId\n                    );\n                this.scrollToIndex(selectedTextIndex);\n            }\n        }\n\n        this.textAlignmentById = this.props.textAlignmentById;\n        this.selectedWindow = this.props.selectedWindow;\n        this.targetId = this.props.syncIdOnClick;\n\n        if (this.selectedNodes && this.selectedNodes.length > 0) {\n            const selectedNodes = this.selectedNodes;\n            const selectedSegments = this.props.selectedAnnotatedSegments;\n            setTimeout(() => {\n                let selRange = document.createRange();\n                let startNode = selectedNodes[0];\n                let endNode = selectedNodes[selectedNodes.length - 1];\n                let lastSegment = selectedSegments[selectedSegments.length - 1];\n                if (lastSegment instanceof TextSegment) {\n                    let lastElement = document.getElementById(\n                        idForSegment(lastSegment)\n                    );\n                    if (lastElement) endNode = lastElement;\n                }\n\n                if (\n                    startNode instanceof Element &&\n                    endNode instanceof Element\n                ) {\n                    startNode = document.getElementById(startNode.id);\n                    endNode = document.getElementById(endNode.id);\n                    if (startNode && endNode) {\n                        selRange.setStart(startNode, 0);\n                        selRange.setEnd(endNode, endNode.childNodes.length);\n                        let sel = document.getSelection();\n                        if (sel) {\n                            this._modifyingSelection = true;\n                            sel.removeAllRanges();\n                            sel.addRange(selRange);\n                            this.selectedNodes = null;\n                        }\n                    }\n                }\n            }, 0);\n        }\n\n        if (!this._didSetInitialScrollPosition && this.list) {\n            const list = this.list;\n            if (\n                this.props.activeAnnotation ||\n                this.props.selectedSearchResult\n            ) {\n                let selectedTextIndex = this.getSelectedTextIndex();\n                setTimeout(() => {\n                    list.scrollToRow(selectedTextIndex);\n                    // scrollToRow often positions the annotation at the\n                    // bottom of the screen, so scroll up a bit\n                    setTimeout(() => {\n                        list.scrollToPosition(list.props.scrollTop - 300);\n                    }, 0);\n                }, 100);\n            }\n            this._didSetInitialScrollPosition = true;\n        }\n        //Video and audio alignment scrolling\n        if (scrollToId.from == \"video\" && scrollToId.id) {\n            let start = scrollToId.id;\n            let selectedTextIndex =\n                this.props.splitText.getTextIndexOfPosition(start);\n            setTimeout(() => {\n                list.scrollToRow(selectedTextIndex);\n                setTimeout(() => {\n                    list.scrollToPosition(list.props.scrollTop - 300);\n                }, 0);\n            }, 100);\n        }\n\n        // scroll dom with respect to window 2 scrolling\n        if (\n            this.selectedWindow === 2 &&\n            scrollToId.from == 2 &&\n            this.condition &&\n            scrollToId.id !== null\n        ) {\n            this.textAlignmentById = this.props.textAlignmentById || [];\n            if (Alignment) {\n                let req = this.textAlignmentById.find(\n                    (l) => l.TStart === scrollToId.id\n                );\n\n                let start = req?.start;\n                if (start !== null) {\n                    let selectedTextIndex =\n                        this.props.splitText.getTextIndexOfPosition(start);\n                    this.scrollToIndex(selectedTextIndex);\n                }\n            }\n        }\n\n        // scroll dom with respect to window 2 click\n        //for scrolling to the highlighted alignment if its outside visible DOM\n\n        if (\n            this.targetId &&\n            scrollToId.from === \"ua\" &&\n            this.selectedWindow === 2 &&\n            scrollToId.id === \"ua\" &&\n            this.condition\n        ) {\n            let clickIdObj = Alignment.alignment.find(\n                (l) =>\n                    this.targetId >= l.target_segment.start &&\n                    this.targetId < l.target_segment.end\n            );\n            let syncClickTargetId = clickIdObj?.source_segment?.start;\n            let selectedTextIndex =\n                this.props.splitText.getTextIndexOfPosition(syncClickTargetId);\n\n            this.scrollToIndex(selectedTextIndex);\n        }\n    }\n    componentWillUnmount() {\n        document.removeEventListener(\"mousedown\", this);\n        document.removeEventListener(\"mouseup\", this);\n        window.removeEventListener(\"resize\", this.resizeHandler);\n\n        document.removeEventListener(\"selectionchange\", this.selectionHandler);\n        clearTimeout(this.timer);\n    }\n\n    calculateImageHeight() {\n        let height = null;\n        if (this.imageHeight && this.imageWidth) {\n            const ratio = this.imageWidth / this.imageHeight;\n            const pechaImageClass = styles.pechaImage;\n            const pechaImageContainers =\n                document.getElementsByClassName(pechaImageClass);\n            if (pechaImageContainers.length > 0) {\n                let container = pechaImageContainers[0];\n                height = container.offsetWidth / ratio;\n            }\n        }\n        return height;\n    }\n\n    getSelectedTextIndex(): number {\n        let selectedTextIndex = 0;\n        let startPos = null;\n        if (this.props.activeAnnotation) {\n            [startPos] =\n                this.props.splitText.annotatedText.getPositionOfAnnotation(\n                    this.props.activeAnnotation\n                );\n        } else if (this.props.selectedSearchResult) {\n            let segment =\n                this.props.splitText.annotatedText.segmentAtOriginalPosition(\n                    this.props.selectedSearchResult.start\n                );\n            if (segment instanceof TextSegment) {\n                startPos = segment.start;\n            } else if (typeof segment === \"number\") {\n                startPos = segment;\n            }\n        }\n        if (startPos) {\n            selectedTextIndex =\n                this.props.splitText.getTextIndexOfPosition(startPos);\n        }\n        return selectedTextIndex;\n    }\n\n    getBaseAnnotation(annotation: Annotation): Annotation {\n        let [start] =\n            this.props.splitText.annotatedText.getPositionOfAnnotation(\n                annotation\n            );\n        if (start === null) start = 0;\n        return this.props.splitText.annotatedText.getBaseAnnotation(\n            start,\n            annotation.content.length\n        );\n    }\n\n    render() {\n        const props = this.props;\n        const rowRenderer = this.rowRenderer;\n        const cache = this.cache;\n        const key = props.selectedWitness ? props.selectedWitness.id : 0;\n\n        return (\n            <div\n                className={styles.splitText}\n                ref={(div) => (this.splitText = div)}\n                key={key}\n            >\n                <button\n                    id=\"updateList\"\n                    style={{ display: \"none\" }}\n                    onClick={this.resizeHandler}\n                ></button>\n                <AutoSizer disableWidth>\n                    {({ height }) => (\n                        <List\n                            width={1}\n                            ref={(list) => (this.list = list)}\n                            height={height}\n                            rowCount={props.splitText.texts.length}\n                            rowHeight={cache.rowHeight}\n                            rowRenderer={rowRenderer}\n                            overscanRowCount={0}\n                            deferredMeasurementCache={cache}\n                            onScroll={this.scrollEvent}\n                            scrollToAlignment=\"start\"\n                            containerStyle={{\n                                width: \"100%\",\n                                maxWidth: \"100%\",\n                            }}\n                            style={{\n                                width: \"100%\",\n                            }}\n                        ></List>\n                    )}\n                </AutoSizer>\n            </div>\n        );\n    }\n\n    getImageUrl(pageIndex: number): string {\n        if (\n            !this.props.selectedWitness ||\n            !this.props.selectedWitness.properties\n        )\n            return \"\";\n        let witnessProperties = this.props.selectedWitness.properties;\n        let prefix = witnessProperties[IMAGE_START_PRE_KEY];\n        let start = witnessProperties[IMAGE_START_NUMBER_KEY];\n        let suffix = witnessProperties[IMAGE_START_SUFFIX_KEY];\n        let id = Number(start) + pageIndex;\n        let url =\n            IMAGE_URL_PREFIX + prefix + id + \".\" + suffix + IMAGE_URL_SUFFIX;\n        return url;\n    }\n\n    getStringPositions(\n        text: SegmentedText,\n        string: string,\n        index: number\n    ): { [position: number]: [number, number] } {\n        const uniqueId = this.props.splitText.annotatedText.getUniqueId();\n\n        if (!_searchResultsCache.hasOwnProperty(uniqueId)) {\n            _searchResultsCache = {\n                [uniqueId]: {},\n            };\n        }\n\n        if (!_searchResultsCache[uniqueId].hasOwnProperty(string)) {\n            _searchResultsCache[uniqueId] = {\n                [string]: {},\n            };\n        }\n\n        if (_searchResultsCache[uniqueId][string].hasOwnProperty(index)) {\n            return _searchResultsCache[uniqueId][string][index];\n        }\n\n        const splitter = new GraphemeSplitter();\n        const content = text.getText();\n        const firstSegment = text.segments[0];\n        const startingPosition = firstSegment?.start;\n        let positions = [];\n        let position = content.indexOf(string);\n        while (position !== -1) {\n            positions.push(position);\n            position = content.indexOf(string, position + 1);\n        }\n\n        // Position needs to be position in complete text\n        let verifiedPositions: { [position: number]: [number, number] } = {};\n        if (positions.length > 0) {\n            const graphemes = splitter.splitGraphemes(content);\n            let position = 0;\n            let activePosition = null;\n            for (let i = 0; i < graphemes.length; i++) {\n                const grapheme = graphemes[i];\n                const graphemeEnd = position + (grapheme.length - 1);\n                if (activePosition !== null) {\n                    let expectedEnd = activePosition + (string.length - 1);\n                    if (graphemeEnd >= expectedEnd) {\n                        verifiedPositions[activePosition + startingPosition] = [\n                            activePosition + startingPosition,\n                            graphemeEnd + startingPosition,\n                        ];\n                        activePosition = null;\n                    }\n                } else if (positions.indexOf(position) !== -1) {\n                    if (string.length === grapheme.length) {\n                        verifiedPositions[position + startingPosition] = [\n                            position + startingPosition,\n                            graphemeEnd + startingPosition,\n                        ];\n                    } else if (string.length > grapheme.length) {\n                        activePosition = position;\n                    }\n                } else {\n                    activePosition = null;\n                }\n\n                position += grapheme.length;\n            }\n        }\n\n        _searchResultsCache[uniqueId][string][index] = verifiedPositions;\n\n        return verifiedPositions;\n    }\n\n    rowRenderer({\n        key,\n        index,\n        parent,\n        style,\n    }: {\n        key: string,\n        index: number,\n        parent: {},\n        style: {},\n    }): React.Element<CellMeasurer> {\n        const props = this.props;\n        const cache = this.cache;\n        const component = this;\n        const pechaImageClass = props.showImages ? styles.pechaImage : null;\n\n        let imageUrl = \"\";\n        // if (this.imageData?.alignment && props.selectedWitness) {\n        //     imageUrl = HttpUrl(\n        //         this.imageData?.alignment[index]?.target_segment\n        //     );\n        // }\n        if (\n            props.selectedWitness &&\n            props.selectedWitness.properties &&\n            props.selectedWitness.properties.hasOwnProperty(IMAGE_START_PRE_KEY)\n        ) {\n            imageUrl = this.getImageUrl(index);\n        }\n\n        let searchStringPositions = {};\n        let searchValue = this.props.searchValue;\n        if (searchValue && searchValue.length > 0 && props.splitText) {\n            searchStringPositions = this.getStringPositions(\n                props.splitText.texts[index],\n                searchValue,\n                index\n            );\n        }\n\n        let pechaStyles = {};\n\n        if (props.showImages && pechaImageClass && this.calculatedImageHeight) {\n            pechaStyles[\"height\"] = this.calculatedImageHeight + \"px\";\n        }\n        let newStyle = {\n            ...style,\n            height: style.height + 10,\n            cursor: !this.props.isAnnotating ? \"pointer\" : \"text\",\n        };\n        return (\n            <CellMeasurer\n                columnIndex={0}\n                key={key}\n                parent={parent}\n                rowIndex={index}\n                cache={cache}\n            >\n                <div\n                    key={key}\n                    style={newStyle}\n                    className={styles.splitTextRow}\n                    ref={this.splitTextRef}\n                    id={`index_${index}`}\n                >\n                    <div className={styles.splitTextRowContent}>\n                        {props.showImages && (\n                            <div\n                                className={pechaImageClass}\n                                style={pechaStyles}\n                            >\n                                <img\n                                    alt=\"Text related Image\"\n                                    className={styles.image}\n                                    src={imageUrl}\n                                    width=\"100%\"\n                                    height=\"100%\"\n                                    loading=\"lazy\"\n                                    decoding=\"async\"\n                                    onLoad={(e) => {\n                                        if (\n                                            e.target &&\n                                            component.imageWidth === null\n                                        ) {\n                                            component.imageWidth =\n                                                e.target.naturalWidth;\n                                            component.imageHeight =\n                                                e.target.naturalHeight;\n                                            component.calculatedImageHeight =\n                                                null;\n                                            window.setTimeout(\n                                                component.updateList.bind(\n                                                    component\n                                                ),\n                                                0\n                                            );\n                                        }\n                                    }}\n                                />\n                            </div>\n                        )}\n\n                        <Text\n                            ref={this.childRef}\n                            segmentedText={props.splitText.texts[index]}\n                            annotations={props.annotations}\n                            activeAnnotations={props.activeAnnotations}\n                            activeAnnotation={props.activeAnnotation}\n                            row={index}\n                            selectedSegmentId={props.selectedSegmentId}\n                            annotationPositions={props.annotationPositions}\n                            selectedAnnotatedSegments={\n                                this._filteredSelectedAnnotatedSegments\n                            }\n                            getBaseAnnotation={this.getBaseAnnotation.bind(\n                                this\n                            )}\n                            activeWitness={this.props.selectedWitness}\n                            searchValue={searchValue}\n                            selectedSearchResult={\n                                this.props.selectedSearchResult\n                            }\n                            searchStringPositions={searchStringPositions}\n                            fontSize={props.fontSize}\n                            changeSyncIdOnClick={this.props.changeSyncIdOnClick}\n                            changeScrollToId={this.props.changeScrollToId}\n                            textAlignmentById={this.props.textAlignmentById}\n                            selectedSourceRange={this.props.selectedSourceRange}\n                            selectedTargetRange={this.props.selectedTargetRange}\n                            changeSelectedRange={this.props.changeSelectedRange}\n                            condition={this.condition}\n                        />\n                    </div>\n                    {this.props.isAnnotating &&\n                        this.selectedTextIndex === index &&\n                        this.props.activeAnnotation && (\n                            <AnnotationControlsContainer\n                                annotationPositions={props.annotationPositions}\n                                annotatedText={props.splitText.annotatedText}\n                                activeAnnotation={props.activeAnnotation}\n                                inline={true}\n                                firstSelectedSegment={this.firstSelectedSegment}\n                                splitTextRect={this.splitTextRect}\n                                selectedElementId={this.selectedElementId}\n                                pechaImageClass={pechaImageClass}\n                                splitText={props.splitText}\n                                selectedElementIds={this.selectedElementIds}\n                                list={this.list}\n                            />\n                        )}\n                </div>\n            </CellMeasurer>\n        );\n    }\n}\n","import React from \"react\";\nimport { Box, ClickAwayListener, Typography } from \"@mui/material\";\nimport Loader from \"react-loader\";\nimport styles from \"./TableOfContent.css\";\nimport { styled, alpha } from \"@mui/material/styles\";\nimport SearchIcon from \"@mui/icons-material/Search\";\nimport InputBase from \"@mui/material/InputBase\";\nimport Toolbar from \"@mui/material/Toolbar\";\nconst Search = styled(\"div\")(({ theme }) => ({\n    position: \"relative\",\n    borderRadius: theme.shape.borderRadius,\n    backgroundColor: alpha(theme.palette.common.white, 0.15),\n    \"&:hover\": {\n        backgroundColor: alpha(theme.palette.common.white, 0.25),\n    },\n    marginLeft: 0,\n    width: \"100%\",\n    [theme.breakpoints.up(\"sm\")]: {\n        marginLeft: theme.spacing(1),\n        width: \"auto\",\n    },\n}));\n\nconst SearchIconWrapper = styled(\"div\")(({ theme }) => ({\n    padding: theme.spacing(0, 2),\n    height: \"100%\",\n    position: \"absolute\",\n    pointerEvents: \"none\",\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n}));\n\nconst StyledInputBase = styled(InputBase)(({ theme }) => ({\n    color: \"inherit\",\n    \"& .MuiInputBase-input\": {\n        padding: theme.spacing(1, 1, 1, 0),\n        // vertical padding + font size from searchIcon\n        paddingLeft: `calc(1em + ${theme.spacing(4)})`,\n        transition: theme.transitions.create(\"width\"),\n        width: \"100%\",\n        [theme.breakpoints.up(\"sm\")]: {\n            width: \"0\",\n            cursor: \"pointer\",\n            \"&:focus\": {\n                width: \"20ch\",\n            },\n        },\n    },\n}));\n\nfunction TableOfContent() {\n    let data = [\n        { Id: 1, Title: \"chapter 1\", segment_id: 0 },\n        { Id: 2, Title: \"chapter 2\", segment_id: 400 },\n    ];\n    let loaded = data.length > 0 ? true : false;\n\n    return (\n        <Box\n            className={styles.TableContent}\n            sx={{\n                bgcolor: \"heading.main\",\n                color: \"text.primary\",\n                width: \"100%\",\n                height: \"100%\",\n                paddingInline: 2,\n            }}\n        >\n            <Toolbar\n                sx={{\n                    justifyContent: \"space-between\",\n                    paddingLeft: \"0 !important\",\n                    margin: 0,\n                }}\n            >\n                <Typography textTransform={\"uppercase\"} component=\"h6\">\n                    Table Of Content\n                </Typography>\n                <Search>\n                    <SearchIconWrapper>\n                        <SearchIcon />\n                    </SearchIconWrapper>\n                    <StyledInputBase\n                        placeholder=\"Search…\"\n                        inputProps={{ \"aria-label\": \"search\" }}\n                    />\n                </Search>\n            </Toolbar>\n            {/* <Loader loaded={loaded} /> */}\n            <Box>\n                {data.map((list, index) => {\n                    return (\n                        <Box\n                            key={\"TableContent-\" + index}\n                            sx={{\n                                cursor: \"pointer\",\n                                width: \"fit-content\",\n                                \"&:hover\": {\n                                    fontWeight: \"bold\",\n                                },\n                            }}\n                        >\n                            {list.Title}\n                        </Box>\n                    );\n                })}\n            </Box>\n        </Box>\n    );\n}\n\nexport default React.memo(TableOfContent);\n","// @flow\nimport React from \"react\";\nimport classnames from \"classnames\";\nimport styles from \"./Text.css\";\nimport TextSegment from \"lib/TextSegment\";\nimport {\n    INSERTION_KEY,\n    DELETION_KEY,\n    PAGE_BREAK_KEY,\n    LINE_BREAK_KEY,\n} from \"lib/AnnotatedText\";\nimport _ from \"lodash\";\nimport SegmentedText from \"lib/SegmentedText\";\nimport Annotation from \"lib/Annotation\";\nimport Witness from \"lib/Witness\";\nimport { ANNOTATION_TYPES } from \"lib/Annotation\";\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\nimport GraphemeSplitter from \"grapheme-splitter\";\nimport { find } from \"lodash\";\nimport { withTheme } from \"@mui/styles\";\n\nexport function idForSegment(segment: TextSegment): string {\n    return \"s_\" + segment.start;\n}\n\nexport function idForDeletedSegment(segment: TextSegment): string {\n    return \"ds_\" + segment.start;\n}\n\nexport function idForInsertion(segment: TextSegment): string {\n    return \"i_\" + segment.start;\n}\n\nexport function idForPageBreak(segment: TextSegment): string {\n    return \"p_\" + (segment.end + 1);\n}\n\nexport function idForLineBreak(segment: TextSegment): string {\n    return \"l_\" + (segment.end + 1);\n}\n\nexport type Props = {\n    segmentedText: SegmentedText,\n    annotationPositions: { [string]: Annotation[] },\n    selectedSegmentId: (id: string) => void,\n    activeAnnotations: { [AnnotationUniqueId]: Annotation } | null,\n    getBaseAnnotation: (annotation: Annotation) => Annotation,\n    selectedAnnotatedSegments: TextSegment[],\n    row: number,\n    activeAnnotation: Annotation | null,\n    searchValue: string | null,\n    selectedSearchResult: {\n        textId: number,\n        start: number,\n        length: number,\n    } | null,\n    searchStringPositions: { [position: number]: [number, number] },\n    fontSize?: number,\n    activeWitness: Witness,\n    changeSyncIdOnClick: () => void,\n    changeScrollToId: () => void,\n    textAlignmentById: {},\n    selectedSourceRange: [],\n    selectedTargetRange: [],\n};\n\nexport type State = {\n    segmentedText: SegmentedText,\n};\n\nimport ReactDOMServer from \"react-dom/server\";\nimport PageBreakIcon from \"images/page_break_icon.svg\";\nconst PARA_SYMBOL = String.fromCharCode(182);\nconst pageBreakIconString = ReactDOMServer.renderToStaticMarkup(\n    <PageBreakIcon />\n);\nclass Text extends React.Component<Props, State> {\n    _renderedSegments: TextSegment[] | null;\n    _renderedHtml: { __html: string } | null;\n    textAlignmentById;\n    rangeSelect;\n    theme;\n    constructor(props: Props) {\n        super(props);\n        this.textAlignmentById = [];\n        this.state = {\n            segmentedText: props.segmentedText,\n        };\n        this.textAlignmentById = this.props.textAlignmentById;\n        this._renderedSegments = null;\n        this._renderedHtml = null;\n        this.rangeSelect = [];\n        this.theme = props.theme;\n    }\n    UNSAFE_componentWillReceiveProps(nextProps: Props) {\n        this.setState((prevState: State, props: Props) => {\n            return {\n                ...prevState,\n                segmentedText: nextProps.segmentedText,\n            };\n        });\n    }\n\n    annotationsForSegment(segment: TextSegment): Annotation[] {\n        let annotations: Annotation[] = [];\n        const foundAnnotations =\n            this.props.annotationPositions[String(segment.start)];\n        if (foundAnnotations) {\n            annotations = foundAnnotations;\n        }\n        const insertions =\n            this.props.annotationPositions[INSERTION_KEY + segment.start] || [];\n        const deletions =\n            this.props.annotationPositions[DELETION_KEY + segment.start] || [];\n        const pageBreaks =\n            this.props.annotationPositions[\n                PAGE_BREAK_KEY + (segment.end + 1)\n            ] || [];\n        const lineBreaks =\n            this.props.annotationPositions[\n                LINE_BREAK_KEY + (segment.end + 1)\n            ] || [];\n\n        return annotations.concat(\n            insertions,\n            deletions,\n            pageBreaks,\n            lineBreaks\n        );\n    }\n\n    segmentsContainSegment(segments: TextSegment[], segment: TextSegment) {\n        for (let i = 0; i < segments.length; i++) {\n            let listSegment = segments[i];\n            if (\n                listSegment.start === segment.start &&\n                listSegment.text === segment.text\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    selectedElement(element: Element) {\n        if (element.tagName === \"DIV\") {\n            this.props.selectedSegmentId(\"\");\n            return;\n        }\n        let sourceRangeSelection = [];\n        let targetRangeSelection = [];\n        const selection = document.getSelection();\n        var clickId = parseInt(element.id.replace(\"s_\", \"\"));\n        this.props.changeSyncIdOnClick(clickId);\n        if (element?.id.includes(\"s_\") && this.props.condition) {\n            this.props.changeScrollToId({ id: null, from: null });\n\n            let id = parseInt(element.id.replace(\"s_\", \"\"));\n            let rangeUnique = find(\n                this.textAlignmentById,\n                (l) => id >= l.start && id < l.end\n            );\n            if (rangeUnique) {\n                for (let i = rangeUnique.start; i < rangeUnique.end; i++) {\n                    sourceRangeSelection.push(i);\n                }\n                for (let i = rangeUnique.TStart; i < rangeUnique.TEnd; i++) {\n                    targetRangeSelection.push(i);\n                }\n                this.props.changeSelectedRange({\n                    source: sourceRangeSelection,\n                    target: targetRangeSelection,\n                });\n            }\n        }\n\n        if (selection && selection.type === \"Range\") {\n            return;\n        }\n        this.props.selectedSegmentId(element.id);\n\n        if (!element.id) {\n            this.props.changeSelectedRange({ source: [], target: [] });\n        }\n    }\n\n    generateHtml(renderProps: Props, renderState: State): { __html: string } {\n        let segments = renderState.segmentedText.segments;\n\n        let textLineClass = styles.textLine;\n        let segmentHTML = '<p class=\"' + textLineClass + '\">';\n        if (segments.length === 0) return { __html: segmentHTML };\n\n        const insertionClass = styles.insertion;\n        const endPosition = segments[segments.length - 1].end + 1;\n        if (renderProps.annotationPositions[INSERTION_KEY + endPosition]) {\n            const endSegment = new TextSegment(endPosition, \"\");\n            segments.push(endSegment);\n        }\n        if (renderProps.annotationPositions[PAGE_BREAK_KEY + endPosition]) {\n            const endSegment = new TextSegment(endPosition, \"\");\n            segments.push(endSegment);\n        }\n        if (renderProps.annotationPositions[LINE_BREAK_KEY + endPosition]) {\n            const endSegment = new TextSegment(endPosition, \"\");\n            segments.push(endSegment);\n        }\n\n        let activeAnnotations = renderProps.activeAnnotations || {};\n\n        let highlightClass = styles.highlight;\n        let activeHighlightClass = styles.activeHighlight;\n        let activeSearchResultEnd = null;\n        let processedInactiveInsertions = {};\n        for (let i = 0; i < segments.length; i++) {\n            let segment = segments[i];\n            let classAttribute = \"\";\n            let classes = [];\n            let annotations = this.annotationsForSegment(segment);\n            let deletionText = null;\n            let selectedCurrentDeletion = false;\n            let selectedCurrentPageBreak = false;\n            let selectedCurrentLineBreak = false;\n            let lineBreakAnnotation = false;\n            let pageBreakAnnotation = null;\n\n            if (annotations) {\n                let activeInsertions = [];\n                let inactiveInsertions = [];\n                let remainingAnnotations = [];\n                let activeDeletions = [];\n\n                for (let j = 0, len = annotations.length; j < len; j++) {\n                    let annotation = annotations[j];\n                    if (annotation.isInsertion) {\n                        if (annotation.uniqueId in activeAnnotations) {\n                            activeInsertions.push(annotation);\n                        } else {\n                            // Only first inactive insertion at a position will\n                            // be shown, so only process first one.\n                            // TODO: need to check if there is an active insertion\n                            // at the same place. If so, ignore inactive insertion\n                            // as they should be shown in the popover.\n                            const annotationKey = annotation.start;\n                            if (\n                                !processedInactiveInsertions.hasOwnProperty(\n                                    annotationKey\n                                )\n                            ) {\n                                inactiveInsertions.push(annotation);\n                                processedInactiveInsertions[annotationKey] =\n                                    annotation;\n                            }\n                        }\n                    } else {\n                        if (annotation.isDeletion) {\n                            if (annotation.uniqueId in activeAnnotations) {\n                                activeDeletions.push(annotation);\n                            }\n                        } else if (\n                            annotation.type === ANNOTATION_TYPES.pageBreak &&\n                            !renderProps.activeWitness.isWorking\n                        ) {\n                            pageBreakAnnotation = annotation;\n                        } else if (\n                            annotation.type === ANNOTATION_TYPES.lineBreak &&\n                            !renderProps.activeWitness.isWorking\n                        ) {\n                            lineBreakAnnotation = annotation;\n                        } else {\n                            remainingAnnotations.push(annotation);\n                        }\n                    }\n                }\n\n                if (\n                    activeInsertions.length === 0 &&\n                    inactiveInsertions.length > 0\n                ) {\n                    const insertion = inactiveInsertions[0];\n                    const insertionId = idForInsertion(segment);\n                    let insertionClasses = insertionClass;\n                    if (\n                        renderProps.activeAnnotation &&\n                        renderProps.activeAnnotation.isInsertion &&\n                        renderProps.activeAnnotation.start === insertion.start\n                    ) {\n                        insertionClasses += \" \" + styles.selectedAnnotation;\n                    }\n\n                    segmentHTML +=\n                        \"<span id=\" +\n                        insertionId +\n                        \" key=\" +\n                        insertionId +\n                        ' class=\"' +\n                        insertionClasses +\n                        '\">' +\n                        insertion.content +\n                        \"</span>\";\n                }\n\n                if (activeDeletions.length > 0) {\n                    const activeDeletion = activeDeletions[0];\n                    const baseAnnotation =\n                        renderProps.getBaseAnnotation(activeDeletion);\n                    deletionText = baseAnnotation.content;\n                    if (\n                        renderProps.activeAnnotation &&\n                        renderProps.activeAnnotation.isDeletion &&\n                        renderProps.activeAnnotation.start ===\n                            activeDeletion.start &&\n                        renderProps.activeAnnotation.length ===\n                            activeDeletion.length &&\n                        segment.length === 0\n                    ) {\n                        selectedCurrentDeletion = true;\n                    }\n                }\n\n                if (pageBreakAnnotation) {\n                    if (\n                        renderProps.activeAnnotation &&\n                        renderProps.activeAnnotation.uniqueId ===\n                            pageBreakAnnotation.uniqueId\n                    ) {\n                        selectedCurrentPageBreak = true;\n                    }\n                }\n\n                if (lineBreakAnnotation) {\n                    if (\n                        renderProps.activeAnnotation &&\n                        renderProps.activeAnnotation.uniqueId ===\n                            lineBreakAnnotation.uniqueId\n                    ) {\n                        selectedCurrentLineBreak = true;\n                    }\n                }\n                if (\n                    remainingAnnotations.length > 0 ||\n                    activeInsertions.length > 0\n                ) {\n                    classes.push(styles.annotation);\n                }\n            }\n\n            // It's an insertion at the end of the text, which should have just been added to the html.\n            // So break as we don't want anymore segment html adding.\n            if (segment.start === endPosition) {\n                break;\n            }\n\n            let id = null;\n            if (segment.length === 0) {\n                id = idForDeletedSegment(segment);\n                classes.push(styles.removedByAnnotation);\n                if (deletionText) {\n                    segment = new TextSegment(segment.start, deletionText);\n                }\n            } else {\n                id = idForSegment(segment);\n            }\n\n            if (\n                this.segmentsContainSegment(\n                    renderProps.selectedAnnotatedSegments,\n                    segment\n                ) ||\n                selectedCurrentDeletion\n            ) {\n                classes.push(styles.selectedAnnotation);\n            }\n\n            if (\n                renderProps.selectedSourceRange.includes(segment.start) &&\n                renderProps.condition\n            ) {\n                let newClass =\n                    renderProps.theme.palette.mode === \"light\"\n                        ? styles.selectedRangelight\n                        : styles.selectedRangeDark;\n                classes.push(newClass);\n            }\n\n            if (classes.length > 0) {\n                let className = classnames(...classes);\n                classAttribute = 'class=\"' + className + '\"';\n            }\n\n            let segmentContent = segment.text;\n\n            // Add search result highlight if required.\n            if (renderProps.searchStringPositions) {\n                let segmentStart = segment.start;\n                let position = segmentStart;\n                segmentContent = \"\";\n\n                let highlight = highlightClass;\n                if (\n                    renderProps.selectedSearchResult &&\n                    renderProps.selectedSearchResult.start <= position &&\n                    renderProps.selectedSearchResult.start +\n                        renderProps.selectedSearchResult.length >\n                        position\n                ) {\n                    highlight = activeHighlightClass;\n                }\n\n                for (let j = 0; j < segment.text.length; j++) {\n                    let char = segment.text.charAt(j);\n                    position = segmentStart + j;\n                    if (activeSearchResultEnd) {\n                        let [start, end] = activeSearchResultEnd;\n                        if (j === 0) {\n                            segmentContent +=\n                                '<span class=\"' + highlight + '\">';\n                        }\n                        if (position === end) {\n                            segmentContent += char + \"</span>\";\n                            activeSearchResultEnd = null;\n                        } else if (j === segment.text.length - 1) {\n                            segmentContent += char + \"</span>\";\n                        } else {\n                            segmentContent += char;\n                        }\n                    } else if (position in renderProps.searchStringPositions) {\n                        let [start, end] =\n                            renderProps.searchStringPositions[position];\n                        segmentContent +=\n                            '<span class=\"' + highlight + '\">' + char;\n                        if (j === segment.text.length - 1 || position === end) {\n                            segmentContent += \"</span>\";\n                        }\n                        if (position < end) {\n                            activeSearchResultEnd = [start, end];\n                        }\n                    } else {\n                        segmentContent += char;\n                    }\n                }\n            }\n\n            segmentHTML +=\n                \"<span id=\" +\n                id +\n                \" key=\" +\n                id +\n                \" \" +\n                classAttribute +\n                \">\" +\n                segmentContent +\n                \"</span>\";\n\n            if (pageBreakAnnotation) {\n                let pageBreakClasses = [styles.pageBreak];\n                if (selectedCurrentPageBreak) {\n                    pageBreakClasses.push(styles.selectedAnnotation);\n                }\n                const pageBreakClassAttribute =\n                    ' class=\"' + pageBreakClasses.join(\" \") + '\" ';\n                segmentHTML +=\n                    \"<span id=\" +\n                    idForPageBreak(segment) +\n                    \" key=\" +\n                    idForPageBreak(segment) +\n                    pageBreakClassAttribute +\n                    \">\" +\n                    pageBreakIconString +\n                    \"</span>\";\n            }\n            if (lineBreakAnnotation) {\n                let lineBreakClasses = [styles.lineBreak];\n                if (selectedCurrentLineBreak) {\n                    lineBreakClasses.push(styles.selectedAnnotation);\n                }\n                const lineBreakClassAttribute =\n                    ' class=\"' + lineBreakClasses.join(\" \") + '\" ';\n                segmentHTML +=\n                    \"<span id=\" +\n                    idForLineBreak(segment) +\n                    \" key=\" +\n                    idForLineBreak(segment) +\n                    lineBreakClassAttribute +\n                    \">\" +\n                    PARA_SYMBOL +\n                    \"</span>\";\n\n                segmentHTML += '</p><p class=\"' + textLineClass + '\">';\n            }\n        }\n\n        this._renderedSegments = segments;\n\n        segmentHTML += \"</p>\";\n        const html = {\n            __html: segmentHTML,\n        };\n        return html;\n    }\n    shouldComponentUpdate(nextProps: Props, nextState: State) {\n        const renderedHtml = this.generateHtml(nextProps, nextState);\n\n        if (this.props.fontSize !== nextProps.fontSize) {\n            return true;\n        } else if (\n            this._renderedHtml &&\n            renderedHtml.__html === this._renderedHtml.__html\n        ) {\n            return false;\n        } else {\n            this._renderedHtml = renderedHtml;\n            return true;\n        }\n        // return false;\n    }\n    componentDidUpdate() {\n        this.textAlignmentById = this.props.textAlignmentById;\n    }\n\n    render() {\n        let classes = [styles.text];\n        if (this.props.row === 0) {\n            classes.push(styles.textFirstRow);\n        }\n        // Generate HTML manually as it is much faster when\n        // creating large numbers of elements, such as these spans.\n        const html = this._renderedHtml\n            ? this._renderedHtml\n            : this.generateHtml(this.props, this.state);\n        if (!this._renderedHtml) {\n            this._renderedHtml = html;\n        }\n        return (\n            <div className={styles.textContainer}>\n                <div\n                    className={classnames(...classes)}\n                    id=\"text1\"\n                    dangerouslySetInnerHTML={html}\n                    style={{\n                        fontSize: this.props.fontSize,\n                        fontFamily: \"var(--tibetan-fonts)\",\n                    }}\n                    onClick={(e) => {\n                        this.selectedElement(e.target);\n                    }}\n                />\n            </div>\n        );\n    }\n}\n\nexport default withTheme(Text);\n","// @flow\nimport React from \"react\";\nimport classnames from \"classnames\";\nimport imageStyle from \"components/MediaComponent/Image.css\";\nimport Placeholder from \"components/utility/Placeholder\";\nimport Loader from \"react-loader\";\nimport AnnotationControlsContainer from \"./AnnotationControlsContainer\";\nimport SplitText from \"lib/SplitText\";\nimport Annotation from \"lib/Annotation\";\nimport Witness from \"lib/Witness\";\nimport AnnotatedText from \"lib/AnnotatedText\";\nimport lengthSplitter from \"lib/text_splitters/lengthSplitter\";\nimport positionSplitter from \"lib/text_splitters/positionSplitter\";\nimport headerStyles from \"components/Header/Header.css\";\nimport styles from \"./TextDetail.css\";\nimport utilStyles from \"css/util.css\";\nimport type { TextData } from \"api\";\nimport TextSegment from \"lib/TextSegment\";\nimport TextDetailHeadingContainer from \"./TextDetailHeadingContainer\";\nimport { Box, ClickAwayListener, Divider, Slide } from \"@mui/material\";\nimport _ from \"lodash\";\nimport TableOfContent from \"./TableOfContent/TableOfContent\";\n\nimport SplitTextComponent from \"components/TextDetail/SplitText\";\n\nexport type Props = {\n    condition: Boolean,\n    paginated: boolean,\n    pageImagesVisible: boolean,\n    text: TextData | null,\n    loading: boolean,\n    pageBreaks: number[],\n    annotatedText: AnnotatedText,\n    annotations: Annotation[],\n    activeAnnotations: Annotation[],\n    activeAnnotation: Annotation | null,\n    didSelectSegmentIds: (segmentIds: string[]) => void,\n    selectedSegmentId: (segmentId: string) => void,\n    annotationPositions: { [string]: Annotation[] },\n    selectedAnnotatedSegments: Array<TextSegment | number>,\n    textListVisible: boolean,\n    imagesBaseUrl: string,\n    selectedWitness: Witness | null,\n    selectedSearchResult: {\n        textId: number,\n        start: number,\n        length: number,\n    } | null,\n    searchValue: string | null,\n    fontSize: number,\n    isSecondWindowOpen: Boolean,\n    imageData: {},\n    isPanelLinked: boolean,\n    isPanelVisible: Boolean,\n    changeSyncIdOnClick: () => void,\n    changeScrollToId: () => void,\n    changeSelectedImage: () => void,\n    closeAnnotation: () => void,\n    textAlignmentById: {},\n    selectedWindow: Number,\n    changeSelectedWindow: () => void,\n    changeSelectedRange: [],\n    scrollToId: {},\n    selectedSourceRange: [],\n    selectedTargetRange: [],\n    searchResults: [],\n    changeShowTableContent: () => void,\n    showTableContent: Boolean,\n    syncIdOnSearch: String,\n    imageAlignmentById: [],\n    changeImageScrollId: () => void,\n    imageScrollId: {},\n};\n\nlet textDetailId = 0;\n\nclass TextDetail extends React.Component<Props> {\n    key: number;\n    ref;\n    selectedWindow;\n    constructor() {\n        super();\n        this.key = textDetailId++;\n        this.ref = React.createRef();\n        this.selectedWindow = null;\n    }\n\n    mouseEnter() {\n        if (this.selectedWindow === 2 && this.props.text.name)\n            this.props.changeSelectedWindow(1);\n    }\n    componentDidMount() {\n        this.ref.current.addEventListener(\n            \"mouseenter\",\n            this.mouseEnter.bind(this)\n        );\n    }\n    componentDidUpdate() {\n        this.selectedWindow = this.props.selectedWindow;\n    }\n\n    render() {\n        let text = {\n            name: \"\",\n        };\n        if (this.props.text) {\n            text = this.props.text;\n        }\n        let inlineControls = false;\n        let textComponent = null;\n        let splitText = null;\n        if (\n            !this.props.annotatedText ||\n            !this.props.text ||\n            this.props.loading\n        ) {\n            textComponent = (\n                <div key={this.key}>\n                    <Placeholder />\n                </div>\n            );\n        } else {\n            let limitWidth = false;\n            let splitter;\n            if (this.props.paginated) {\n                splitter = positionSplitter(this.props.pageBreaks);\n            } else {\n                splitter = lengthSplitter(1000, /^།[\\s]+(?!།[\\s]+)/, 2, 5);\n            }\n\n            splitText = new SplitText(this.props.annotatedText, splitter);\n\n            inlineControls = true;\n            textComponent = (\n                <SplitTextComponent\n                    splitText={splitText}\n                    annotations={this.props.annotations}\n                    activeAnnotations={this.props.activeAnnotations}\n                    activeAnnotation={this.props.activeAnnotation}\n                    limitWidth={limitWidth}\n                    didSelectSegmentIds={this.props.didSelectSegmentIds}\n                    selectedSegmentId={this.props.selectedSegmentId}\n                    annotationPositions={this.props.annotationPositions}\n                    selectedAnnotatedSegments={\n                        this.props.selectedAnnotatedSegments\n                    }\n                    syncIdOnClick={this.props.syncIdOnClick}\n                    textListVisible={this.props.textListVisible}\n                    showImages={this.props.pageImagesVisible}\n                    // showImages={this.props.selectedMedia.isImageVisible}\n                    imagesBaseUrl={this.props.imagesBaseUrl}\n                    selectedWitness={this.props.selectedWitness}\n                    selectedWitness2={this.props.selectedWitness2}\n                    key={this.key}\n                    selectedSearchResult={this.props.selectedSearchResult}\n                    searchValue={this.props.searchValue}\n                    fontSize={this.props.fontSize}\n                    isSecondWindowOpen={this.props.isSecondWindowOpen}\n                    changeScrollToId={this.props.changeScrollToId}\n                    changeSyncIdOnClick={this.props.changeSyncIdOnClick}\n                    imageData={this.props.imageData}\n                    isPanelLinked={this.props.isPanelLinked}\n                    selectedImage={this.props.selectedImage}\n                    changeSelectedImage={this.props.changeSelectedImage}\n                    isAnnotating={this.props.isAnnotating}\n                    closeAnnotation={this.props.closeAnnotation}\n                    textAlignment={this.props.textAlignment}\n                    textAlignmentById={this.props.textAlignmentById}\n                    isPanelVisible={this.props.isPanelVisible}\n                    scrollToId={this.props.scrollToId}\n                    selectedWindow={this.selectedWindow}\n                    selectedSourceRange={this.props.selectedSourceRange}\n                    selectedTargetRange={this.props.selectedTargetRange}\n                    changeSelectedRange={this.props.changeSelectedRange}\n                    searchResults={this.props.searchResults}\n                    showTableContent={this.props.showTableContent}\n                    selectedText={this.props.text}\n                    syncIdOnSearch={this.props.syncIdOnSearch}\n                    imageAlignmentById={this.props.imageAlignmentById}\n                    changeImageScrollId={this.props.changeImageScrollId}\n                    imageScrollId={this.props.imageScrollId}\n                    condition={this.props.condition}\n                />\n            );\n        }\n        let textComponents = [textComponent];\n        return (\n            <Box\n                sx={{\n                    height: \"100%\",\n                    flex: 1,\n                    bgcolor: \"navbar.main\",\n                    color: \"texts.main\",\n                }}\n                className={classnames(\n                    styles.textDetail,\n                    utilStyles.flex,\n                    utilStyles.flexColumn\n                )}\n                key={this.key}\n                ref={this.ref}\n            >\n                <TextDetailHeadingContainer />\n                <Divider />\n                <Loader loaded={!this.props.loading} zIndex={5} />\n                <Box\n                    style={{\n                        display: \"flex\",\n                        height: \"100%\",\n                        width: \"100%\",\n                        position: \"relative\",\n                    }}\n                >\n                    <Box\n                        className={classnames(\n                            styles.textContainer,\n                            utilStyles.flex\n                        )}\n                    >\n                        {!this.props.loading ? textComponents : <div />}\n                    </Box>\n\n                    <Slide\n                        direction=\"left\"\n                        in={this.props.showTableContent}\n                        container={this.ref.current}\n                        unmountOnExit\n                        mountOnEnter\n                    >\n                        <Box\n                            sx={{\n                                position: \"absolute\",\n                                height: \"100%\",\n                                minWidth: \"50%\",\n                                right: 0,\n                            }}\n                        >\n                            <TableOfContent />\n                        </Box>\n                    </Slide>\n                </Box>\n            </Box>\n        );\n    }\n}\n\nexport default TextDetail;\n","// @flow\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport Annotation, { ANNOTATION_TYPES } from \"lib/Annotation\";\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\nimport Source, { WORKING_VERSION_SOURCE_NAME } from \"lib/Source\";\nimport Witness from \"lib/Witness\";\nimport Text from \"lib/Text\";\nimport TextSegment from \"lib/TextSegment\";\nimport type { AppState } from \"reducers\";\nimport type { AnnotationData, TextData } from \"api\";\nimport {\n    WORKING_VERSION_ANNOTATION_ID,\n    INSERTION_KEY,\n    DELETION_KEY,\n    PAGE_BREAK_KEY,\n    LINE_BREAK_KEY,\n} from \"lib/AnnotatedText\";\nimport TextDetail from \"components/TextDetail\";\nimport {\n    changedActiveAnnotation,\n    changedActiveTextAnnotation,\n    changedWitnessScrollPosition,\n} from \"actions\";\nimport {\n    showPageImages,\n    getAnnotationsForWitnessId,\n    getActiveAnnotationsForWitnessId,\n    getActiveAnnotation,\n    getActiveTextAnnotation,\n    getBaseWitness,\n    getWorkingWitness,\n    getSelectedText,\n    annotationFromData,\n    getAnnotationData,\n    getUser,\n    getTextListVisible,\n    getSelectedTextWitnessId,\n    getTextWitnesses,\n    getWitness,\n    hasLoadedWitnessAnnotations,\n    getRemovedDefaultAnnotationsForWitnessId,\n    hasLoadedWitnessAppliedAnnotations,\n    getScrollPosition,\n    getSelectedSearchResult,\n    getSearchValue,\n    getTextFontSize,\n    isSecondWindowOpen,\n    getImageData,\n    getSelectedImage,\n    isImagePortrait,\n    isPanelVisible,\n    getSelectedSourceRange,\n    getSelectedTargetRange,\n    getSearchResults,\n    getShowTableContent,\n    getImageAlignmentById,\n    getImageScrollId,\n} from \"reducers\";\nimport * as reducers from \"reducers\";\nimport _ from \"lodash\";\n\nimport AnnotatedText from \"lib/AnnotatedText\";\nimport segmentTibetanText from \"lib/segmentTibetanText\";\nimport SegmentedText from \"lib/SegmentedText\";\nimport * as actions from \"actions\";\nimport * as constants from \"app_constants\";\nimport * as TextStore from \"state_helpers/TextStore\";\n\nconst DISMISS_CONTROLS_ON_CLICK = false;\nfunction getInsertionKey(annotation) {\n    return [annotation.start, annotation.length].join(\"-\");\n}\n\nlet _posAnnotatedText;\nlet _posAnnotations;\nlet _positions;\nlet _posVersion;\nconst getAnnotationPositions = (\n    annotatedText: AnnotatedText,\n    annotations: Annotation[]\n): { [string]: Annotation[] } => {\n    if (\n        annotatedText === _posAnnotatedText &&\n        annotations === _posAnnotations &&\n        annotatedText.version === _posVersion\n    ) {\n        return _positions;\n    }\n\n    let positions = {};\n    let activeInsertions = {};\n\n    for (let i = 0; i < annotations.length; i++) {\n        let annotation = annotations[i];\n        let [startPos, length] =\n            annotatedText.getPositionOfAnnotation(annotation);\n        if (startPos == null) {\n            continue;\n        }\n        if (length === 0) {\n            if (annotation.isInsertion) {\n                // group with any active insertions at the same position\n                const activeKey = getInsertionKey(annotation);\n                const activeInsertionPositions = activeInsertions[activeKey];\n                if (activeInsertionPositions) {\n                    activeInsertionPositions.map((pos) =>\n                        positions[pos].push(annotation)\n                    );\n                    continue;\n                }\n                startPos = INSERTION_KEY + startPos;\n            }\n            if (annotation.isDeletion && annotation.length > 0) {\n                // active deletion\n                startPos = DELETION_KEY + startPos;\n            }\n            if (annotation.type === ANNOTATION_TYPES.pageBreak) {\n                startPos = PAGE_BREAK_KEY + startPos;\n            }\n            if (annotation.type === ANNOTATION_TYPES.lineBreak) {\n                startPos = LINE_BREAK_KEY + startPos;\n            }\n            if (positions[startPos] === undefined) {\n                positions[startPos] = [];\n            }\n            if (positions[startPos].indexOf(annotation) === -1) {\n                positions[startPos].push(annotation);\n            }\n        } else {\n            let annotationPositions = [];\n            for (let j = startPos; j < startPos + length; j++) {\n                if (positions[j] === undefined) {\n                    positions[j] = [];\n                }\n                if (positions[j].indexOf(annotation) === -1) {\n                    positions[j].push(annotation);\n                }\n                annotationPositions.push(j);\n            }\n            // Store the positions this annotation is displayed at.\n            // This can then be used later to group with inactive insertions\n            if (annotation.isInsertion) {\n                const key = getInsertionKey(annotation);\n                activeInsertions[key] = annotationPositions;\n            }\n        }\n    }\n\n    _posAnnotatedText = annotatedText;\n    _posAnnotations = annotations;\n    _positions = positions;\n    _posVersion = annotatedText.version;\n    return positions;\n};\n\nlet _selectedWitness = null;\n\nconst mapStateToProps = (state) => {\n    const user = getUser(state);\n    const loading =\n        state.data.loadingWitnesses || state.data.loadingAnnotations;\n    const textListVisible = getTextListVisible(state);\n    const textAlignmentById = reducers.getTextAlignmentById(state);\n\n    if (loading) {\n        return {\n            text: null,\n            witnesses: null,\n            baseWitness: null,\n            annotations: null,\n            loading: loading,\n            paginated: null,\n            pageImagesVisible: true,\n            annotatedText: null,\n            selectedAnnotatedSegments: null,\n            annotationPositions: null,\n            activeAnnotations: null,\n            activeAnnotation: null,\n            user: user,\n            textListVisible,\n            fontSize: constants.DEFAULT_TEXT_FONT_SIZE,\n            textAlignmentById,\n            imageAlignmentById: getImageAlignmentById(state),\n        };\n    }\n\n    const selectedText = getSelectedText(state);\n    let witnesses = {};\n    let workingWitness;\n    let baseWitness;\n    if (selectedText) {\n        workingWitness = getWorkingWitness(state, selectedText.id);\n        baseWitness = getBaseWitness(state, selectedText.id);\n    }\n    let selectedSearchResult = getSelectedSearchResult(state);\n    let annotationPositions = {};\n    let annotations = [];\n    let annotatedText = null;\n    let activeAnnotation = getActiveTextAnnotation(state);\n    let selectedAnnotatedSegments = [];\n    let appliedAnnotations = {};\n    let pageBreaks = [];\n    let imagesBaseUrl = \"\";\n    let selectedWitness;\n    let searchValue = getSearchValue(state);\n    // Whether to show the text's page images\n    let paginated = false;\n    let pageImagesVisible = false;\n    let fontSize = getTextFontSize(state);\n    if (\n        workingWitness &&\n        selectedText &&\n        state.data.witnessAnnotationsById.hasOwnProperty(workingWitness.id)\n    ) {\n        witnesses = getTextWitnesses(state, selectedText.id);\n        let selectedWitnessId = getSelectedTextWitnessId(\n            state,\n            selectedText.id\n        );\n        if (selectedWitnessId) {\n            selectedWitness = getWitness(state, selectedWitnessId);\n        }\n        if (!selectedWitness) {\n            selectedWitness = workingWitness;\n            selectedWitnessId = workingWitness.id;\n        }\n\n        if (selectedWitness.id !== workingWitness.id) {\n            paginated = true;\n            pageImagesVisible = showPageImages(state);\n        }\n\n        annotatedText = TextStore.getWitnessText(state, selectedWitness.id);\n\n        [appliedAnnotations, annotations] = TextStore.getWitnessAnnotations(\n            state,\n            selectedWitness,\n            workingWitness\n        );\n\n        if (annotatedText) {\n            annotationPositions = getAnnotationPositions(\n                annotatedText,\n                (Object.values(annotations): any)\n            );\n        }\n\n        // Get the segments that are part of the current active annotation.\n        // These are used by Text to highlight the currently selected segment.\n        if (activeAnnotation && annotatedText) {\n            // If we've just switched witnesses, make sure we select the\n            // correct part of the text by getting a new annotation.\n            if (\n                !_selectedWitness ||\n                _selectedWitness.id !== selectedWitness.id\n            ) {\n                activeAnnotation = annotatedText.getAnnotation(\n                    activeAnnotation.start,\n                    activeAnnotation.length\n                );\n            }\n            if (activeAnnotation) {\n                selectedAnnotatedSegments =\n                    annotatedText.segmentsForAnnotation(activeAnnotation);\n            }\n        }\n        if (selectedWitness && baseWitness && annotatedText) {\n            let witnessPageBreaks =\n                annotatedText.getAnnotationsOfType(\n                    ANNOTATION_TYPES.pageBreak\n                ) || {};\n            let basePageBreaks = null;\n            if (selectedWitness.id !== baseWitness.id) {\n                basePageBreaks = getAnnotationsForWitnessId(\n                    state,\n                    workingWitness.id,\n                    ANNOTATION_TYPES.pageBreak,\n                    baseWitness.id\n                );\n            }\n\n            pageBreaks = getPageBreaks(witnessPageBreaks, basePageBreaks);\n            for (let i = 0, len = pageBreaks.length; i < len; i++) {\n                let position = pageBreaks[i];\n                let segment = annotatedText.segmentAtOriginalPosition(position);\n                if (segment instanceof TextSegment) {\n                    pageBreaks[i] = segment.start;\n                } else if (segment instanceof Number) {\n                    pageBreaks[i] = segment;\n                }\n            }\n\n            if (paginated) {\n                imagesBaseUrl =\n                    \"/static/images/texts/\" +\n                    selectedText.name +\n                    \"/\" +\n                    selectedWitness.source.name +\n                    \"/\";\n            }\n        }\n    }\n    _selectedWitness = selectedWitness;\n    const scrollToId = reducers.getScrollToId(state);\n    const isPanelLinked = reducers.isPanelLinked(state);\n\n    const textAlignment = reducers.getTextAlignment(state);\n    const syncIdOnClick = reducers.getSyncIdOnClick(state);\n    const selectedWindow = reducers.getSelectedWindow(state);\n    const selectedWitness2 = reducers.getSelectedTextWitness2(state);\n    let Media = reducers.getMediaData(state);\n    const imageData = getImageData(state);\n    const isSecondWindowOpen = reducers.isSecondWindowOpen(state);\n    const condition = reducers.getConditionForAlignment(state);\n    return {\n        text: selectedText,\n        witnesses: witnesses,\n        workingWitness: workingWitness,\n        baseWitness: baseWitness,\n        annotations: annotations,\n        loading: loading,\n        paginated: paginated,\n        pageImagesVisible: pageImagesVisible,\n        annotatedText: annotatedText,\n        selectedAnnotatedSegments: selectedAnnotatedSegments,\n        annotationPositions: annotationPositions,\n        activeAnnotations: { ...appliedAnnotations },\n        activeAnnotation: activeAnnotation,\n        pageBreaks: pageBreaks,\n        imagesBaseUrl: imagesBaseUrl,\n        user: user,\n        textListVisible,\n        selectedWitness,\n        selectedSearchResult,\n        searchValue,\n        fontSize,\n        isSecondWindowOpen,\n        imageData,\n        selectedImage: getSelectedImage(state),\n        isImagePortrait: isImagePortrait(state),\n        isAnnotating: reducers.isAnnotating(state),\n        textAlignment,\n        textAlignmentById,\n        scrollToId,\n        syncIdOnClick,\n        selectedWindow,\n        selectedSourceRange: getSelectedSourceRange(state),\n        selectedTargetRange: getSelectedTargetRange(state),\n        searchResults: getSearchResults(state, searchValue),\n        showTableContent: getShowTableContent(state),\n        syncIdOnSearch: reducers.getSyncIdOnSearch(state),\n        imageAlignmentById: getImageAlignmentById(state),\n        imageScrollId: getImageScrollId(state),\n        selectedMedia: Media,\n        condition: condition && isPanelLinked && isSecondWindowOpen,\n    };\n};\n\nconst mergeProps = (stateProps, dispatchProps, ownProps) => {\n    const { dispatch } = dispatchProps;\n    const { annotatedText, annotationPositions } = stateProps;\n\n    const didSelectSegmentPosition = (segmentPosition, start, length) => {\n        let segmentAnnotations = annotationPositions[segmentPosition];\n        let segmentVariants = [];\n        let segmentPageBreaks = [];\n        let segmentLineBreaks = [];\n        if (segmentAnnotations) {\n            segmentVariants = segmentAnnotations.filter(\n                (annotation: Annotation) =>\n                    annotation.type === ANNOTATION_TYPES.variant\n            );\n            segmentPageBreaks = segmentAnnotations.filter(\n                (annotation: Annotation) =>\n                    annotation.type === ANNOTATION_TYPES.pageBreak\n            );\n            segmentLineBreaks = segmentAnnotations.filter(\n                (annotation: Annotation) =>\n                    annotation.type === ANNOTATION_TYPES.lineBreak\n            );\n        }\n        let activeAnnotations = _.intersectionWith(\n            segmentVariants.concat(segmentPageBreaks, segmentLineBreaks),\n            annotatedText.annotations,\n            (a, b) => a.toString() == b.toString()\n        );\n        let activeAnnotation = null;\n        if (activeAnnotations.length > 0) {\n            // get any active annotations\n            activeAnnotation = activeAnnotations[0];\n        } else if (segmentVariants && segmentVariants.length > 0) {\n            // get base text annotation for longest annotation highlighted in text\n            let longestAvailable = getLongestAnnotation(segmentVariants);\n            let [start, textLength] =\n                annotatedText.getPositionOfAnnotation(longestAvailable);\n            if (longestAvailable && longestAvailable.isInsertion) {\n                textLength = 0;\n            }\n            activeAnnotation = annotatedText.getBaseAnnotation(\n                start,\n                textLength\n            );\n        } else {\n            // get base annotation of just the segment\n            activeAnnotation = annotatedText.getBaseAnnotation(start, length);\n        }\n\n        dispatch(changedActiveTextAnnotation(activeAnnotation));\n    };\n\n    const isInsertion = (id) => {\n        return id.indexOf(\"i_\") !== -1;\n    };\n\n    const isDeletion = (id) => {\n        return id.indexOf(\"ds_\") !== -1;\n    };\n\n    const isPageBreak = (id) => {\n        return id.indexOf(\"p_\") !== -1;\n    };\n\n    const isLineBreak = (id) => {\n        return id.indexOf(\"l_\") !== -1;\n    };\n\n    const idFromSegmentId = (id) => {\n        let start = 0;\n        if (isInsertion(id)) {\n            start = id.substr(2);\n        } else if (isDeletion(id)) {\n            start = id.substr(3);\n        } else {\n            start = id.substr(2);\n        }\n\n        return start;\n    };\n\n    return {\n        ...stateProps,\n        ...ownProps,\n        didSelectSegmentIds: (segmentIds) => {\n            if (segmentIds.length === 0) {\n                return;\n            }\n            let segmentAnnotations = [];\n            let segments = [];\n            for (let segmentId of segmentIds) {\n                if (isDeletion(segmentId) || isInsertion(segmentId)) {\n                    continue;\n                }\n\n                let segmentPosition = idFromSegmentId(segmentId);\n                let textSegment =\n                    annotatedText.segmentedText.segmentAtPosition(\n                        segmentPosition\n                    );\n                segments.push(textSegment);\n                const annotations = annotationPositions[textSegment.start];\n                if (annotations) {\n                    segmentAnnotations = segmentAnnotations.concat(annotations);\n                }\n            }\n            segmentAnnotations = _.uniqWith(\n                segmentAnnotations,\n                (a, b) => a.toString() == b.toString()\n            );\n\n            let activeAnnotations = _.intersectionWith(\n                segmentAnnotations,\n                annotatedText.annotations,\n                (a, b) => a.toString() == b.toString()\n            );\n\n            const range = getSegmentsRange(\n                segments,\n                activeAnnotations,\n                segmentAnnotations,\n                stateProps.annotatedText\n            );\n            if (!range) {\n                console.warn(\n                    \"No range for selected segment ids: %o\",\n                    segmentIds\n                );\n                return;\n            }\n            const baseAnnotation = annotatedText.getBaseAnnotation(\n                range.start,\n                range.length\n            );\n            let activeAnnotation = null;\n            if (range.annotation) {\n                activeAnnotation = range.annotation;\n            } else if (activeAnnotations.length > 0) {\n                const content = annotatedText.segmentedText\n                    .segmentsInRange(range.start, range.length)\n                    .reduce((content, segment) => content + segment.text, \"\");\n                // TODO: test this when editing non-working edition.\n                // Check if getTextWorkingWitness works as required\n                if (!stateProps.selectedWitness) {\n                    console.log(\n                        \"no stateProps.selectedWitness: %o\",\n                        stateProps.selectedWitness\n                    );\n                }\n                activeAnnotation = new Annotation(\n                    WORKING_VERSION_ANNOTATION_ID,\n                    getTextWorkingWitness(stateProps.text),\n                    baseAnnotation.start,\n                    baseAnnotation.length,\n                    content,\n                    ANNOTATION_TYPES.variant,\n                    stateProps.selectedWitness,\n                    stateProps.user\n                );\n            } else {\n                activeAnnotation = baseAnnotation;\n            }\n            dispatch(changedActiveTextAnnotation(activeAnnotation));\n        },\n        selectedSegmentId: (segmentId) => {\n            let start = idFromSegmentId(segmentId);\n            let positionKey = start;\n            if (isInsertion(segmentId)) {\n                positionKey = INSERTION_KEY + start;\n            } else if (isDeletion(segmentId)) {\n                positionKey = DELETION_KEY + start;\n            } else if (isPageBreak(segmentId)) {\n                positionKey = PAGE_BREAK_KEY + start;\n            } else if (isLineBreak(segmentId)) {\n                positionKey = LINE_BREAK_KEY + start;\n            }\n\n            let segmentAnnotations = annotationPositions[positionKey];\n            if (\n                (DISMISS_CONTROLS_ON_CLICK && stateProps.activeAnnotation) ||\n                segmentId === \"\"\n            ) {\n                const activeAnnotation = stateProps.activeAnnotation;\n\n                if (activeAnnotation) {\n                    const dismissTextAnnotation =\n                        actions.changedActiveTextAnnotation(null);\n                    dispatch(dismissTextAnnotation);\n                }\n            } else {\n                if (\n                    isInsertion(segmentId) ||\n                    isDeletion(segmentId) ||\n                    isPageBreak(segmentId) ||\n                    isLineBreak(segmentId)\n                ) {\n                    const length = 0;\n                    didSelectSegmentPosition(positionKey, start, length);\n                } else {\n                    let segmentPosition = Number(idFromSegmentId(segmentId));\n                    let textSegment =\n                        annotatedText.segmentedText.segmentAtPosition(\n                            segmentPosition\n                        );\n                    if (textSegment) {\n                        didSelectSegmentPosition(\n                            textSegment.start,\n                            textSegment.start,\n                            textSegment.length\n                        );\n                    }\n                }\n            }\n        },\n        changeScrollToId: (payload) =>\n            dispatch(actions.changeScrollToId(payload)),\n        changeSyncIdOnClick: (payload) =>\n            dispatch(actions.changeSyncIdOnClick(payload)),\n        changeSelectedImage: (payload) => {\n            dispatch(actions.selectImage(payload));\n        },\n        changeSelectedWindow: (payload) => {\n            dispatch(actions.changeSelectedWindow(payload));\n        },\n        changeSelectedRange: (payload) => {\n            dispatch(actions.changeSelectedRange(payload));\n        },\n        changeShowTableContent: (payload) => {\n            dispatch(actions.showTableContent(payload));\n        },\n        closeAnnotation: () => {\n            const dismissTextAnnotation =\n                actions.changedActiveTextAnnotation(null);\n            dispatch(dismissTextAnnotation);\n        },\n        changeImageScrollId: (data) => {\n            dispatch(actions.changeImageScrollId(data));\n        },\n    };\n};\n\nconst getPageBreaks = (\n    witnessPageBreaks: { [AnnotationUniqueId]: Annotation },\n    basePageBreaks: { [AnnotationUniqueId]: AnnotationData } | null\n): number[] => {\n    let witnessStarts = [];\n    _.forIn(witnessPageBreaks, (o) => witnessStarts.push(o.start));\n    witnessStarts = witnessStarts.sort((a, b) => a - b);\n\n    if (!basePageBreaks) {\n        return witnessStarts;\n    }\n\n    let baseStarts = [];\n    _.forIn(basePageBreaks, (o) => baseStarts.push(o.start));\n    baseStarts = baseStarts.sort((a, b) => a - b);\n\n    if (witnessStarts.length === 0) {\n        return baseStarts;\n    }\n\n    // Only add page breaks if witness has < 90% of base witness breaks.\n    // Editions often have differing numbers of words per page so can't\n    // be 100%.\n    const threshold = 0.9;\n    if (witnessStarts.length / baseStarts.length < threshold) {\n        let lastWitnessPageStart = witnessStarts[witnessStarts.length - 1];\n        for (let i = 0, len = baseStarts.length; i < len; i++) {\n            let start = baseStarts[i];\n            if (start > lastWitnessPageStart) witnessStarts.push(start);\n        }\n    }\n    console.log(witnessStarts);\n    return witnessStarts;\n};\n\nconst getTextWorkingWitness = (textData: TextData): Witness => {\n    const source = new Source(\n        WORKING_VERSION_ANNOTATION_ID,\n        WORKING_VERSION_SOURCE_NAME\n    );\n    const text = new Text(textData.id, textData.name);\n    const witness = new Witness(\n        WORKING_VERSION_ANNOTATION_ID,\n        text,\n        source,\n        \"\",\n        false\n    );\n\n    return witness;\n};\n\nconst getSegmentsRange = (\n    segments: TextSegment[],\n    activeAnnotations: Annotation[],\n    annotations: Annotation[],\n    annotatedText: AnnotatedText\n): { start: number, length: number, annotation: Annotation | null } | null => {\n    if (segments.length === 0) {\n        return null;\n    }\n    let first = segments[0];\n    let last = segments[segments.length - 1];\n\n    let start = first.start;\n    let end = last.end;\n\n    let startAnnotation = null;\n    let endAnnotation = null;\n    for (let i = 0; i < annotations.length; i++) {\n        const annotation = annotations[i];\n        let annotationStart,\n            annotationLength,\n            annotationEnd = null;\n        [annotationStart, annotationLength] =\n            annotatedText.getPositionOfAnnotation(annotation);\n\n        if (activeAnnotations.indexOf(annotation) !== -1) {\n            if (annotationStart && annotationStart < start) {\n                start = annotationStart;\n                startAnnotation = annotation;\n            }\n\n            annotationEnd = annotationStart + annotationLength - 1;\n\n            if (annotationEnd && annotationEnd > end) {\n                end = annotationEnd;\n                endAnnotation = annotationEnd;\n            }\n        } else {\n            // For inactive annotions - we want to select the whole\n            // length of text the annotation refers to.\n            annotationEnd = annotationStart + annotationLength - 1;\n            if (annotationEnd > end) {\n                end = annotationEnd;\n            }\n        }\n    }\n\n    // Set if the whole range is encompassed by a single annotation\n    let rangeAnnotation = null;\n    if (startAnnotation && endAnnotation && startAnnotation === endAnnotation) {\n        rangeAnnotation = startAnnotation;\n    }\n\n    return {\n        start: start,\n        length: end - start + 1,\n        annotation: rangeAnnotation,\n    };\n};\n\nconst getLongestAnnotation = (annotations: Annotation[]): Annotation | null => {\n    let longest = null;\n    for (let i = 0; i < annotations.length; i++) {\n        let annotation = annotations[i];\n        if (!longest) {\n            longest = annotation;\n        } else {\n            if (annotation.length > longest.length) {\n                longest = annotation;\n            }\n        }\n    }\n    return longest;\n};\n\nconst TextDetailContainer = connect(\n    mapStateToProps,\n    null,\n    mergeProps\n)(TextDetail);\n\nexport default React.memo(TextDetailContainer);\n","import React, {\n    useState,\n    useRef,\n    useCallback,\n    useEffect,\n    useMemo,\n} from \"react\";\nimport styles from \"./TextDetailHeading.css\";\nimport SelectVersion from \"./SelectVersion\";\nimport _ from \"lodash\";\nimport TextList from \"./TextListContainer\";\nimport CloseIcon from \"@mui/icons-material/Close\";\nimport {\n    Stack,\n    Box,\n    TextField,\n    Button,\n    Collapse,\n    Divider,\n    ButtonGroup,\n    IconButton,\n} from \"@mui/material\";\nimport Refresh from \"./HeaderMenu/Refresh\";\nimport Search from \"./HeaderMenu/Search\";\nimport Settings from \"./HeaderMenu/Settings\";\nimport TableOfContent from \"./HeaderMenu/TableOfContent\";\nimport SearchList from \"./HeaderMenu/SearchList\";\n\ntype HeaderProps = {\n    selectedText: {},\n    witnesses: Witness[],\n    selectedWitness: Witness,\n    onSelectedWitness: () => void,\n    user: User,\n    activeLocale: string,\n    accountOverlayVisible: boolean,\n    navigationButtonClicked: () => void,\n    menuButtonClicked: () => void,\n    textFontSize: Number,\n    onChangedFontSize: () => void,\n    onChangeWindowOpen: () => void,\n    isSecondWindowOpen: boolean,\n    changeIsAnnotating: () => void,\n    isAnnotating: Boolean,\n    searchChanged: () => void,\n    searchValue: String,\n    changeShowTableContent: () => void,\n    searchResults: [],\n};\n\nfunction TextDetailHeading(props: HeaderProps) {\n    const [findvalue, setfindvalue] = useState(\"\");\n    let [showFind, setShowFind] = useState(false);\n    let [visible, setVisible] = useState(false);\n    const headingRef = useRef();\n    const inputRef = useRef();\n    const handleListItemClick = (id) => {\n        props.changeSelectSyncId(id);\n    };\n    const debouncedSearch = React.useRef(\n        _.debounce((s) => {\n            props.searchChanged(s);\n        }, 1000)\n    ).current;\n    const handleSearch = useCallback(\n        (e) => {\n            e.preventDefault();\n            debouncedSearch(findvalue);\n            setVisible(true);\n        },\n        [findvalue]\n    );\n    const handleWindowSearch = useCallback(() => {\n        if (showFind === false) debouncedSearch(null);\n        setShowFind(!showFind);\n    }, [showFind]);\n\n    useEffect(() => {\n        if (showFind === true) {\n            inputRef.current.focus();\n        }\n        if (showFind === false) debouncedSearch(null);\n    }, [showFind]);\n\n    const closeSearchItemBox = useCallback(() => {\n        setVisible(false);\n        debouncedSearch(null);\n        setfindvalue(\"\");\n    }, []);\n\n    let condition = useMemo(\n        () =>\n            _.isObject(props.searchResults) &&\n            props.searchResults.hasOwnProperty(props.selectedText.id),\n        [props.searchResults, props.selectedText]\n    );\n    let results = condition\n        ? props.searchResults[props.selectedText.id].results\n        : [];\n    return (\n        <Stack\n            ref={headingRef}\n            direction=\"column\"\n            spacing={1}\n            sx={{\n                paddingInline: { md: 1, xs: 0 },\n                paddingBlock: { md: 1, xs: 0 },\n                bgcolor: \"heading.main\",\n                color: \"text.primary\",\n            }}\n        >\n            <Stack direction=\"row\" spacing={1} justifyContent=\"space-between\">\n                <Box\n                    sx={{\n                        display: \"flex\",\n                        gap: { md: 2, sx: 0 },\n                        flexDirection: { md: \"row\", xs: \"column\" },\n                    }}\n                >\n                    <TextList />\n                    <SelectVersion\n                        witnesses={props.witnesses}\n                        activeWitness={props.selectedWitness}\n                        onSelectedWitness={props.onSelectedWitness}\n                        user={props.user}\n                    />\n                </Box>\n\n                <ButtonGroup\n                    size=\"small\"\n                    sx={{\n                        position: \"relative\",\n                        display: \"flex\",\n                        height: \"fit-content\",\n                        alignItems: \"center\",\n                        justifyContent: \"center\",\n                        width: \"fit-content\",\n                        border: (theme) => `1px solid ${theme.palette.divider}`,\n                        borderRadius: 1,\n                        bgcolor: \"background.paper\",\n                        color: \"text.secondary\",\n                        \"& svg\": {\n                            m: 1,\n                        },\n                        \"& hr\": {\n                            mx: 0.5,\n                        },\n                    }}\n                    className={styles.button_group_menu}\n                >\n                    <Refresh isSecondWindowOpen={props.isSecondWindowOpen} />\n                    <Divider orientation=\"vertical\" variant=\"middle\" flexItem />\n                    <Search handleWindowSearch={handleWindowSearch} />\n                    <Settings\n                        textFontSize={props.textFontSize}\n                        onChangedFontSize={props.onChangedFontSize}\n                        onExport={props.onExport}\n                    />\n                    <TableOfContent\n                        changeShowTableContent={props.changeShowTableContent}\n                        showTableContent={props.showTableContent}\n                    />\n                </ButtonGroup>\n            </Stack>\n\n            <Collapse in={showFind} mountOnEnter unmountOnExit>\n                <form onSubmit={handleSearch}>\n                    <Stack direction=\"row\" spacing={2} position=\"relative\">\n                        <TextField\n                            hiddenLabel\n                            id=\"filled-hidden-label-small\"\n                            inputProps={{\n                                style: {\n                                    height: 25,\n                                    padding: \"0 14px\",\n                                },\n                            }}\n                            style={{ height: 25, flex: 1 }}\n                            fullWidth\n                            inputRef={inputRef}\n                            value={findvalue}\n                            onChange={(e) => setfindvalue(e.target.value)}\n                        />\n\n                        <Button\n                            variant=\"outlined\"\n                            size=\"small\"\n                            onClick={handleSearch}\n                            style={{ height: 25 }}\n                        >\n                            Search\n                        </Button>\n\n                        {props.searchResults && visible && (\n                            <Box\n                                sx={{\n                                    position: \"absolute\",\n                                    top: 35,\n                                    right: 0,\n                                    zIndex: 1,\n                                    bgcolor: \"heading.main\",\n                                    height: 350,\n                                    width: 350,\n                                    boxShadow: 3,\n                                    overflowX: \"hidden\",\n                                    boxShadow: 3,\n                                    display:\n                                        results.length === 0 ? \"none\" : \"block\",\n                                }}\n                            >\n                                {condition && results.length > 0 && (\n                                    <SearchList\n                                        handleListItemClick={\n                                            handleListItemClick\n                                        }\n                                        searchValue={props.searchValue}\n                                        results={results}\n                                        selectedText={props.selectedText}\n                                    />\n                                )}\n                                <IconButton\n                                    aria-label=\"closeButton\"\n                                    onClick={closeSearchItemBox}\n                                    size=\"small\"\n                                    sx={{\n                                        right: 15,\n                                        top: 0,\n                                        position: \"absolute\",\n                                    }}\n                                >\n                                    <CloseIcon fontSize=\"inherit\" />\n                                </IconButton>\n                            </Box>\n                        )}\n                    </Stack>\n                </form>\n            </Collapse>\n        </Stack>\n    );\n}\n\nexport default React.memo(TextDetailHeading);\n","// @flow\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport TextDetailHeading from \"./TextDetailHeading\";\nimport * as actions from \"actions\";\nimport * as reducers from \"reducers\";\nimport type { AppState } from \"reducers\";\n\nconst mapStateToProps = (state: AppState): {} => {\n    const selectedText = reducers.getSelectedText(state);\n    const selectedText2 = reducers.getSelectedText2(state);\n    let witnesses = [];\n    let exportingWitness = false;\n    let selectedWitness;\n    let selectedWitness2;\n\n    if (selectedText) {\n        witnesses = reducers.getTextWitnesses(state, selectedText.id);\n        const selectedWitnessId = reducers.getSelectedTextWitnessId(\n            state,\n            selectedText.id\n        );\n        if (selectedWitnessId) {\n            selectedWitness = reducers.getWitness(state, selectedWitnessId);\n            exportingWitness = reducers.getExportingWitness(\n                state,\n                selectedWitnessId\n            );\n        } else {\n            selectedWitness = reducers.getWorkingWitness(\n                state,\n                selectedText.id\n            );\n        }\n    }\n\n    if (selectedText2) {\n        // witnesses = reducers.getTextWitnesses(state, selectedText2.id);\n        const selectedWitnessId2 = reducers.getSelectedTextWitnessId2(\n            state,\n            selectedText2.id\n        );\n        if (selectedWitnessId2) {\n            selectedWitness2 = reducers.getWitness2(state, selectedWitnessId2);\n        } else {\n            selectedWitness2 = reducers.getWorkingWitness2(\n                state,\n                selectedText2.id\n            );\n        }\n    }\n\n    let textFontSize = reducers.getTextFontSize(state);\n    let searchValue = reducers.getSearchValue(state);\n    return {\n        witnesses,\n        selectedText,\n        selectedText2,\n        selectedWitness,\n        selectedWitness2,\n        textFontSize,\n        exportingWitness,\n        searchValue,\n        showTableContent: reducers.getShowTableContent(state),\n        searchResults: reducers.getSearchResults(state, searchValue),\n    };\n};\n\nconst mergeProps = (stateProps, dispatchProps, ownProps) => {\n    const navigationButtonClicked = () => {\n        dispatchProps.dispatch(\n            actions.changedTextListVisible(!stateProps.textListIsVisible)\n        );\n    };\n\n    const { dispatch } = dispatchProps;\n    const { selectedText } = stateProps;\n\n    return {\n        ...ownProps,\n        ...stateProps,\n        navigationButtonClicked,\n        onSelectedWitness: (witness: Witness) => {\n            dispatch(\n                actions.selectedTextWitness(selectedText?.id, witness?.id)\n            );\n        },\n        onChangedFontSize: (fontSize: number) => {\n            dispatch(actions.changedTextFontSize(fontSize));\n        },\n        onChangeWindowOpen: (data: boolean, textId) => {\n            dispatch(actions.toggleSecondWindow(data, textId));\n        },\n        onExport: () => {\n            dispatch(\n                actions.exportWitness(stateProps.selectedWitness.id, \"docx\")\n            );\n        },\n        navigationButtonClicked: () => {\n            dispatch(\n                actions.changedTextListVisible(!stateProps.textListIsVisible)\n            );\n        },\n\n        changeIsAnnotating: (payload) => {\n            dispatch(actions.changeIsAnnotating(payload));\n            if (payload === false) {\n                const dismissTextAnnotation =\n                    actions.changedActiveTextAnnotation(null);\n                dispatch(dismissTextAnnotation);\n                dispatch(actions.changedActiveTextAnnotation(null));\n            }\n        },\n        searchChanged: (searchTerm: string) => {\n            dispatch(actions.changedSearchValue(searchTerm));\n        },\n        changeShowTableContent: (payload) => {\n            dispatch(actions.showTableContent(payload));\n        },\n        changeSelectSyncId: (payload) => {\n            dispatch(actions.changeSyncIdOnSearch(payload));\n        },\n    };\n};\n\nconst TextDetailHeadingContainer = connect(\n    mapStateToProps,\n    null,\n    mergeProps\n)(TextDetailHeading);\n\nexport default TextDetailHeadingContainer;\n","import React, {\n    useState,\n    useRef,\n    useCallback,\n    useMemo,\n    useEffect,\n} from \"react\";\nimport {\n    List,\n    AutoSizer,\n    CellMeasurer,\n    CellMeasurerCache,\n} from \"react-virtualized\";\nimport classname from \"classnames\";\nimport styles from \"./TextList.css\";\nimport {\n    TextField,\n    ClickAwayListener,\n    Box,\n    Typography,\n    Button,\n    Grow,\n} from \"@mui/material\";\nimport addShay from \"lib/addTibetanShay\";\nimport { filter } from \"lodash\";\nfunction TextList(props) {\n    const temptext = useRef(props.texts);\n    const [textslist, setTextList] = useState(temptext.current);\n    const [filterValue, setFilterValue] = useState(null);\n    const onSelectedText = props.onSelectedText;\n    const selectedText = props.selectedText;\n    const [isOpen, setIsOpen] = useState(false);\n\n    let selected = selectedText?.name;\n    const cache = useRef(\n        new CellMeasurerCache({\n            fixedHeight: true,\n            defaultHeight: 40,\n        })\n    );\n\n    let classes = [styles.textlist];\n    useEffect(() => {\n        let temp = [];\n        if (filterValue === \"\") {\n            setTextList([...temptext.current]);\n        }\n        if (filterValue !== null && filterValue !== \"\") {\n            temp = temptext.current.filter((val) => {\n                return val.name.includes(filterValue);\n            });\n            setTextList([...temp]);\n        }\n    }, [filterValue]);\n\n    const handleClick = () => {\n        setIsOpen((prev) => !prev);\n        if (isOpen === false) classes.push(styles.open);\n    };\n    const handleChange = (e) => {\n        let value = e.target.value;\n        setFilterValue(value);\n    };\n\n    const rowRenderer = React.useCallback(\n        ({ key, index, style, parent }) => {\n            let data = textslist[index];\n            return (\n                <CellMeasurer\n                    key={`optionvalues-${key}`}\n                    cache={cache.current}\n                    parent={parent}\n                    columnIndex={0}\n                    rowIndex={index}\n                >\n                    <div\n                        style={style}\n                        onClick={() => {\n                            setIsOpen(false);\n                            onSelectedText(data);\n                        }}\n                    >\n                        <Box\n                            sx={{\n                                overflow: \"hidden\",\n                                textOverflow: \"ellipsis\",\n                                width: \"13rem\",\n                                paddingLeft: 2,\n                                fontSize: {\n                                    lg: 12,\n                                    md: 11,\n                                    sm: 10,\n                                    xs: 10,\n                                },\n                                color: \"text.primary\",\n                            }}\n                            component=\"div\"\n                        >\n                            <Typography noWrap={true}>\n                                {addShay(data.name)}\n                            </Typography>\n                        </Box>\n                    </div>\n                </CellMeasurer>\n            );\n        },\n        [textslist]\n    );\n    return (\n        <ClickAwayListener onClickAway={() => setIsOpen(false)}>\n            <div style={{ position: \"relative\", marginLeft: 10 }}>\n                <Button\n                    onClick={handleClick}\n                    component=\"div\"\n                    variant=\"outlined\"\n                    sx={{\n                        textOverflow: \"ellipsis\",\n                        width: \"10rem\",\n                        height: \"100%\",\n                        color: \"text.primary\",\n                    }}\n                >\n                    <Typography noWrap={true}>\n                        {selected ? selected : \"select Text here\"}\n                    </Typography>\n                </Button>\n\n                <Grow in={isOpen}>\n                    <Box\n                        className={classname(classes)}\n                        sx={{\n                            position: \"absolute\",\n                            bgcolor: \"heading.main\",\n                            zIndex: 1,\n                        }}\n                    >\n                        <TextField\n                            onChange={handleChange}\n                            id=\"standard-basic\"\n                            label=\"Search\"\n                            variant=\"standard\"\n                            style={{ width: \"100%\" }}\n                        />\n                        <AutoSizer>\n                            {({ width, height }) => (\n                                <List\n                                    width={width}\n                                    height={height}\n                                    rowHeight={30}\n                                    deferredMeasurementCache={cache.current}\n                                    rowCount={textslist.length}\n                                    rowRenderer={rowRenderer}\n                                />\n                            )}\n                        </AutoSizer>\n                    </Box>\n                </Grow>\n            </div>\n        </ClickAwayListener>\n    );\n}\n\nexport default React.memo(TextList);\n","// @flow\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport TextList from \"./TextList\";\nimport * as actions from \"actions\";\nimport { getSelectedText } from \"reducers\";\nimport type { AppState } from \"reducers\";\nimport * as api from \"api\";\nimport * as reducers from \"reducers\";\nimport { batchActions } from \"redux-batched-actions\";\nimport { reduce } from \"lodash\";\n\nconst mapStateToProps = (state: AppState) => {\n    // TODO: display search results or spinner depending on when anything\n    // returned\n    let texts = reducers.getTexts(state);\n    let selectedText = reducers.getSelectedText(state);\n    return {\n        texts,\n        selectedText,\n    };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n    return {\n        onSelectedText: (text: api.TextData) => {\n            dispatch(actions.selectedText(text));\n        },\n    };\n};\n\nconst TextListContainer = connect(\n    mapStateToProps,\n    mapDispatchToProps\n)(TextList);\n\nexport default React.memo(TextListContainer);\n","// @flow\nimport * as React from \"react\";\nimport GraphemeSplitter from \"grapheme-splitter\";\nimport reactStringReplace from \"react-string-replace\";\n\ntype Props = {\n    string: string,\n    highlightClass: string,\n    stringClass?: string,\n    searchTerm?: string\n};\n\nexport default class HighlightedString extends React.Component<Props> {\n    constructor(props: Props) {\n        super(props);\n    }\n\n    render() {\n        const string = this.props.string;\n        let nameHtml = string;\n        let stringClass = this.props.stringClass || \"\";\n        if (this.props.searchTerm) {\n            const searchTerm = this.props.searchTerm;\n            const splitter = new GraphemeSplitter();\n            const graphemes = splitter.splitGraphemes(string);\n            const start = string.indexOf(searchTerm);\n            const end = start + searchTerm.length;\n            let position = 0;\n            let foundGraphemes = \"\";\n            if (start > -1) {\n                for (let i = 0; i < graphemes.length; i++) {\n                    let grapheme = graphemes[i];\n                    if (position >= start && position < end) {\n                        foundGraphemes += grapheme;\n                    }\n                    position += grapheme.length;\n                }\n            }\n            if (foundGraphemes.length > 0) {\n                nameHtml = reactStringReplace(\n                    string,\n                    foundGraphemes,\n                    (match, i) => (\n                        <span className={this.props.highlightClass} key={`highlight-${i}`}>\n                            {match}\n                        </span>\n                    )\n                );\n            }\n        }\n        return <span className={stringClass}>{nameHtml}</span>;\n    }\n}\n","import React, { useCallback, useEffect } from \"react\";\nimport RefreshIcon from \"@mui/icons-material/Refresh\";\nimport { IconButton } from \"@mui/material\";\nfunction Refresh({ isSecondWindowOpen }) {\n    const handleRefresh = useCallback(() => {\n        let updatelistBtn2 = document.getElementById(\"updateList2\");\n\n        if (updatelistBtn2) updatelistBtn2.click();\n    }, [isSecondWindowOpen]);\n\n    useEffect(() => {\n        let timer = setTimeout(() => {\n            handleRefresh();\n        }, 500);\n        return () => clearTimeout(timer);\n    }, [isSecondWindowOpen]);\n\n    return (\n        <IconButton variant=\"text\" size=\"small\" onClick={handleRefresh}>\n            <RefreshIcon />\n        </IconButton>\n    );\n}\n\nexport default Refresh;\n","import React from \"react\";\nimport SearchIcon from \"@mui/icons-material/Search\";\nimport { IconButton } from \"@mui/material\";\n\nfunction Search({ handleWindowSearch }) {\n    return (\n        <IconButton size=\"small\" variant=\"text\" onClick={handleWindowSearch}>\n            <SearchIcon />\n        </IconButton>\n    );\n}\n\nexport default Search;\n","import React, { useRef } from \"react\";\nimport {\n    AutoSizer,\n    CellMeasurer,\n    CellMeasurerCache,\n    List,\n} from \"react-virtualized\";\nimport HighlightedString from \"./HighlightedString\";\nimport styles from \"./SearchStyle.css\";\n\nfunction SearchList(props) {\n    const { handleListItemClick, searchValue, results, selectedText } = props;\n    let listRef = useRef();\n    let cache = useRef(\n        new CellMeasurerCache({\n            fixedWidth: true,\n            defaultHeight: 100,\n        })\n    );\n    let rowRenderer = ({ key, index, parent, style }) => {\n        let result = results[index];\n        return (\n            <CellMeasurer\n                key={`listkeys2-${key}`}\n                cache={cache.current}\n                parent={parent}\n                columnIndex={0}\n                rowIndex={index}\n            >\n                <div style={style}>\n                    {results.length > 0 && (\n                        <div\n                            className={styles.searchListItem}\n                            onClick={() => handleListItemClick(result[0])}\n                        >\n                            <HighlightedString\n                                string={result[1]}\n                                highlightClass={styles.highlight}\n                                searchTerm={searchValue}\n                            />\n                        </div>\n                    )}\n                </div>\n            </CellMeasurer>\n        );\n    };\n\n    if (!results) return null;\n    return (\n        <>\n            <AutoSizer>\n                {({ height, width }) => (\n                    <List\n                        ref={listRef}\n                        height={height}\n                        rowCount={results?.length}\n                        rowHeight={cache.current.rowHeight}\n                        deferredMeasurementCache={cache.current}\n                        rowRenderer={rowRenderer}\n                        width={width}\n                        overscanRowCount={1}\n                    ></List>\n                )}\n            </AutoSizer>\n        </>\n    );\n}\n\nexport default SearchList;\n","import React, { useEffect, useState } from \"react\";\nimport WrenchIcon from \"images/wrench.svg\";\nimport Slider from \"../../UI/Slider\";\nimport useLocalStorage from \"components/utility/useLocalStorage\";\n\nimport CheckIcon from \"@mui/icons-material/Check\";\nimport {\n    IconButton,\n    MenuList,\n    MenuItem,\n    Divider,\n    Grow,\n    Box,\n    ClickAwayListener,\n} from \"@mui/material\";\nimport { FONT_LIST } from \"app_constants\";\n\nfunction Settings(props) {\n    let [showOption, setShowOption] = useState(false);\n    let [fontSelect, setFontSelect] = useLocalStorage(\n        \"WindowTwoFont\",\n        \"Tibetan\"\n    );\n    useEffect(() => {\n        document.body.style.setProperty(\"--tibetan-fonts2\", fontSelect);\n    }, []);\n    const handleClick = () => {\n        setShowOption((prev) => !prev);\n    };\n    const handlefont = (value) => {\n        setFontSelect(value);\n        document.body.style.setProperty(\"--tibetan-fonts2\", `${value}`);\n        let update = document.getElementById(\"updateList2\");\n        let times = 1;\n        let timer = setInterval(() => {\n            update.click();\n            times++;\n            console.log(\"ran\");\n            if (times > 4) {\n                clearInterval(timer);\n            }\n        }, 800);\n        setShowOption(false);\n    };\n    return (\n        <ClickAwayListener onClickAway={() => setShowOption(false)}>\n            <Box position=\"relative\">\n                <IconButton onClick={handleClick} size=\"small\" variant=\"text\">\n                    <WrenchIcon height={20} width={20} fill=\"currentColor\" />\n                </IconButton>\n                <Grow in={showOption}>\n                    <MenuList\n                        dense\n                        sx={{\n                            position: \"absolute\",\n                            right: 0,\n                            zIndex: 2,\n                            top: 40,\n                            bgcolor: \"heading.main\",\n                        }}\n                    >\n                        <Slider\n                            max={20}\n                            min={7}\n                            initialvalue={props.textFontSize}\n                            changeSize={props.onChangedFontSize}\n                        />\n                        <Divider />\n                        <FontSelection\n                            selectFont={handlefont}\n                            selectedfont={fontSelect}\n                        />\n                        <MenuItem onClick={() => props.onExport()}>\n                            Export Document\n                            {props.exportingWitness && <CheckIcon />}\n                        </MenuItem>\n                    </MenuList>\n                </Grow>\n            </Box>\n        </ClickAwayListener>\n    );\n}\n\nexport default Settings;\n\nconst FontSelection = ({ selectFont, selectedfont }) => {\n    let fontAvailable = FONT_LIST || [];\n\n    return (\n        <Box textAlign={\"center\"}>\n            <span>Font:</span>{\" \"}\n            <select\n                onChange={(e) => selectFont(e.target.value)}\n                value={selectedfont}\n            >\n                {fontAvailable.map((font, index) => {\n                    return (\n                        <option key={index + \"-fontselect\"} value={font}>\n                            {font}\n                        </option>\n                    );\n                })}\n            </select>\n        </Box>\n    );\n};\n","import React from \"react\";\nimport { IconButton } from \"@mui/material\";\nimport MenuIcon from \"@mui/icons-material/Menu\";\nimport ClearIcon from \"@mui/icons-material/Clear\";\n\nfunction TableOfContent(props) {\n    const handleClick = () => {\n        props.changeShowTableContent(!props.showTableContent);\n    };\n    return (\n        <React.Fragment key=\"right\">\n            <IconButton onClick={handleClick}>\n                {props.showTableContent ? <ClearIcon /> : <MenuIcon />}\n            </IconButton>\n        </React.Fragment>\n    );\n}\n\nexport default TableOfContent;\n","// @flow\nimport React, { useState, useEffect, memo, useLayoutEffect } from \"react\";\nimport _ from \"lodash\";\nimport { FormattedMessage, injectIntl } from \"react-intl\";\nimport styles from \"./SelectVersion.css\";\nimport Witness from \"lib/Witness\";\nimport { NativeSelect } from \"@mui/material\";\n\nexport type Props = {\n    witnesses: Witness[],\n    activeWitness: Witness | null,\n    onSelectedWitness: (witness: Witness) => void,\n    user: {},\n};\n\nconst SelectVersion = (props: Props) => {\n    let witnesses = [];\n    let tabName = \"\";\n    let r = \"\";\n    let classes = [];\n    if (props.witnesses) {\n        witnesses = props.witnesses.map((witness) => witness);\n        if (props.activeWitness)\n            r = props.witnesses.findIndex(\n                (l) => l.id === props.activeWitness.id\n            );\n        witnesses.sort((a, b) => {\n            if (a.isWorking) {\n                return -1;\n            }\n            if (b.isWorking) {\n                return 1;\n            }\n            if (a.isBase) {\n                return -1;\n            }\n            if (b.isBase) {\n                return 1;\n            }\n            return 0;\n        });\n        witnesses = witnesses.sort((a, b) => a.id - b.id);\n    }\n\n    const handleChangeWitness = (e) => {\n        if (!_.isEmpty(witnesses)) {\n            props.onSelectedWitness(witnesses[e.target.value]);\n        }\n    };\n\n    if (_.isEmpty(witnesses) && !props.activeWitness) return null;\n\n    return (\n        <NativeSelect\n            onChange={handleChangeWitness}\n            className={styles.selectVersion}\n            value={r}\n            label=\"Version2\"\n            classes={{\n                root: styles.selectEmpty,\n                select: styles.selectOptions,\n            }}\n        >\n            {witnesses.map((witness, key) => {\n                if (witness.id === props.activeWitness?.id)\n                    classes.push(styles.selected);\n                tabName = witness.source.name;\n\n                if (witness.isWorking) {\n                    tabName =\n                        props.intl.locale === \"en\"\n                            ? props.user.name === \"User\"\n                                ? \"Working\"\n                                : \"My Edition\"\n                            : \"མཉམ་འབྲེལ་པར་མ།\";\n                }\n\n                return (\n                    <option\n                        key={`versionSelect2-${key}`}\n                        value={key}\n                        className={styles.selectOptions}\n                    >\n                        {tabName}\n                    </option>\n                );\n            })}\n        </NativeSelect>\n    );\n};\n\nexport default memo(injectIntl(SelectVersion));\n","// @flow\nimport * as React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { AutoSizer } from \"react-virtualized/dist/es/AutoSizer\";\nimport { List } from \"react-virtualized\";\nimport {\n    CellMeasurer,\n    CellMeasurerCache,\n} from \"react-virtualized/dist/es/CellMeasurer\";\nimport \"react-virtualized/styles.css\";\nimport Text from \"./Text\";\nimport SplitText from \"lib/SplitText\";\nimport styles from \"components/TextDetail/SplitText.css\";\nimport _, { split } from \"lodash\";\nimport TextSegment from \"lib/TextSegment\";\nimport Witness from \"lib/Witness\";\nimport GraphemeSplitter from \"grapheme-splitter\";\nimport { Box } from \"@mui/material\";\n\nlet _searchResultsCache: {\n    [splitTextUniqueId: string]: {\n        [searchTerm: string]: {\n            [index: number]: { [position: number]: [number, number] },\n        },\n    },\n} = {};\n\nexport type Props = {\n    splitText: SplitText,\n    didSelectSegmentIds: (segmentIds: string[]) => void,\n    limitWidth: boolean,\n    // selectedAnnotatedSegments: Array<TextSegment | number>,\n    selectedSegmentId: (segmentId: string) => void,\n    selectedWitness: Witness | null,\n    // selectedSearchResult: {\n    //     textId: number,\n    //     start: number,\n    //     length: number\n    // } | null,\n    // searchValue: string | null,\n    fontSize: number,\n    isPanelLinked: Boolean,\n    textAlignment: {},\n    textAlignmentById: {},\n    changeScrollToId: () => void,\n    selectedWindow: Boolean,\n    selectedTargetRange: [],\n    selectedSourceRange: [],\n    syncIdOnSearch: String,\n    changeSyncIdOnClick: () => void,\n};\n\nexport default class SplitTextComponent extends React.PureComponent<Props> {\n    list: List | null;\n    splitText: HTMLDivElement | null;\n    didSelectSegmentIds;\n    cache: CellMeasurerCache;\n    rowRenderer: (params: {\n        key: string,\n        index: number,\n        parent: {},\n        style: {},\n    }) => React.Element<CellMeasurer>;\n    resizeHandler: () => void;\n    selectionHandler: (e: Event) => void;\n    textListVisible: boolean;\n    editMenuVisible: Boolean;\n    activeSelection: Selection | null;\n    selectedNodes: Node[] | null;\n    // Whether the mouse button is down\n    textAlignmentById;\n    changeScrollToId: () => void;\n\n    selectedTextIndex: number | null;\n    splitTextRect: ClientRect | null;\n    firstSelectedSegment: TextSegment | null;\n    selectedElementId: string | null;\n    selectedElementIds: string[] | null;\n    selectedWindow: Boolean;\n    scrollEvent: () => void;\n    mouseEnter: () => void;\n    mouseLeft: () => void;\n    scrollTop;\n    debouncedScroll;\n    constructor(props: Props) {\n        super(props);\n        this.textAlignmentById = [];\n        this.changeScrollToId = props.changeScrollToId;\n        this.condition = props.condition;\n        this.list = null;\n        this.splitText = null;\n        this.cache = new CellMeasurerCache({\n            fixedWidth: true,\n        });\n        this.rowRenderer = this.rowRenderer.bind(this);\n        this.activeSelection = null;\n        this.selectedNodes = null;\n        this._mouseDown = false;\n        this._activeWitness = null;\n        this._didSetInitialScrollPosition = false;\n        this._modifyingSelection = false;\n        this.imageHeight = null;\n        this.imageWidth = null;\n        this.calculatedImageHeight = null;\n        this.selectedWindow = this.props.selectedWindow;\n        this.scrollEvent = this.scrollEvent.bind(this);\n        // this.processProps(props);\n        this.scrollTop = 0;\n    }\n    scrollEvent(e) {\n        if (this.selectedWindow === 1) return null;\n        if (this.selectedWindow === 2) {\n            let list = [];\n            this.textAlignmentById.map((l) => {\n                let number = document.getElementById(\"s2_\" + l.TStart);\n                if (number) {\n                    let position = number.getBoundingClientRect();\n                    if (position.top > 90) {\n                        list.push({\n                            id: l.id,\n                            start: l.start,\n                            TStart: l.TStart,\n                            end: l.end,\n                            TEnd: l.TEnd,\n                        });\n                    }\n                }\n            });\n            if (!_.isEmpty(list)) {\n                if (this.selectedWindow === 2) {\n                    this.debouncedScroll(list);\n                }\n            }\n        }\n    }\n\n    selectedListRow(props: Props): number | null {\n        let row = null;\n        if (props.activeAnnotation) {\n            row = props.splitText.getTextIndexOfPosition(\n                props.activeAnnotation.start\n            );\n        }\n        return row;\n    }\n    handleSelection(e: Event) {\n        if (!this._modifyingSelection) {\n            this.activeSelection = document.getSelection();\n            if (!this._mouseDown) {\n                // sometimes, this gets called after the mouseDown event handler\n                this.mouseUp();\n            }\n        } else {\n            e.stopPropagation();\n            // Need to set this here. If set at callsite, the event will not\n            // have time to propagate.\n            this._modifyingSelection = false;\n        }\n    }\n    mouseDown() {\n        this._mouseDown = true;\n    }\n\n    mouseUp() {\n        this._mouseDown = false;\n        if (this.activeSelection) {\n            // let segmentIds = this.processSelection(this.activeSelection);\n            // if (!segmentIds) {\n            //     segmentIds = [];\n            // }\n            // this.props.didSelectSegmentIds(segmentIds);\n            this.activeSelection = null;\n        }\n    }\n\n    // processSelection(selection: Selection): string[] | null {\n    //     if (\n    //         selection.rangeCount === 0 ||\n    //         selection.isCollapsed ||\n    //         selection.type === \"Caret\"\n    //     ) {\n    //         this.selectedNodes = null;\n    //         return null;\n    //     }\n\n    //     const range = selection.getRangeAt(0);\n    //     const start = range.startContainer;\n    //     const startSpan = this.getNodeSegmentSpan(start);\n    //     if (!(startSpan && startSpan.parentNode)) {\n    //         If the selection is not a text segment, ignore.\n    //         Assuming if the first node is a non-segment, they\n    //         all are.\n    //         return null;\n    //     }\n\n    //     let nodes = this.getRangeNodes(range, startSpan.parentNode);\n    //     Check if the selection starts after the end of a node, and\n    //     if so remove that node.\n    //     if (nodes.length > 0) {\n    //         let firstNode = nodes[0];\n    //         if (range.startOffset === firstNode.textContent.length) {\n    //             nodes.shift();\n    //         }\n    //     }\n\n    //     const end = range.endContainer;\n    //     const endSpan = this.getNodeSegmentSpan(end);\n    //     if (!(endSpan && endSpan.parentNode)) {\n    //         return null;\n    //     }\n    //     if (endSpan && startSpan.parentNode !== endSpan.parentNode) {\n    //         Selection is spanning Texts.\n    //         We assume a selection can only run across a maximum\n    //         of two Texts.\n    //         nodes = nodes.concat(this.getRangeNodes(range, endSpan.parentNode));\n    //     } else {\n    //         Check if the selection ends before the start of a node, and\n    //         if so remove that node.\n    //         if (range.endOffset === 0) {\n    //             nodes.pop();\n    //         }\n    //     }\n    //     this.selectedNodes = nodes;\n    //     let nodeIds = [];\n    //     nodes.reduce((accumulator: string[], current: Node) => {\n    //         if (current instanceof Element) {\n    //             accumulator.push(current.id);\n    //         }\n    //         return accumulator;\n    //     }, nodeIds);\n\n    //     return nodeIds;\n    // }\n    // getRangeNodes(range: Range, parentNode: Node): Node[] {\n    //     let rangeSpans = [];\n    //     for (let i = 0, len = parentNode.childNodes.length; i < len; i++) {\n    //         const node = parentNode.childNodes[i];\n    //         // TODO: add polyfill for i.e.?\n    //         // e.g. https://gist.github.com/jonathansampson/6d09bd6d2e8c22c53868aec42e66b0f9\n    //         if (range.intersectsNode(node)) {\n    //             rangeSpans.push(node);\n    //         }\n    //     }\n    //     return rangeSpans;\n    // }\n    getNodeSegmentSpan(node: Node): Element | null {\n        let currentNode = node;\n        let span = null;\n        const test = /^(i|s|ds)_/;\n        while (!span && currentNode.parentNode) {\n            if (currentNode instanceof Element && test.test(currentNode.id)) {\n                span = currentNode;\n            }\n            currentNode = currentNode.parentNode;\n        }\n\n        return span;\n    }\n\n    updateList(\n        resetCache: boolean = true,\n        resetRows: number | number[] | null = null\n    ) {\n        if (\n            this.props.showImages &&\n            !this.calculatedImageHeight &&\n            this.imageHeight &&\n            this.imageWidth\n        ) {\n            this.calculatedImageHeight = this.calculateImageHeight();\n        }\n        if (this.list) {\n            const list = this.list;\n            if (resetCache) {\n                if (resetRows !== null) {\n                    if (!Array.isArray(resetRows)) {\n                        this.cache.clear(resetRows);\n                    } else if (Array.isArray(resetRows)) {\n                        for (let i = 0; i < resetRows.length; i++) {\n                            let resetRow = resetRows[i];\n                            this.cache.clear(resetRow);\n                        }\n                    }\n                } else {\n                    this.cache.clearAll();\n                    list.measureAllRows();\n                    list.recomputeRowHeights(0);\n                }\n            }\n            list.forceUpdateGrid();\n        }\n    }\n\n    processProps(props: Props) {\n        let changedWitness = false;\n        if (\n            !this.props.selectedWitness ||\n            (props.selectedWitness &&\n                props.selectedWitness.id !== this.props.selectedWitness.id)\n        ) {\n            changedWitness = true;\n            this._didSetInitialScrollPosition = false;\n        }\n\n        if (\n            props.selectedSearchResult &&\n            (!this.props.selectedSearchResult ||\n                props.selectedSearchResult.start !==\n                    this.props.selectedSearchResult.start ||\n                props.selectedSearchResult.textId !==\n                    this.props.selectedSearchResult.textId)\n        ) {\n            console.log(\"resetting scroll position from search result\");\n            this._didSetInitialScrollPosition = false;\n        }\n\n        // TODO: check if new selectedSearchResult and if so\n        // set this._didSetInitialScrollPosition = false\n\n        // make sure there's no numbers in selectedAnnotatedSegments\n        // as we want to pass it to Text which only expects TextSegments\n        // this._filteredSelectedAnnotatedSegments = props.selectedAnnotatedSegments.reduce(\n        //     (acc, current: TextSegment | number) => {\n        //         if (current instanceof TextSegment) acc.push(current);\n        //         return acc;\n        //     },\n        //     []\n        // );\n\n        const controlsMeasurements = this.getControlsMeasurements(props);\n        if (controlsMeasurements) {\n            this.selectedTextIndex = controlsMeasurements.selectedTextIndex;\n            this.firstSelectedSegment =\n                controlsMeasurements.firstSelectedSegment;\n            this.splitTextRect = controlsMeasurements.splitTextRect;\n            this.selectedElementId = controlsMeasurements.selectedElementId;\n            this.selectedElementIds = controlsMeasurements.selectedElementIds;\n        }\n\n        if (\n            props.textListVisible !== this.textListVisible ||\n            props.editMenuVisible !== this.editMenuVisible\n        ) {\n            setTimeout(() => {\n                this.textListVisible = props.textListVisible;\n                this.editMenuVisible = props.editMenuVisible;\n                this.updateList(true);\n            }, 500);\n        } else {\n            if (changedWitness) {\n                this.updateList(true);\n            } else if (this.pageBreaksChanged(this.props, props)) {\n                let selectedRows = null;\n                let currentSelectedRow = this.selectedListRow(this.props);\n                let newSelectedRow = this.selectedListRow(props);\n                if (currentSelectedRow && newSelectedRow) {\n                    let firstChangedRow =\n                        currentSelectedRow > newSelectedRow\n                            ? newSelectedRow\n                            : currentSelectedRow;\n\n                    let splitRowTexts = this.props.splitText.texts;\n                    selectedRows = [];\n                    for (\n                        let i = firstChangedRow, len = splitRowTexts.length;\n                        i < len;\n                        i++\n                    ) {\n                        selectedRows.push(i);\n                    }\n                }\n                this.updateList(true, selectedRows);\n            } else if (this.lineBreaksChanges(this.props, props)) {\n                let selectedRow = this.selectedListRow(props);\n                if (!selectedRow)\n                    selectedRow = this.selectedListRow(this.props);\n                let splitRowTexts = this.props.splitText.texts;\n                let selectedRows = [];\n                if (selectedRow !== null) {\n                    for (\n                        let i = selectedRow, len = splitRowTexts.length;\n                        i < len;\n                        i++\n                    ) {\n                        selectedRows.push(i);\n                    }\n                    this.updateList(true, selectedRows);\n                }\n            } else if (this.props.fontSize !== props.fontSize) {\n                this.updateList(true);\n            } else if (\n                this.props.activeAnnotation &&\n                props.activeAnnotation &&\n                this.annotationsInSameLocation(\n                    this.props.activeAnnotation,\n                    props.activeAnnotation\n                )\n            ) {\n                this.updateList(true, this.selectedListRow(props));\n            } else {\n                this.updateList(this.shouldResetListCache(this.props, props));\n            }\n        }\n    }\n\n    pageBreaksChanged(oldProps: Props, newProps: Props) {\n        const oldTextBreaks = oldProps.splitText.getTextsFinalPositions();\n        const newTextBreaks = newProps.splitText.getTextsFinalPositions();\n\n        if (oldTextBreaks.length !== newTextBreaks.length) return true;\n\n        return JSON.stringify(oldTextBreaks) !== JSON.stringify(newTextBreaks);\n    }\n\n    lineBreaksChanges(oldProps: Props, newProps: Props) {\n        let oldActiveAnnotation = oldProps.activeAnnotation;\n        let newActiveAnnotation = newProps.activeAnnotation;\n        let hasChanged = false;\n\n        if (\n            oldActiveAnnotation &&\n            oldActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) &&\n            newProps.activeAnnotations &&\n            !newProps.activeAnnotations.hasOwnProperty(\n                oldActiveAnnotation.uniqueId\n            )\n        ) {\n            hasChanged = true;\n        }\n\n        if (\n            newActiveAnnotation &&\n            newActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) &&\n            oldProps.activeAnnotations &&\n            !oldProps.activeAnnotations.hasOwnProperty(\n                newActiveAnnotation.uniqueId\n            )\n        ) {\n            hasChanged = true;\n        }\n\n        return hasChanged;\n    }\n    shouldResetListCache(oldProps: Props, newProps: Props) {\n        let shouldReset = false;\n        if (\n            oldProps.showImages !== newProps.showImages ||\n            this.pageBreaksChanged(oldProps, newProps)\n        ) {\n            shouldReset = true;\n        }\n\n        return shouldReset;\n    }\n\n    UNSAFE_componentWillReceiveProps(props: Props) {\n        this.processProps(props);\n    }\n\n    componentDidMount() {\n        this.resizeHandler = _.throttle(() => {\n            this.calculatedImageHeight = null;\n            this.updateList();\n        }, 500).bind(this);\n        window.addEventListener(\"resize\", this.resizeHandler);\n\n        this.debouncedScroll = _.debounce((list) => {\n            this.changeScrollToId({ id: list[0].TStart, from: 2 });\n        }, 1000);\n        this.selectionHandler = _.debounce((e) => {\n            this.handleSelection(e);\n        }, 200).bind(this);\n\n        document.addEventListener(\"selectionchange\", this.selectionHandler);\n\n        document.addEventListener(\"mousedown\", this.mouseDown.bind(this), true);\n        document.addEventListener(\"mouseup\", this.mouseUp.bind(this), true);\n\n        this.processProps(this.props);\n        this.componentDidUpdate();\n        this.splitText.style.scrollBehavior = \"smooth\";\n        this.timer = setTimeout(() => {\n            this.resizeHandler();\n        }, 2000);\n    }\n    scrollToIndex(selectedTextIndex) {\n        let list = this.list;\n\n        setTimeout(() => {\n            list.scrollToRow(selectedTextIndex);\n            setTimeout(() => {\n                list.scrollToPosition(list.props.scrollTop - 300);\n            }, 0);\n        }, 100);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        let scrollToId = this.props.scrollToId;\n        this.targetId2 = this.props.syncIdOnClick;\n        this.selectedWindow = this.props.selectedWindow;\n        let SearchSyncId = this.props.syncIdOnSearch || null;\n        let list = this.list;\n        let result = this.props.searchResults;\n        let Alignment = this.props.textAlignment;\n        this.condition = this.props.condition;\n        let con =\n            prevProps?.searchResults !== this.props?.searchResults ||\n            prevProps?.syncIdOnSearch !== this.props?.syncIdOnSearch;\n\n        // for scrolling for search results;\n\n        if (con && result) {\n            if (SearchSyncId) {\n                let selectedTextIndex =\n                    this.props.splitText.getTextIndexOfPosition(SearchSyncId);\n                this.scrollToIndex(selectedTextIndex);\n            }\n        }\n\n        // scroll dom with respect to window 1 scrolling\n\n        if (\n            this.selectedWindow === 1 &&\n            scrollToId.from === 1 &&\n            this.condition &&\n            scrollToId.id !== null\n        ) {\n            this.textAlignmentById = this.props.textAlignmentById || [];\n\n            if (Alignment) {\n                let req = this.textAlignmentById.find(\n                    (l) => l.start === scrollToId.id\n                );\n                let TStart = req?.TStart;\n                if (TStart !== null) {\n                    let selectedTextIndex =\n                        this.props.splitText.getTextIndexOfPosition(TStart);\n                    this.scrollToIndex(selectedTextIndex);\n                }\n            }\n        }\n        // scroll dom with respect to window 1 click\n        //for scrolling to the highlighted alignment if its outside visible DOM\n        if (\n            this.targetId2 &&\n            scrollToId.from === null &&\n            this.selectedWindow === 1 &&\n            scrollToId.id === null &&\n            this.condition\n        ) {\n            let clickIdObj = Alignment.alignment.find(\n                (l) =>\n                    this.targetId2 >= l.source_segment.start &&\n                    this.targetId2 < l.source_segment.end\n            );\n            let syncClickTargetId = clickIdObj?.target_segment?.start;\n            let selectedTextIndex =\n                this.props.splitText.getTextIndexOfPosition(syncClickTargetId);\n\n            this.scrollToIndex(selectedTextIndex);\n        }\n\n        // if (this.selectedNodes && this.selectedNodes.length > 0) {\n        //     const selectedNodes = this.selectedNodes;\n        //     const selectedSegments = this.props.selectedAnnotatedSegments;\n        //     setTimeout(() => {\n        //         let selRange = document.createRange();\n        //         let startNode = selectedNodes[0];\n        //         let endNode = selectedNodes[selectedNodes.length - 1];\n        //         // let lastSegment = selectedSegments[selectedSegments.length - 1];\n        //         if (lastSegment instanceof TextSegment) {\n        //             let lastElement = document.getElementById(\n        //                 idForSegment(lastSegment)\n        //             );\n        //             if (lastElement) endNode = lastElement;\n        //         }\n        //         if (\n        //             startNode instanceof Element &&\n        //             endNode instanceof Element\n        //         ) {\n        //             startNode = document.getElementById(startNode.id);\n        //             endNode = document.getElementById(endNode.id);\n        //             if (startNode && endNode) {\n        //                 selRange.setStart(startNode, 0);\n        //                 selRange.setEnd(endNode, endNode.childNodes.length);\n        //                 let sel = document.getSelection();\n        //                 if (sel) {\n        //                     this._modifyingSelection = true;\n        //                     sel.removeAllRanges();\n        //                     sel.addRange(selRange);\n        //                     this.selectedNodes = null;\n        //                 }\n        //             }\n        //         }\n        //     }, 0);\n        // }\n    }\n\n    componentWillUnmount() {\n        document.removeEventListener(\"mousedown\", this);\n        document.removeEventListener(\"mouseup\", this);\n        window.removeEventListener(\"resize\", this.resizeHandler);\n\n        document.removeEventListener(\"selectionchange\", this.selectionHandler);\n        clearTimeout(this.timer);\n    }\n\n    getSelectedTextIndex(): number {\n        let selectedTextIndex = 0;\n        let startPos = null;\n        if (this.props.activeAnnotation) {\n            [startPos] =\n                this.props.splitText.annotatedText.getPositionOfAnnotation(\n                    this.props.activeAnnotation\n                );\n        } else if (this.props.selectedSearchResult) {\n            let segment =\n                this.props.splitText.annotatedText.segmentAtOriginalPosition(\n                    this.props.selectedSearchResult.start\n                );\n            if (segment instanceof TextSegment) {\n                startPos = segment.start;\n            } else if (typeof segment === \"number\") {\n                startPos = segment;\n            }\n        }\n        if (startPos) {\n            selectedTextIndex =\n                this.props.splitText.getTextIndexOfPosition(startPos);\n        }\n        return selectedTextIndex;\n    }\n    getControlsMeasurements(props: Props): {\n        selectedTextIndex: number,\n        firstSelectedSegment: TextSegment,\n        selectedElementId: string,\n        splitTextRect: ClientRect,\n        selectedElementIds: string[],\n    } | null {\n        if (!this.splitText) {\n            return null;\n        }\n        let splitTextComponent = this.splitText;\n        let selectedTextIndex = null;\n        let firstSelectedSegment = null;\n        let selectedElementId = null;\n        let splitTextRect = null;\n        let segmentIdFunction: null | ((segment: TextSegment) => string) = null;\n        let selectedElementIds = [];\n        let startPos = 0;\n        if (props.activeAnnotation) {\n            let activeAnnotation = props.activeAnnotation;\n            [startPos] =\n                props.splitText.annotatedText.getPositionOfAnnotation(\n                    activeAnnotation\n                );\n            if (startPos === null) {\n                console.warn(\"No startPos in getControlsMeasurements\");\n                return null;\n            }\n            if (activeAnnotation.type === ANNOTATION_TYPES.pageBreak) {\n                startPos -= 1;\n            }\n            if (activeAnnotation.type === ANNOTATION_TYPES.lineBreak) {\n                startPos -= 1;\n            }\n\n            // Index of text containing end of annotation\n            let positionEnd = startPos + activeAnnotation.length;\n            if (activeAnnotation.length > 0) positionEnd -= 1;\n            selectedTextIndex =\n                props.splitText.getTextIndexOfPosition(positionEnd);\n            splitTextRect = splitTextComponent.getBoundingClientRect();\n        }\n        let selectedAnnotatedSegments = [];\n        if (\n            props.selectedAnnotatedSegments &&\n            props.selectedAnnotatedSegments.length > 0\n        ) {\n            selectedAnnotatedSegments = props.selectedAnnotatedSegments;\n            for (let i = 0; i < selectedAnnotatedSegments.length; i++) {\n                let segment = selectedAnnotatedSegments[i];\n                if (\n                    firstSelectedSegment === null &&\n                    segment instanceof TextSegment\n                ) {\n                    firstSelectedSegment = segment;\n                    break;\n                }\n            }\n            if (firstSelectedSegment) {\n                if (\n                    firstSelectedSegment.length === 0 &&\n                    props.activeAnnotation &&\n                    props.activeAnnotation.isInsertion\n                ) {\n                    selectedElementId = idForInsertion(firstSelectedSegment);\n                    segmentIdFunction = idForInsertion;\n                } else {\n                    selectedElementId = idForSegment(firstSelectedSegment);\n                    segmentIdFunction = idForSegment;\n                }\n            }\n        } else if (props.activeAnnotation) {\n            if (props.activeAnnotation.isDeletion) {\n                let segment = new TextSegment(startPos, \"\");\n                selectedElementId = idForDeletedSegment(segment);\n                segmentIdFunction = idForDeletedSegment;\n                firstSelectedSegment = segment;\n                selectedAnnotatedSegments = [firstSelectedSegment];\n            } else if (props.activeAnnotation.isInsertion) {\n                const [start] =\n                    props.splitText.annotatedText.getPositionOfAnnotation(\n                        props.activeAnnotation\n                    );\n                if (start) {\n                    let segment = new TextSegment(start, \"\");\n                    selectedElementId = idForInsertion(segment);\n                    segmentIdFunction = idForInsertion;\n                    firstSelectedSegment = segment;\n                    selectedAnnotatedSegments = [firstSelectedSegment];\n                }\n            } else if (\n                props.activeAnnotation.type === ANNOTATION_TYPES.pageBreak\n            ) {\n                let segment = new TextSegment(startPos + 1, \"\");\n                let prevSegment = new TextSegment(startPos, \"\");\n                selectedElementId = idForPageBreak(prevSegment);\n                firstSelectedSegment = segment;\n                selectedAnnotatedSegments = [segment];\n                selectedElementIds = [selectedElementId];\n            } else if (\n                props.activeAnnotation.type === ANNOTATION_TYPES.lineBreak\n            ) {\n                let segment = new TextSegment(startPos + 1, \"\");\n                let prevSegment = new TextSegment(startPos, \"\");\n                selectedElementId = idForLineBreak(prevSegment);\n                firstSelectedSegment = segment;\n                selectedAnnotatedSegments = [segment];\n                selectedElementIds = [selectedElementId];\n            }\n        }\n        if (segmentIdFunction) {\n            for (let i = 0; i < selectedAnnotatedSegments.length; i++) {\n                let segment = selectedAnnotatedSegments[i];\n                if (segment instanceof TextSegment) {\n                    const segmentId = segmentIdFunction(segment);\n                    selectedElementIds.push(segmentId);\n                }\n            }\n        }\n        if (\n            selectedTextIndex != null &&\n            firstSelectedSegment &&\n            selectedElementId &&\n            splitTextRect\n        ) {\n            return {\n                selectedTextIndex: selectedTextIndex,\n                firstSelectedSegment: firstSelectedSegment,\n                selectedElementId: selectedElementId,\n                splitTextRect: splitTextRect,\n                selectedElementIds: selectedElementIds,\n            };\n        } else {\n            return null;\n        }\n    }\n\n    render() {\n        const props = this.props;\n        const rowRenderer = this.rowRenderer;\n        const cache = this.cache;\n        const key = props.selectedWitness ? props.selectedWitness.id : 0;\n\n        return (\n            <div\n                className={styles.splitText}\n                ref={(div) => (this.splitText = div)}\n                key={key}\n                style={{\n                    cursor: \"pointer\",\n                }}\n            >\n                <button\n                    id=\"updateList2\"\n                    style={{ display: \"none\" }}\n                    onClick={() => this.updateList(true)}\n                ></button>\n                <AutoSizer disableWidth>\n                    {({ height }) => (\n                        <List\n                            ref={(list) => (this.list = list)}\n                            height={height}\n                            rowCount={props.splitText.texts.length}\n                            rowHeight={cache.rowHeight}\n                            rowRenderer={rowRenderer}\n                            width={1}\n                            overscanRowCount={1}\n                            deferredMeasurementCache={cache}\n                            onScroll={this.scrollEvent}\n                            scrollToAlignment=\"start\"\n                            containerStyle={{\n                                width: \"100%\",\n                                maxWidth: \"100%\",\n                            }}\n                            style={{\n                                width: \"100%\",\n                            }}\n                        ></List>\n                    )}\n                </AutoSizer>\n            </div>\n        );\n    }\n    getStringPositions(\n        text: SegmentedText,\n        string: string,\n        index: number\n    ): { [position: number]: [number, number] } {\n        const uniqueId = this.props.splitText.annotatedText.getUniqueId();\n\n        if (!_searchResultsCache.hasOwnProperty(uniqueId)) {\n            _searchResultsCache = {\n                [uniqueId]: {},\n            };\n        }\n\n        if (!_searchResultsCache[uniqueId].hasOwnProperty(string)) {\n            _searchResultsCache[uniqueId] = {\n                [string]: {},\n            };\n        }\n\n        if (_searchResultsCache[uniqueId][string].hasOwnProperty(index)) {\n            return _searchResultsCache[uniqueId][string][index];\n        }\n\n        const splitter = new GraphemeSplitter();\n        const content = text.getText();\n        const firstSegment = text.segments[0];\n        const startingPosition = firstSegment.start;\n        let positions = [];\n        let position = content.indexOf(string);\n        while (position !== -1) {\n            positions.push(position);\n            position = content.indexOf(string, position + 1);\n        }\n\n        // Position needs to be position in complete text\n        let verifiedPositions: { [position: number]: [number, number] } = {};\n        if (positions.length > 0) {\n            const graphemes = splitter.splitGraphemes(content);\n            let position = 0;\n            let activePosition = null;\n            for (let i = 0; i < graphemes.length; i++) {\n                const grapheme = graphemes[i];\n                const graphemeEnd = position + (grapheme.length - 1);\n                if (activePosition !== null) {\n                    let expectedEnd = activePosition + (string.length - 1);\n                    if (graphemeEnd >= expectedEnd) {\n                        verifiedPositions[activePosition + startingPosition] = [\n                            activePosition + startingPosition,\n                            graphemeEnd + startingPosition,\n                        ];\n                        activePosition = null;\n                    }\n                } else if (positions.indexOf(position) !== -1) {\n                    if (string.length === grapheme.length) {\n                        verifiedPositions[position + startingPosition] = [\n                            position + startingPosition,\n                            graphemeEnd + startingPosition,\n                        ];\n                    } else if (string.length > grapheme.length) {\n                        activePosition = position;\n                    }\n                } else {\n                    activePosition = null;\n                }\n\n                position += grapheme.length;\n            }\n        }\n\n        _searchResultsCache[uniqueId][string][index] = verifiedPositions;\n\n        return verifiedPositions;\n    }\n\n    rowRenderer({\n        key,\n        index,\n        parent,\n        style,\n    }: {\n        key: string,\n        index: number,\n        parent: {},\n        style: {},\n    }): React.Element<CellMeasurer> {\n        const props = this.props;\n        const cache = this.cache;\n\n        let searchStringPositions = {};\n        let searchValue = this.props.searchValue;\n        if (searchValue && searchValue.length > 0 && props.splitText) {\n            searchStringPositions = this.getStringPositions(\n                props.splitText.texts[index],\n                searchValue,\n                index\n            );\n        }\n\n        let newStyle = {\n            ...style,\n            height: style.height + 10,\n        };\n        return (\n            <CellMeasurer\n                columnIndex={0}\n                key={key}\n                parent={parent}\n                rowIndex={index}\n                cache={cache}\n            >\n                <div\n                    key={key}\n                    style={newStyle}\n                    ref={this.splitTextRef}\n                    id={`index2_${index}`}\n                    className={styles.splitTextRow}\n                >\n                    <div className={styles.splitTextRowContent}>\n                        <Text\n                            segmentedText={props.splitText.texts[index]}\n                            row={index}\n                            selectedSegmentId={props.selectedSegmentId}\n                            // searchValue={searchValue}\n                            // selectedSearchResult={\n                            //     this.props.selectedSearchResult\n                            // }\n                            searchStringPositions={searchStringPositions}\n                            textAlignmentById={props.textAlignmentById}\n                            fontSize={props.fontSize}\n                            isPanelLinked={this.props.isPanelLinked}\n                            selectedSourceRange={props.selectedSourceRange}\n                            selectedTargetRange={props.selectedTargetRange}\n                            changeSelectedRange={props.changeSelectedRange}\n                            changeSyncIdOnClick={this.props.changeSyncIdOnClick}\n                            changeScrollToId={this.props.changeScrollToId}\n                            condition={this.condition}\n                        />\n                    </div>\n                </div>\n            </CellMeasurer>\n        );\n    }\n}\n","import React from \"react\";\nimport { Box, Typography } from \"@mui/material\";\nimport Loader from \"react-loader\";\n\nimport { styled, alpha } from \"@mui/material/styles\";\nimport SearchIcon from \"@mui/icons-material/Search\";\nimport InputBase from \"@mui/material/InputBase\";\nimport Toolbar from \"@mui/material/Toolbar\";\n\nconst Search = styled(\"div\")(({ theme }) => ({\n    position: \"relative\",\n    borderRadius: theme.shape.borderRadius,\n    backgroundColor: alpha(theme.palette.common.white, 0.15),\n    \"&:hover\": {\n        backgroundColor: alpha(theme.palette.common.white, 0.25),\n    },\n    marginLeft: 0,\n    width: \"100%\",\n    [theme.breakpoints.up(\"sm\")]: {\n        marginLeft: theme.spacing(1),\n        width: \"auto\",\n    },\n}));\n\nconst SearchIconWrapper = styled(\"div\")(({ theme }) => ({\n    padding: theme.spacing(0, 2),\n    height: \"100%\",\n    position: \"absolute\",\n    pointerEvents: \"none\",\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n}));\n\nconst StyledInputBase = styled(InputBase)(({ theme }) => ({\n    color: \"inherit\",\n    \"& .MuiInputBase-input\": {\n        padding: theme.spacing(1, 1, 1, 0),\n        // vertical padding + font size from searchIcon\n        paddingLeft: `calc(1em + ${theme.spacing(4)})`,\n        transition: theme.transitions.create(\"width\"),\n        width: \"100%\",\n        [theme.breakpoints.up(\"sm\")]: {\n            width: \"0\",\n            cursor: \"pointer\",\n            \"&:focus\": {\n                width: \"20ch\",\n            },\n        },\n    },\n}));\n\nfunction TableOfContent() {\n    let data = [\n        { Id: 1, Title: \"chapter 1\", segment_id: 0 },\n        { Id: 2, Title: \"chapter 2\", segment_id: 400 },\n    ];\n    let loaded = data.length > 0 ? true : false;\n\n    return (\n        <Box\n            sx={{\n                bgcolor: \"heading.main\",\n                color: \"text.primary\",\n                width: \"100%\",\n                height: \"100%\",\n                paddingInline: 2,\n            }}\n        >\n            <Toolbar\n                sx={{\n                    justifyContent: \"space-between\",\n                    paddingLeft: \"0 !important\",\n                    margin: 0,\n                }}\n            >\n                <Typography textTransform={\"uppercase\"} component=\"h6\">\n                    Table Of Content\n                </Typography>\n                <Search>\n                    <SearchIconWrapper>\n                        <SearchIcon />\n                    </SearchIconWrapper>\n                    <StyledInputBase\n                        placeholder=\"Search…\"\n                        inputProps={{ \"aria-label\": \"search\" }}\n                    />\n                </Search>\n            </Toolbar>\n            {/* <Loader loaded={loaded} /> */}\n            <Box>\n                {data.map((list, index) => {\n                    return (\n                        <Box\n                            key={\"TableContent-\" + index}\n                            sx={{\n                                cursor: \"pointer\",\n                                width: \"fit-content\",\n                                \"&:hover\": {\n                                    fontWeight: \"bold\",\n                                },\n                            }}\n                        >\n                            {list.Title}\n                        </Box>\n                    );\n                })}\n            </Box>\n        </Box>\n    );\n}\n\nexport default TableOfContent;\n","// @flow\nimport React from \"react\";\nimport classnames from \"classnames\";\nimport styles from \"components/TextDetail/Text.css\";\nimport TextSegment from \"lib/TextSegment\";\nimport {\n    INSERTION_KEY,\n    DELETION_KEY,\n    PAGE_BREAK_KEY,\n    LINE_BREAK_KEY,\n} from \"lib/AnnotatedText\";\nimport _ from \"lodash\";\nimport SegmentedText from \"lib/SegmentedText\";\nimport Annotation from \"lib/Annotation\";\nimport Witness from \"lib/Witness\";\nimport { ANNOTATION_TYPES } from \"lib/Annotation\";\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\nimport GraphemeSplitter from \"grapheme-splitter\";\nimport { withTheme } from \"@mui/styles\";\n\nexport function idForSegment(segment: TextSegment): string {\n    return \"s2_\" + segment.start;\n}\n\nexport function idForDeletedSegment(segment: TextSegment): string {\n    return \"ds_\" + segment.start;\n}\n\n// export function idForInsertion(segment: TextSegment): string {\n//     return \"i_\" + segment.start;\n// }\n\n// export function idForPageBreak(segment: TextSegment): string {\n//     return \"p_\" + (segment.end + 1);\n// }\n\n// export function idForLineBreak(segment: TextSegment): string {\n//     return \"l_\" + (segment.end + 1);\n// }\n\nexport type Props = {\n    segmentedText: SegmentedText,\n    annotationPositions: { [string]: Annotation[] },\n    selectedSegmentId: (id: string) => void,\n    activeAnnotations: { [AnnotationUniqueId]: Annotation } | null,\n    getBaseAnnotation: (annotation: Annotation) => Annotation,\n    selectedAnnotatedSegments: TextSegment[],\n    row: number,\n    activeAnnotation: Annotation | null,\n    searchValue: string | null,\n    selectedSearchResult: {\n        textId: number,\n        start: number,\n        length: number,\n    } | null,\n    searchStringPositions: { [position: number]: [number, number] },\n    fontSize?: number,\n    activeWitness: Witness,\n    textAlignmentById: {},\n    selectedSourceRange: [],\n    selectedTargetRange: [],\n    changeSyncIdOnClick: () => void,\n};\n\nexport type State = {\n    segmentedText: SegmentedText,\n};\n\n// import ReactDOMServer from \"react-dom/server\";\n// import PageBreakIcon from \"images/page_break_icon.svg\";\n// const PARA_SYMBOL = String.fromCharCode(182);\n// const pageBreakIconString = ReactDOMServer.renderToStaticMarkup(\n//     <PageBreakIcon />\n// );\n\nclass Text2 extends React.Component<Props, State> {\n    _renderedSegments: TextSegment[] | null;\n    _renderedHtml: { __html: string } | null;\n    textAlignmentById;\n\n    constructor(props: Props) {\n        super(props);\n\n        this.state = {\n            segmentedText: props.segmentedText,\n        };\n        this.textAlignmentById = this.props.textAlignmentById;\n        this._renderedSegments = null;\n        this._renderedHtml = null;\n    }\n\n    UNSAFE_componentWillReceiveProps(nextProps: Props) {\n        this.setState((prevState: State, props: Props) => {\n            return {\n                ...prevState,\n                segmentedText: nextProps.segmentedText,\n            };\n        });\n    }\n\n    // annotationsForSegment(segment: TextSegment): Annotation[] {\n    //     let annotations: Annotation[] = [];\n    //     const foundAnnotations = this.props.annotationPositions[\n    //         String(segment.start)\n    //     ];\n    //     if (foundAnnotations) {\n    //         annotations = foundAnnotations;\n    //     }\n    //     const insertions =\n    //         this.props.annotationPositions[INSERTION_KEY + segment.start] || [];\n    //     const deletions =\n    //         this.props.annotationPositions[DELETION_KEY + segment.start] || [];\n    //     const pageBreaks =\n    //         this.props.annotationPositions[\n    //             PAGE_BREAK_KEY + (segment.end + 1)\n    //         ] || [];\n    //     const lineBreaks =\n    //         this.props.annotationPositions[\n    //             LINE_BREAK_KEY + (segment.end + 1)\n    //         ] || [];\n\n    //     return annotations.concat(\n    //         insertions,\n    //         deletions,\n    //         pageBreaks,\n    //         lineBreaks\n    //     );\n    // }\n\n    // segmentsContainSegment(segments: TextSegment[], segment: TextSegment) {\n    //     for (let i = 0; i < segments.length; i++) {\n    //         let listSegment = segments[i];\n    //         if (\n    //             listSegment.start === segment.start &&\n    //             listSegment.text === segment.text\n    //         ) {\n    //             return true;\n    //         }\n    //     }\n    //     return false;\n    // }\n\n    selectedElement(element: Element) {\n        let sourceRangeSelection = [];\n        let targetRangeSelection = [];\n        const selection = document.getSelection();\n        if (element?.id.includes(\"s2_\") && this.props.condition) {\n            var clickId = parseInt(element.id.replace(\"s2_\", \"\"));\n\n            this.props.changeSyncIdOnClick(clickId);\n            this.props.changeScrollToId({ id: \"ua\", from: \"ua\" });\n\n            let id = parseInt(element.id.replace(\"s2_\", \"\"));\n            let rangeUnique = this.textAlignmentById.find(\n                (l) => id >= l.TStart && id < l.TEnd\n            );\n            if (rangeUnique) {\n                for (let i = rangeUnique.start; i < rangeUnique.end; i++) {\n                    sourceRangeSelection.push(i);\n                }\n                for (let i = rangeUnique.TStart; i < rangeUnique.TEnd; i++) {\n                    targetRangeSelection.push(i);\n                }\n                this.props.changeSelectedRange({\n                    source: sourceRangeSelection,\n                    target: targetRangeSelection,\n                });\n            }\n        }\n\n        if (selection && selection.type === \"Range\") {\n            return;\n        }\n        this.props.selectedSegmentId(element.id);\n        if (!element.id) {\n            this.props.changeSelectedRange({ source: [], target: [] });\n        }\n    }\n\n    generateHtml(renderProps: Props, renderState: State): { __html: string } {\n        let segments = renderState.segmentedText.segments;\n\n        let textLineClass = styles.textLine;\n        let segmentHTML = '<p class=\"' + textLineClass + '\">';\n        if (segments.length === 0) return { __html: segmentHTML };\n\n        const endPosition = segments[segments.length - 1].end + 1;\n\n        let highlightClass = styles.highlight;\n        let activeHighlightClass = styles.activeHighlight;\n        let activeSearchResultEnd = null;\n        for (let i = 0; i < segments.length; i++) {\n            let segment = segments[i];\n            let classAttribute = \"\";\n            let classes = [];\n            let selectedCurrentDeletion = false;\n            let selectedCurrentPageBreak = false;\n            let selectedCurrentLineBreak = false;\n            let lineBreakAnnotation = false;\n            let pageBreakAnnotation = null;\n\n            // It's an insertion at the end of the text, which should have just been added to the html.\n            // So break as we don't want anymore segment html adding.\n            if (segment.start === endPosition) {\n                break;\n            }\n            let id = null;\n            if (segment.length === 0) {\n                // id = idForDeletedSegment(segment);\n                // classes.push(styles.removedByAnnotation);\n                // if (deletionText) {\n                //     segment = new TextSegment(segment.start, deletionText);\n                // }\n            } else {\n                id = idForSegment(segment);\n            }\n\n            // if (\n            //     this.segmentsContainSegment(\n            //         renderProps.selectedAnnotatedSegments,\n            //         segment\n            //     ) ||\n            //     selectedCurrentDeletion\n            // ) {\n            //     classes.push(styles.selectedAnnotation);\n            // }\n            if (\n                renderProps.selectedTargetRange?.includes(segment.start) &&\n                renderProps.condition\n            ) {\n                let newClass =\n                    renderProps.theme.palette.mode === \"light\"\n                        ? styles.selectedRangelight\n                        : styles.selectedRangeDark;\n                classes.push(newClass);\n            }\n\n            if (classes.length > 0) {\n                let className = classnames(...classes);\n                classAttribute = 'class=\"' + className + '\"';\n            }\n\n            let segmentContent = segment.text;\n            // Add search result highlight if required.\n            if (renderProps.searchStringPositions) {\n                let segmentStart = segment.start;\n                let position = segmentStart;\n                segmentContent = \"\";\n\n                let highlight = highlightClass;\n                if (\n                    renderProps.selectedSearchResult &&\n                    renderProps.selectedSearchResult.start <= position &&\n                    renderProps.selectedSearchResult.start +\n                        renderProps.selectedSearchResult.length >\n                        position\n                ) {\n                    highlight = activeHighlightClass;\n                }\n\n                for (let j = 0; j < segment.text.length; j++) {\n                    let char = segment.text.charAt(j);\n                    position = segmentStart + j;\n                    if (activeSearchResultEnd) {\n                        let [start, end] = activeSearchResultEnd;\n                        if (j === 0) {\n                            segmentContent +=\n                                '<span class=\"' + highlight + '\">';\n                        }\n                        if (position === end) {\n                            segmentContent += char + \"</span>\";\n                            activeSearchResultEnd = null;\n                        } else if (j === segment.text.length - 1) {\n                            segmentContent += char + \"</span>\";\n                        } else {\n                            segmentContent += char;\n                        }\n                    } else if (position in renderProps.searchStringPositions) {\n                        let [start, end] =\n                            renderProps.searchStringPositions[position];\n                        segmentContent +=\n                            '<span class=\"' + highlight + '\">' + char;\n                        if (j === segment.text.length - 1 || position === end) {\n                            segmentContent += \"</span>\";\n                        }\n                        if (position < end) {\n                            activeSearchResultEnd = [start, end];\n                        }\n                    } else {\n                        segmentContent += char;\n                    }\n                }\n            }\n            // if (\n            //     this.props.textAlignmentById !== null\n            //     // && selectedTextId === TargetId\n            // ) {\n            //     let r = this.props.textAlignmentById.find(\n            //         (d) => d.TStart === segment.start\n            //     );\n            //     if (r) {\n            //         segmentHTML +=\n            //             \"<span id='alignment2_\" +\n            //             segment.start +\n            //             \"'>\" +\n            //             `<sup class=` +\n            //             styles.syncIdClass +\n            //             `>${r.id}</sup>` +\n            //             \"</span>\";\n            //     }\n            // }\n\n            segmentHTML +=\n                \"<span id=\" +\n                id +\n                \" key=\" +\n                id +\n                \" \" +\n                classAttribute +\n                \">\" +\n                segmentContent +\n                \"</span>\";\n        }\n\n        this._renderedSegments = segments;\n        segmentHTML += \"</p>\";\n\n        const html = {\n            __html: segmentHTML,\n        };\n        return html;\n    }\n\n    shouldComponentUpdate(nextProps: Props, nextState: State) {\n        const renderedHtml = this.generateHtml(nextProps, nextState);\n        if (this.props.fontSize !== nextProps.fontSize) {\n            return true;\n        } else if (\n            this._renderedHtml &&\n            renderedHtml.__html === this._renderedHtml.__html\n        ) {\n            return false;\n        } else if (this._renderedHtml !== renderedHtml) {\n            this._renderedHtml = renderedHtml;\n            return true;\n        }\n        return false;\n    }\n    componentDidUpdate() {\n        this.textAlignmentById = this.props.textAlignmentById;\n    }\n    render() {\n        let classes = [styles.text];\n        if (this.props.row === 0) {\n            classes.push(styles.textFirstRow);\n        }\n\n        // Generate HTML manually as it is much faster when\n        // creating large numbers of elements, such as these spans.\n        const html = this._renderedHtml\n            ? this._renderedHtml\n            : this.generateHtml(this.props, this.state);\n        if (!this._renderedHtml) {\n            this._renderedHtml = html;\n        }\n\n        return (\n            <div className={styles.textContainer}>\n                <div\n                    className={classnames(...classes)}\n                    dangerouslySetInnerHTML={html}\n                    onClick={(e) => this.selectedElement(e.target)}\n                    style={{\n                        fontSize: this.props.fontSize,\n                        fontFamily: \"var(--tibetan-fonts2)\",\n                    }}\n                />\n            </div>\n        );\n    }\n}\nexport default withTheme(Text2);\n","import React, { useEffect, useRef } from \"react\";\nimport TextDetailHeading from \"./TextDetailHeadingContainer\";\nimport SplitText from \"lib/SplitText\";\nimport Loader from \"react-loader\";\nimport lengthSplitter from \"lib/text_splitters/lengthSplitter\";\nimport styles from \"components/TextDetail/TextDetail.css\";\nimport { Box, Divider, Slide } from \"@mui/material\";\nimport TableOfContent from \"./TableOfContent/TableOfContent\";\nimport utilStyles from \"css/util.css\";\nimport classnames from \"classnames\";\nimport Placeholder from \"components/utility/Placeholder\";\n\nimport imageStyle from \"components/MediaComponent/Image.css\";\nimport SplitTextComponent from \"./SplitText\";\n\nfunction TextDetail(props) {\n    const ref = useRef();\n    let text = {\n        name: \"\",\n    };\n    if (props.text) {\n        text = props.text;\n    }\n    useEffect(() => {\n        let element = ref.current;\n        element.addEventListener(\"mouseenter\", mouseEnter);\n        return () => {\n            element.removeEventListener(\"mouseenter\", mouseEnter);\n        };\n    }, []);\n\n    function mouseEnter() {\n        if (text.name) {\n            props.changeSelectedWindow(2);\n        }\n    }\n\n    let inlineControls = false;\n    let textComponent = null;\n    let splitText = null;\n    const selectedWindow = props.selectedWindow;\n    if (!props.annotatedText || !props.text || props.loading) {\n        textComponent = (\n            <div key={Math.random()}>\n                <Placeholder />\n            </div>\n        );\n    } else {\n        let limitWidth = false;\n        let splitter;\n        if (props.paginated) {\n            splitter = positionSplitter(props.pageBreaks);\n        } else {\n            splitter = lengthSplitter(800, /^།[\\s]+(?!།[\\s]+)/, 2, 5);\n        }\n\n        let key = 12;\n        splitText = new SplitText(props.annotatedText, splitter);\n        inlineControls = true;\n        textComponent = (\n            <SplitTextComponent\n                splitText={splitText}\n                // annotations={this.props.annotations}\n                // activeAnnotations={this.props.activeAnnotations}\n                // activeAnnotation={this.props.activeAnnotation}\n                limitWidth={limitWidth}\n                // didSelectSegmentIds={props.didSelectSegmentIds}\n                selectedSegmentId={props.selectedSegmentId}\n                annotationPositions={props.annotationPositions}\n                selectedAnnotatedSegments={props?.selectedAnnotatedSegments}\n                // textListVisible={this.props.textListVisible}\n                // showImages={this.props.pageImagesVisible}\n                // imagesBaseUrl={this.props.imagesBaseUrl}\n                selectedWitness={props.selectedWitness}\n                key={key}\n                // selectedSearchResult={this.props.selectedSearchResult}\n                // searchValue={this.props.searchValue}\n                fontSize={props.textFontSize}\n                scrollToId={props.scrollToId}\n                syncIdOnClick={props.syncIdOnClick}\n                textAlignment={props.textAlignment}\n                textAlignmentById={props.textAlignmentById}\n                isPanelLinked={props.isPanelLinked}\n                changeScrollToId={props.changeScrollToId}\n                changeSyncIdOnClick={props.changeSyncIdOnClick}\n                selectedWindow={selectedWindow}\n                selectedSourceRange={props.selectedSourceRange}\n                selectedTargetRange={props.selectedTargetRange}\n                changeSelectedRange={props.changeSelectedRange}\n                searchResults={props.searchResults}\n                searchValue={props.searchValue}\n                selectedText={props.text}\n                syncIdOnSearch={props.syncIdOnSearch}\n                condition={props.condition}\n            ></SplitTextComponent>\n        );\n    }\n\n    let textComponents = [textComponent];\n    let thirdWindowHeight = imageStyle.ThirdWindowHeight;\n    let bodyHeight = \"calc(100% - \" + thirdWindowHeight + \")\";\n    // let condition = props.isPanelVisible;\n    return (\n        <Box\n            ref={ref}\n            className={styles.textDetail}\n            sx={{\n                height: \"100%\",\n                flex: 1,\n                bgcolor: \"navbar.main\",\n                color: \"texts.main\",\n            }}\n        >\n            <TextDetailHeading />\n            <Divider />\n            <Loader loaded={!props.loading} zIndex={5} />\n            <Box\n                style={{\n                    display: \"flex\",\n                    height: \"100%\",\n                    width: \"100%\",\n                    position: \"relative\",\n                }}\n            >\n                <Box\n                    className={classnames(\n                        styles.textContainer,\n                        utilStyles.flex\n                    )}\n                >\n                    {!props.loading ? textComponents : <div />}\n                </Box>\n                <Slide\n                    direction=\"left\"\n                    in={props.showTableContent}\n                    container={ref.current}\n                    unmountOnExit\n                    mountOnEnter\n                >\n                    <Box\n                        sx={{\n                            position: \"absolute\",\n                            height: \"100%\",\n                            minWidth: \"50%\",\n                            right: 0,\n                        }}\n                    >\n                        <TableOfContent />\n                    </Box>\n                </Slide>\n            </Box>\n        </Box>\n    );\n}\n\nexport default TextDetail;\n","// @flow\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport TextDetail from \"./TextDetail\";\nimport * as actions from \"actions\";\nimport * as reducers from \"reducers\";\nimport AnnotatedText from \"lib/AnnotatedText\";\nimport _ from \"lodash\";\nimport * as TextStore2 from \"state_helpers/TextStore2\";\nimport {\n    showPageImages,\n    getAnnotationsForWitnessId,\n    getActiveAnnotationsForWitnessId,\n    getActiveAnnotation,\n    getActiveTextAnnotation,\n    getBaseWitness,\n    getWorkingWitness,\n    getSelectedText,\n    annotationFromData,\n    getAnnotationData,\n    getUser,\n    getTextListVisible,\n    getSelectedTextWitnessId,\n    getTextWitnesses,\n    getWitness,\n    hasLoadedWitnessAnnotations,\n    getRemovedDefaultAnnotationsForWitnessId,\n    hasLoadedWitnessAppliedAnnotations,\n    getScrollPosition,\n    getSelectedSearchResult,\n    getTextFontSize,\n    isSecondWindowOpen,\n    getImageData,\n    getSelectedImage,\n    isImagePortrait,\n    isPanelVisible,\n    getSelectedTargetRange,\n    getSelectedSourceRange,\n    getSearchResults2,\n} from \"reducers\";\n\nconst DISMISS_CONTROLS_ON_CLICK = true;\n\nfunction getInsertionKey(annotation) {\n    return [annotation.start, annotation.length].join(\"-\");\n}\n\nlet _posAnnotatedText;\nlet _posAnnotations;\nlet _positions;\nlet _posVersion;\nconst getAnnotationPositions = (\n    annotatedText: AnnotatedText,\n    annotations: Annotation[]\n): { [string]: Annotation[] } => {\n    if (\n        annotatedText === _posAnnotatedText &&\n        annotations === _posAnnotations &&\n        annotatedText.version === _posVersion\n    ) {\n        return _positions;\n    }\n\n    let positions = {};\n    let activeInsertions = {};\n\n    for (let i = 0; i < annotations.length; i++) {\n        let annotation = annotations[i];\n        let [startPos, length] =\n            annotatedText.getPositionOfAnnotation(annotation);\n        if (startPos == null) {\n            continue;\n        }\n        if (length === 0) {\n            if (annotation.isInsertion) {\n                // group with any active insertions at the same position\n                const activeKey = getInsertionKey(annotation);\n                const activeInsertionPositions = activeInsertions[activeKey];\n                if (activeInsertionPositions) {\n                    activeInsertionPositions.map((pos) =>\n                        positions[pos].push(annotation)\n                    );\n                    continue;\n                }\n                startPos = INSERTION_KEY + startPos;\n            }\n            if (annotation.isDeletion && annotation.length > 0) {\n                // active deletion\n                startPos = DELETION_KEY + startPos;\n            }\n            if (annotation.type === ANNOTATION_TYPES.pageBreak) {\n                startPos = PAGE_BREAK_KEY + startPos;\n            }\n            if (annotation.type === ANNOTATION_TYPES.lineBreak) {\n                startPos = LINE_BREAK_KEY + startPos;\n            }\n            if (positions[startPos] === undefined) {\n                positions[startPos] = [];\n            }\n            if (positions[startPos].indexOf(annotation) === -1) {\n                positions[startPos].push(annotation);\n            }\n        } else {\n            let annotationPositions = [];\n            for (let j = startPos; j < startPos + length; j++) {\n                if (positions[j] === undefined) {\n                    positions[j] = [];\n                }\n                if (positions[j].indexOf(annotation) === -1) {\n                    positions[j].push(annotation);\n                }\n                annotationPositions.push(j);\n            }\n            // Store the positions this annotation is displayed at.\n            // This can then be used later to group with inactive insertions\n            if (annotation.isInsertion) {\n                const key = getInsertionKey(annotation);\n                activeInsertions[key] = annotationPositions;\n            }\n        }\n    }\n\n    _posAnnotatedText = annotatedText;\n    _posAnnotations = annotations;\n    _positions = positions;\n    _posVersion = annotatedText.version;\n    return positions;\n};\n\nconst mapStateToProps = (state: AppState): {} => {\n    let selectedWitness = {};\n    let annotatedText = null;\n    let workingWitness;\n    let textFontSize = reducers.getTextFontSize2(state);\n    let selectedText = reducers.getSelectedText2(state);\n    let annotationPositions = {};\n    let annotations = [];\n    if (selectedText) {\n        workingWitness =\n            reducers.getWorkingWitness2(state, selectedText.id) || {};\n        let selectedWitnessId = reducers.getSelectedTextWitnessId2(\n            state,\n            selectedText.id\n        );\n        if (selectedWitnessId) {\n            selectedWitness = reducers.getWitness2(state, selectedWitnessId);\n        }\n        if (_.isEmpty(selectedWitness) && !_.isEmpty(workingWitness));\n        {\n            selectedWitness = workingWitness;\n        }\n    }\n\n    annotatedText = TextStore2.getWitnessText(state, selectedWitness?.id);\n\n    const loading = state.data2.loadingWitnesses;\n\n    if (annotatedText) {\n        annotationPositions = getAnnotationPositions(\n            annotatedText,\n            (Object.values(annotations): any)\n        );\n    }\n    const isPanelLinked = reducers.isPanelLinked(state);\n    const scrollToId = reducers.getScrollToId(state);\n    const syncIdOnClick = reducers.getSyncIdOnClick(state);\n    const textAlignment = reducers.getTextAlignment(state);\n    const selectedWindow = reducers.getSelectedWindow(state);\n    const searchValue = reducers.getSearchValue2(state);\n    const isSecondWindowOpen = reducers.isSecondWindowOpen(state);\n    const condition = reducers.getConditionForAlignment(state);\n\n    return {\n        text: selectedText,\n        textFontSize,\n        annotatedText,\n        selectedWitness,\n        loading,\n        annotationPositions,\n        imageData: getImageData(state),\n        selectedImage: getSelectedImage(state),\n        isImagePortrait: isImagePortrait(state),\n        scrollToId,\n        syncIdOnClick,\n        textAlignment,\n        textAlignmentById: reducers.getTextAlignmentById(state),\n        selectedWindow,\n        selectedSourceRange: getSelectedSourceRange(state),\n        selectedTargetRange: getSelectedTargetRange(state),\n        showTableContent: reducers.getShowTableContent2(state),\n        searchResults: getSearchResults2(state, searchValue),\n        searchValue,\n        syncIdOnSearch: reducers.getSyncIdOnSearch2(state),\n        condition: condition && isPanelLinked && isSecondWindowOpen,\n    };\n};\n\nconst mergeProps = (stateProps, dispatchProps, ownProps) => {\n    const { annotatedText, annotationPositions } = stateProps;\n    const { dispatch } = dispatchProps;\n\n    const isDeletion = (id) => {\n        return id.indexOf(\"ds2_\") !== -1;\n    };\n    const isInsertion = (id) => {\n        return id.indexOf(\"i2_\") !== -1;\n    };\n    const isPageBreak = (id) => {\n        return id.indexOf(\"p2_\") !== -1;\n    };\n\n    const isLineBreak = (id) => {\n        return id.indexOf(\"l2_\") !== -1;\n    };\n\n    const idFromSegmentId = (id) => {\n        let start = 0;\n        if (isInsertion(id)) {\n            start = id.substr(2);\n        } else if (isDeletion(id)) {\n            start = id.substr(3);\n        } else {\n            start = id.substr(2);\n        }\n\n        return start;\n    };\n\n    const didSelectSegmentPosition = (segmentPosition, start, length) => {\n        let segmentAnnotations = annotationPositions[segmentPosition];\n        let segmentVariants = [];\n        let segmentPageBreaks = [];\n        let segmentLineBreaks = [];\n        if (segmentAnnotations) {\n            segmentVariants = segmentAnnotations.filter(\n                (annotation: Annotation) =>\n                    annotation.type === ANNOTATION_TYPES.variant\n            );\n            segmentPageBreaks = segmentAnnotations.filter(\n                (annotation: Annotation) =>\n                    annotation.type === ANNOTATION_TYPES.pageBreak\n            );\n            segmentLineBreaks = segmentAnnotations.filter(\n                (annotation: Annotation) =>\n                    annotation.type === ANNOTATION_TYPES.lineBreak\n            );\n        }\n        let activeAnnotations = _.intersectionWith(\n            segmentVariants.concat(segmentPageBreaks, segmentLineBreaks),\n            annotatedText.annotations,\n            (a, b) => a.toString() == b.toString()\n        );\n        let activeAnnotation = null;\n        if (activeAnnotations.length > 0) {\n            // get any active annotations\n            activeAnnotation = activeAnnotations[0];\n        } else if (segmentVariants && segmentVariants.length > 0) {\n            // get base text annotation for longest annotation highlighted in text\n            let longestAvailable = getLongestAnnotation(segmentVariants);\n            let [start, textLength] =\n                annotatedText.getPositionOfAnnotation(longestAvailable);\n            if (longestAvailable && longestAvailable.isInsertion) {\n                textLength = 0;\n            }\n            activeAnnotation = annotatedText.getBaseAnnotation(\n                start,\n                textLength\n            );\n        } else {\n            // get base annotation of just the segment\n            activeAnnotation = annotatedText.getBaseAnnotation(start, length);\n        }\n\n        // dispatch(actions.changedActiveTextAnnotation(activeAnnotation));\n    };\n\n    return {\n        ...ownProps,\n        ...stateProps,\n        onChangedFontSize: (fontSize: number) => {\n            dispatch(actions.changedTextFontSize(fontSize));\n        },\n\n        didSelectSegmentIds: (segmentIds) => {\n            if (segmentIds.length === 0) {\n                return;\n            }\n            let segmentAnnotations = [];\n            let segments = [];\n            for (let segmentId of segmentIds) {\n                if (isDeletion(segmentId) || isInsertion(segmentId)) {\n                    continue;\n                }\n\n                let segmentPosition = idFromSegmentId(segmentId);\n                let textSegment =\n                    annotatedText.segmentedText.segmentAtPosition(\n                        segmentPosition\n                    );\n                segments.push(textSegment);\n                const annotations = annotationPositions[textSegment.start];\n                if (annotations) {\n                    segmentAnnotations = segmentAnnotations.concat(annotations);\n                }\n            }\n            segmentAnnotations = _.uniqWith(\n                segmentAnnotations,\n                (a, b) => a.toString() == b.toString()\n            );\n\n            let activeAnnotations = _.intersectionWith(\n                segmentAnnotations,\n                annotatedText.annotations,\n                (a, b) => a.toString() == b.toString()\n            );\n\n            const range = getSegmentsRange(\n                segments,\n                activeAnnotations,\n                segmentAnnotations,\n                stateProps.annotatedText\n            );\n            if (!range) {\n                console.warn(\n                    \"No range for selected segment ids: %o\",\n                    segmentIds\n                );\n                return;\n            }\n            const baseAnnotation = annotatedText.getBaseAnnotation(\n                range.start,\n                range.length\n            );\n            let activeAnnotation = null;\n            if (range.annotation) {\n                activeAnnotation = range.annotation;\n            } else if (activeAnnotations.length > 0) {\n                const content = annotatedText.segmentedText\n                    .segmentsInRange(range.start, range.length)\n                    .reduce((content, segment) => content + segment.text, \"\");\n                // TODO: test this when editing non-working edition.\n                // Check if getTextWorkingWitness works as required\n                if (!stateProps.selectedWitness) {\n                    console.log(\n                        \"no stateProps.selectedWitness: %o\",\n                        stateProps.selectedWitness\n                    );\n                }\n                activeAnnotation = new Annotation(\n                    WORKING_VERSION_ANNOTATION_ID,\n                    getTextWorkingWitness(stateProps.text),\n                    baseAnnotation.start,\n                    baseAnnotation.length,\n                    content,\n                    ANNOTATION_TYPES.variant,\n                    stateProps.selectedWitness,\n                    stateProps.user\n                );\n            } else {\n                activeAnnotation = baseAnnotation;\n            }\n            // dispatch(changedActiveTextAnnotation(activeAnnotation));\n        },\n        changeScrollToId: (payload) =>\n            dispatch(actions.changeScrollToId(payload)),\n        changeSyncIdOnClick: (payload) => {\n            dispatch(actions.changeSyncIdOnClick(payload));\n        },\n        changeSelectedWindow: (payload) => {\n            dispatch(actions.changeSelectedWindow(payload));\n        },\n        changeSelectedRange: (payload) => {\n            dispatch(actions.changeSelectedRange(payload));\n        },\n        changeShowTableContent: (payload) => {\n            dispatch(actions.showTableContent2(payload));\n        },\n        selectedSegmentId: (segmentId) => {\n            let start = idFromSegmentId(segmentId);\n            let positionKey = start;\n            if (isInsertion(segmentId)) {\n                positionKey = INSERTION_KEY + start;\n            } else if (isDeletion(segmentId)) {\n                positionKey = DELETION_KEY + start;\n            } else if (isPageBreak(segmentId)) {\n                positionKey = PAGE_BREAK_KEY + start;\n            } else if (isLineBreak(segmentId)) {\n                positionKey = LINE_BREAK_KEY + start;\n            }\n\n            let segmentAnnotations = annotationPositions[positionKey];\n            if (DISMISS_CONTROLS_ON_CLICK && stateProps.activeAnnotation) {\n                const activeAnnotation = stateProps.activeAnnotation;\n                if (activeAnnotation) {\n                    const dismissTextAnnotation =\n                        actions.changedActiveTextAnnotation(null);\n                    dispatch(dismissTextAnnotation);\n                }\n            }\n            //  else {\n            //     if (\n            //         isInsertion(segmentId) ||\n            //         isDeletion(segmentId) ||\n            //         isPageBreak(segmentId) ||\n            //         isLineBreak(segmentId)\n            //     ) {\n            //         const length = 0;\n            //         didSelectSegmentPosition(positionKey, start, length);\n            //     } else {\n            //         let segmentPosition = Number(idFromSegmentId(segmentId));\n            //         let textSegment = annotatedText.segmentedText.segmentAtPosition(\n            //             segmentPosition\n            //         );\n            //         if (textSegment) {\n            //             didSelectSegmentPosition(\n            //                 textSegment.start,\n            //                 textSegment.start,\n            //                 textSegment.length\n            //             );\n            //         }\n            //     }\n            // }\n        },\n    };\n};\n\nconst TextDetailContainer = connect(\n    mapStateToProps,\n    null,\n    mergeProps\n)(TextDetail);\n\nexport default React.memo(TextDetailContainer);\n","import React, { useState, useCallback, useRef, useEffect } from \"react\";\nimport styles from \"./textDetailHeading.css\";\nimport SelectVersion from \"./SelectVersion\";\nimport Slider from \"../UI/Slider\";\nimport TextList from \"./TextListContainer\";\nimport OptionsIcon from \"images/options.svg\";\nimport Settings from \"./HeaderMenu/Settings\";\nimport Search from \"./HeaderMenu/Search\";\nimport TableOfContent from \"./HeaderMenu/TableOfContent\";\nimport _ from \"lodash\";\nimport CloseIcon from \"@mui/icons-material/Close\";\n\nimport {\n    Stack,\n    Box,\n    TextField,\n    Button,\n    Collapse,\n    Divider,\n    ButtonGroup,\n    ListItem,\n    List,\n    IconButton,\n} from \"@mui/material\";\nimport Refresh from \"./HeaderMenu/Refresh\";\n\nimport SearchList from \"./HeaderMenu/SearchList\";\ntype HeaderProps = {\n    user: {},\n    textFontSize: Number,\n    onChangedFontSize: () => void,\n    searchResults: [],\n};\n\nfunction TextDetailHeading(props: HeaderProps) {\n    const [findvalue, setfindvalue] = useState(\"\");\n    let [showFind, setShowFind] = useState(false);\n    let [visible, setVisible] = useState(false);\n\n    const inputRef = useRef();\n    const headingRef = useRef();\n    const handleListItemClick = (id) => {\n        props.changeSelectSyncId(id);\n    };\n    const debouncedSearch = React.useRef(\n        _.debounce((s) => {\n            props.searchChanged(s);\n        }, 1000)\n    ).current;\n    const handleSearch = useCallback(\n        (e) => {\n            e.preventDefault();\n            debouncedSearch(findvalue);\n            setVisible(true);\n        },\n        [findvalue]\n    );\n\n    const handleWindowSearch = useCallback(() => {\n        setShowFind(!showFind);\n    }, [showFind]);\n\n    useEffect(() => {\n        if (showFind === true) {\n            inputRef.current.focus();\n        }\n\n        if (showFind === false) debouncedSearch(null);\n    }, [showFind]);\n\n    const closeSearchItemBox = () => {\n        setVisible(false);\n        debouncedSearch(null);\n        setfindvalue(\"\");\n    };\n\n    let condition =\n        _.isObject(props.searchResults) &&\n        props.searchResults.hasOwnProperty(props.selectedText.id);\n    let results = condition\n        ? props.searchResults[props.selectedText.id].results\n        : [];\n    return (\n        <Stack\n            direction=\"column\"\n            ref={headingRef}\n            spacing={1}\n            sx={{\n                paddingInline: { md: 1, xs: 0 },\n                paddingBlock: { md: 1, xs: 0 },\n                borderTop: { md: 0, xs: \"1px solid gray\" },\n                bgcolor: \"heading.main\",\n                color: \"text.primary\",\n            }}\n        >\n            <Stack direction=\"row\" spacing={1} justifyContent=\"space-between\">\n                <Box\n                    sx={{\n                        display: \"flex\",\n                        gap: { md: 2, sx: 0 },\n                        flexDirection: { md: \"row\", xs: \"column\" },\n                    }}\n                >\n                    <TextList />\n                    <SelectVersion\n                        witnesses={props.witnesses}\n                        activeWitness={props.selectedWitness}\n                        onSelectedWitness={props.onSelectedWitness}\n                        user={props.user}\n                    />\n                </Box>\n\n                <ButtonGroup\n                    size=\"small\"\n                    aria-label=\"small button group\"\n                    sx={{\n                        position: \"relative\",\n                        display: \"flex\",\n                        alignItems: \"center\",\n                        justifyContent: \"center\",\n                        height: \"fit-content\",\n                        width: \"fit-content\",\n                        border: (theme) => `1px solid ${theme.palette.divider}`,\n                        borderRadius: 1,\n                        bgcolor: \"background.paper\",\n                        color: \"text.secondary\",\n                        \"& svg\": {\n                            m: 1,\n                        },\n                        \"& hr\": {\n                            mx: 0.5,\n                        },\n                    }}\n                    className={styles.button_group_menu}\n                >\n                    <Refresh isSecondWindowOpen={props.isSecondWindowOpen} />\n\n                    <Search handleWindowSearch={handleWindowSearch} />\n                    <Settings\n                        textFontSize={props.textFontSize}\n                        onChangedFontSize={props.onChangedFontSize}\n                        onExport={props.onExport}\n                    />\n                    <TableOfContent\n                        changeShowTableContent={props.changeShowTableContent}\n                        showTableContent={props.showTableContent}\n                    />\n                </ButtonGroup>\n            </Stack>\n            <Collapse in={showFind} mountOnEnter unmountOnExit>\n                <form onSubmit={handleSearch}>\n                    <Stack direction=\"row\" spacing={2} position=\"relative\">\n                        <TextField\n                            hiddenLabel\n                            id=\"filled-hidden-label-small\"\n                            inputProps={{\n                                style: {\n                                    height: 25,\n                                    padding: \"0 14px\",\n                                },\n                            }}\n                            style={{ height: 25, flex: 1 }}\n                            fullWidth\n                            inputRef={inputRef}\n                            value={findvalue}\n                            onChange={(e) => setfindvalue(e.target.value)}\n                        />\n                        <Button\n                            variant=\"outlined\"\n                            size=\"small\"\n                            onClick={handleSearch}\n                            style={{ height: 25 }}\n                        >\n                            Search\n                        </Button>\n                        {props.searchResults && visible && (\n                            <Box\n                                sx={{\n                                    position: \"absolute\",\n                                    top: 35,\n                                    right: 0,\n                                    zIndex: 1,\n                                    bgcolor: \"heading.main\",\n                                    width: 350,\n                                    height: 350,\n                                    boxShadow: 3,\n                                    overflowX: \"hidden\",\n                                    boxShadow: 3,\n                                }}\n                            >\n                                {results.length === 0 && (\n                                    <p>no such word present</p>\n                                )}\n                                {condition && results.length > 0 && (\n                                    <SearchList\n                                        handleListItemClick={\n                                            handleListItemClick\n                                        }\n                                        searchValue={props.searchValue}\n                                        results={results}\n                                        selectedText={props.selectedText}\n                                    />\n                                )}\n                                <IconButton\n                                    aria-label=\"closeButton\"\n                                    onClick={closeSearchItemBox}\n                                    size=\"small\"\n                                    sx={{\n                                        right: 15,\n                                        top: 0,\n                                        position: \"absolute\",\n                                    }}\n                                >\n                                    <CloseIcon fontSize=\"inherit\" />\n                                </IconButton>\n                            </Box>\n                        )}\n                    </Stack>\n                </form>\n            </Collapse>\n        </Stack>\n    );\n}\n\nexport default TextDetailHeading;\n","// @flow\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport TextDetailHeading from \"./TextDetailHeading\";\nimport * as actions from \"actions\";\nimport * as reducers from \"reducers\";\nimport type { AppState } from \"reducers\";\nimport {\n    getTextListVisible,\n    getAccountOverlayVisible,\n    getShowTableContent2,\n} from \"reducers\";\n\nconst mapStateToProps = (state: AppState): {} => {\n    const user = reducers.getUser(state);\n    const selectedText = reducers.getSelectedText2(state);\n    let witnesses = [];\n    let exportingWitness = false;\n    let selectedWitness;\n    if (selectedText) {\n        witnesses = reducers.getTextWitnesses2(state, selectedText.id);\n        const selectedWitnessId = reducers.getSelectedTextWitnessId2(\n            state,\n            selectedText.id\n        );\n        if (selectedWitnessId) {\n            selectedWitness = reducers.getWitness2(state, selectedWitnessId);\n            // exportingWitness = reducers.getExportingWitness(\n            //     state,\n            //     selectedWitnessId\n            // );\n        } else {\n            selectedWitness = reducers.getWorkingWitness2(\n                state,\n                selectedText.id\n            );\n        }\n    }\n    let textFontSize = reducers.getTextFontSize2(state);\n    let showTableContent = getShowTableContent2(state);\n    let searchValue = reducers.getSearchValue2(state);\n    return {\n        witnesses,\n        selectedText,\n        selectedWitness,\n        textListIsVisible: getTextListVisible(state),\n        accountOverlayVisible: getAccountOverlayVisible(state),\n        textFontSize,\n        user,\n        searchValue,\n        showTableContent,\n        searchResults: reducers.getSearchResults2(state, searchValue),\n    };\n};\n\nconst mergeProps = (stateProps, dispatchProps, ownProps) => {\n    const navigationButtonClicked = () => {\n        dispatchProps.dispatch(\n            actions.changedTextListVisible(!stateProps.textListIsVisible)\n        );\n    };\n\n    const { dispatch } = dispatchProps;\n    const { selectedText } = stateProps;\n\n    return {\n        ...ownProps,\n        ...stateProps,\n        navigationButtonClicked,\n        onSelectedWitness: (witness: Witness) => {\n            dispatch(\n                actions.selectedTextWitness2(selectedText?.id, witness?.id)\n            );\n        },\n        onChangedFontSize: (fontSize: number) => {\n            dispatch(actions.changedTextFontSize2(fontSize));\n        },\n        changeShowTableContent: (payload) => {\n            dispatch(actions.showTableContent2(payload));\n        },\n        searchChanged: (searchTerm: string) => {\n            dispatch(actions.changedSearchValue2(searchTerm));\n        },\n        changeSelectSyncId: (payload) => {\n            dispatch(actions.changeSyncIdOnSearch2(payload));\n        },\n    };\n};\n\nconst TextDetailHeadingContainer = connect(\n    mapStateToProps,\n    null,\n    mergeProps\n)(TextDetailHeading);\n\nexport default TextDetailHeadingContainer;\n","import React, { useState, useRef, useEffect } from \"react\";\nimport {\n    List,\n    AutoSizer,\n    CellMeasurer,\n    CellMeasurerCache,\n} from \"react-virtualized\";\nimport classname from \"classnames\";\nimport styles from \"./TextList.css\";\nimport addShay from \"lib/addTibetanShay\";\n\nimport {\n    TextField,\n    ClickAwayListener,\n    Box,\n    Typography,\n    Button,\n    Grow,\n} from \"@mui/material\";\nimport { useMemo } from \"react\";\nfunction TextList(props) {\n    const temptext = useRef(props.texts);\n    const [textslist, setTextList] = useState(temptext.current);\n    const [filterValue, setFilterValue] = useState(null);\n    const onSelectedText = props.onSelectedText;\n    const selectedText = props.selectedText;\n    const [isOpen, setIsOpen] = useState(false);\n\n    let selected = selectedText?.name;\n    let selectedText1 = props.selectedText1;\n    useEffect(() => {\n        let temp = [];\n        if (filterValue === \"\") {\n            setTextList([...temptext.current]);\n        }\n        if (filterValue !== null && filterValue !== \"\") {\n            temp = temptext.current.filter((val) => {\n                return val.name.includes(filterValue);\n            });\n            setTextList([...temp]);\n        }\n    }, [filterValue]);\n\n    const cache = useRef(\n        new CellMeasurerCache({\n            fixedHeight: true,\n            defaultHeight: 40,\n        })\n    );\n\n    let classes = [styles.textlist];\n\n    const handleClick = () => {\n        setIsOpen((prev) => !prev);\n        if (isOpen === false) classes.push(styles.open);\n    };\n    const handleChange = (e) => {\n        let value = e.target.value;\n        setFilterValue(value);\n    };\n    const rowRenderer = React.useCallback(\n        ({ key, index, style, parent }) => {\n            let data = textslist[index];\n            return (\n                <CellMeasurer\n                    key={`optionvalues-${key}`}\n                    cache={cache.current}\n                    parent={parent}\n                    columnIndex={0}\n                    rowIndex={index}\n                >\n                    <div\n                        style={style}\n                        onClick={() => {\n                            setIsOpen(false);\n                            onSelectedText(data);\n                        }}\n                    >\n                        <Box\n                            sx={{\n                                overflow: \"hidden\",\n                                textOverflow: \"ellipsis\",\n                                width: \"13rem\",\n                                paddingLeft: 2,\n                                fontSize: {\n                                    lg: 12,\n                                    md: 11,\n                                    sm: 10,\n                                    xs: 10,\n                                },\n                                color: \"text.primary\",\n                            }}\n                            component=\"div\"\n                        >\n                            <Typography noWrap={true}>\n                                {addShay(data.name)}\n                            </Typography>\n                        </Box>\n                    </div>\n                </CellMeasurer>\n            );\n        },\n        [textslist]\n    );\n    return (\n        <ClickAwayListener onClickAway={() => setIsOpen(false)}>\n            <div style={{ position: \"relative\", marginLeft: 10 }}>\n                <Button\n                    onClick={handleClick}\n                    component=\"div\"\n                    variant=\"outlined\"\n                    sx={{\n                        overflow: \"hidden\",\n                        textOverflow: \"ellipsis\",\n                        width: \"10rem\",\n                        height: \"100%\",\n                        color: \"text.primary\",\n                    }}\n                    disabled={selectedText1 === null}\n                >\n                    <Typography noWrap={true}>\n                        {selected ? selected : \"select Text here\"}\n                    </Typography>\n                </Button>\n                <Grow in={isOpen}>\n                    <Box\n                        className={classname(classes)}\n                        sx={{\n                            position: \"absolute\",\n                            bgcolor: \"heading.main\",\n                            zIndex: 1,\n                        }}\n                    >\n                        <TextField\n                            onChange={handleChange}\n                            id=\"standard-basic\"\n                            label=\"filter\"\n                            variant=\"standard\"\n                            style={{ width: \"100%\" }}\n                        />\n                        <AutoSizer>\n                            {({ width, height }) => (\n                                <List\n                                    width={width}\n                                    height={height}\n                                    rowHeight={40}\n                                    deferredMeasurementCache={cache.current}\n                                    rowCount={textslist.length}\n                                    rowRenderer={rowRenderer}\n                                />\n                            )}\n                        </AutoSizer>\n                    </Box>\n                </Grow>\n            </div>\n        </ClickAwayListener>\n    );\n}\n\nexport default React.memo(TextList);\n","// @flow\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport TextList from \"./TextList\";\nimport * as actions from \"actions\";\nimport { getSelectedText2, getSelectedText } from \"reducers\";\nimport type { AppState } from \"reducers\";\nimport * as api from \"api\";\nimport * as reducers from \"reducers\";\nimport { batchActions } from \"redux-batched-actions\";\n\nconst mapStateToProps = (state: AppState) => {\n    const searchValue = reducers.getSearchValue(state);\n    const searchResults = reducers.getSearchResults(state, searchValue);\n    const selectedSearchResult = reducers.getSelectedSearchResult(state);\n    // TODO: display search results or spinner depending on when anything\n    // returned\n\n    let searching = false;\n    let texts = state.data.texts;\n    if (searchValue.length > 0) {\n        if (searchResults === null) {\n            searching = true;\n            texts = [];\n        } else {\n            texts = texts.filter((text) =>\n                searchResults.hasOwnProperty(text.id)\n            );\n        }\n    }\n\n    return {\n        texts: texts,\n        selectedText1: getSelectedText(state),\n        selectedText: getSelectedText2(state),\n        searchTerm: searchValue,\n        searchResults,\n        selectedSearchResult,\n        searching,\n    };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n    return {\n        onSelectedText: (text: api.TextData) => {\n            dispatch(actions.selectedText2(text));\n        },\n    };\n};\n\nconst TextListContainer = connect(\n    mapStateToProps,\n    mapDispatchToProps\n)(TextList);\n\nexport default TextListContainer;\n","// @flow\nimport * as React from \"react\";\nimport GraphemeSplitter from \"grapheme-splitter\";\nimport reactStringReplace from \"react-string-replace\";\n\ntype Props = {\n    string: string,\n    highlightClass: string,\n    stringClass?: string,\n    searchTerm?: string\n};\n\nexport default class HighlightedString extends React.Component<Props> {\n    constructor(props: Props) {\n        super(props);\n    }\n\n    render() {\n        const string = this.props.string;\n        let nameHtml = string;\n        let stringClass = this.props.stringClass || \"\";\n        if (this.props.searchTerm) {\n            const searchTerm = this.props.searchTerm;\n            const splitter = new GraphemeSplitter();\n            const graphemes = splitter.splitGraphemes(string);\n            const start = string.indexOf(searchTerm);\n            const end = start + searchTerm.length;\n            let position = 0;\n            let foundGraphemes = \"\";\n            if (start > -1) {\n                for (let i = 0; i < graphemes.length; i++) {\n                    let grapheme = graphemes[i];\n                    if (position >= start && position < end) {\n                        foundGraphemes += grapheme;\n                    }\n                    position += grapheme.length;\n                }\n            }\n            if (foundGraphemes.length > 0) {\n                nameHtml = reactStringReplace(\n                    string,\n                    foundGraphemes,\n                    (match, i) => (\n                        <span className={this.props.highlightClass} key={`highlight-${i}`}>\n                            {match}\n                        </span>\n                    )\n                );\n            }\n        }\n        return <span className={stringClass}>{nameHtml}</span>;\n    }\n}\n","// @flow\nimport React from \"react\";\nimport { FormattedMessage, injectIntl } from \"react-intl\";\nimport styles from \"./LoadMore.css\";\n\ntype Props = {\n    loading?: boolean\n};\n\nexport default function LoadMore(props: Props) {\n    let content;\n    if (props.loading) {\n        content = (\n            <span>\n                <FormattedMessage id=\"leftbar.loading\" />\n            </span>\n        );\n    } else {\n        content = (\n            <span>\n                <FormattedMessage id=\"leftbar.loadMore\" />\n            </span>\n        );\n    }\n    return <div className={styles.container}>{content}</div>;\n}\n","// @flow\nimport * as React from \"react\";\nimport styles from \"./TextList.css\";\n\ntype Props = {\n    count: number,\n    extra: boolean\n};\n\nexport default class ResultCount extends React.Component<Props> {\n    constructor(props: Props) {\n        super(props);\n    }\n\n    render() {\n        let countDisplay = this.props.count;\n        if (this.props.extra) countDisplay += \"+\";\n        return <span className={styles.searchTotal}>{countDisplay}</span>;\n    }\n}\n","// @flow\nimport React from \"react\";\nimport classnames from \"classnames\";\nimport { AutoSizer } from \"react-virtualized/dist/es/AutoSizer\";\nimport {\n    CellMeasurer,\n    CellMeasurerCache,\n} from \"react-virtualized/dist/es/CellMeasurer\";\nimport \"react-virtualized/styles.css\"; // only needs to be imported once\nimport { List } from \"react-virtualized/dist/es/List\";\nimport * as api from \"api\";\nimport addTibetanShay from \"lib/addTibetanShay\";\nimport styles from \"./TextList.css\";\nimport Loader from \"react-loader\";\nimport HighlightedString from \"./HighlightedString\";\nimport ResultCount from \"./ResultCount\";\nimport LoadMore from \"./LoadMore\";\n\ntype Props = {\n    selectedText: api.TextData,\n    texts: api.TextData[],\n    onSelectedText: (text: api.TextData) => void,\n    onSelectedSearchResult: (\n        text: api.TextData,\n        start: number,\n        length: number,\n        selectedText: api.TextData\n    ) => void,\n    onSearchText: (text: api.TextData, searchTerm: string) => void,\n    searchTerm: string,\n    searchResults: { [number]: api.TextSearchResultData },\n    selectedSearchResult: null | {\n        textId: number,\n        start: number,\n        length: number,\n    },\n    searching: boolean,\n};\n\nconst DEFAULT_ROW_HEIGHT = 60;\n\nclass TextList extends React.Component<Props> {\n    list: List | null;\n    cache: CellMeasurerCache;\n    rowRenderer: (params: {\n        key: string,\n        index: number,\n        parent: {},\n        style: {},\n    }) => React.Element<CellMeasurer>;\n\n    constructor(props: Props) {\n        super(props);\n        this.cache = new CellMeasurerCache({\n            fixedWidth: true,\n            defaultHeight: DEFAULT_ROW_HEIGHT,\n            minHeight: DEFAULT_ROW_HEIGHT,\n        });\n        this.rowRenderer = this.rowRenderer.bind(this);\n    }\n\n    componentDidUpdate(prevProps: Props): void {\n        this.cache.clearAll();\n        if (this.list) this.list.forceUpdateGrid();\n    }\n    componentDidMount() {}\n\n    rowRenderer({\n        key,\n        index,\n        parent,\n        style,\n    }: {\n        key: string,\n        index: number,\n        parent: {},\n        style: {},\n    }): React.Element<CellMeasurer> {\n        const selectedText = this.props.selectedText;\n        const selectedTextId = selectedText ? selectedText.id : -1;\n        const selectedSearchResult = this.props.selectedSearchResult;\n        const texts = this.props.texts;\n        const onSelectedText = this.props.onSelectedText;\n        const onSelectedSearchResult = this.props.onSelectedSearchResult;\n        const searchTerm = this.props.searchTerm;\n        const searchResults = this.props.searchResults;\n        let className = styles.textListRow;\n\n        const text = texts[index];\n        if (text.id === selectedTextId) {\n            className = classnames(className, styles.selectedRow);\n        }\n        let name = addTibetanShay(text.name);\n        let nameHtml = <span className={styles.textName}>{name}</span>;\n        let textSearchResults = [];\n        let resultsCount = null;\n        let extraRemaining = false;\n        let loadingResults = false;\n\n        if (searchTerm.length > 0) {\n            nameHtml = (\n                <HighlightedString\n                    string={name}\n                    stringClass={styles.textName}\n                    highlightClass={styles.highlight}\n                    searchTerm={searchTerm}\n                />\n            );\n            if (searchResults.hasOwnProperty(text.id)) {\n                textSearchResults = searchResults[text.id].results;\n                extraRemaining = searchResults[text.id].extra;\n                loadingResults = searchResults[text.id].loading;\n                resultsCount = (\n                    <ResultCount\n                        count={searchResults[text.id].total}\n                        extra={extraRemaining}\n                    />\n                );\n            }\n        }\n\n        const cache = this.cache;\n\n        let textSearchResultRows = [];\n        if (textSearchResults.length > 0) {\n            textSearchResultRows = textSearchResults.map((result) => {\n                const isSelected =\n                    selectedSearchResult &&\n                    selectedSearchResult.textId === text.id &&\n                    selectedSearchResult.start === result[0];\n                const className = isSelected\n                    ? styles.selectedSearchResult\n                    : styles.searchResult;\n                if (isSelected) {\n                    // TODO: keeps getting rendered when selecting a syllable\n                    // console.log(\"got selected result: %o\", result);\n                }\n                return (\n                    <div\n                        key={text.id + \"_\" + result[0]}\n                        onClick={() => {\n                            onSelectedSearchResult(\n                                text,\n                                result[0],\n                                searchTerm.length,\n                                selectedText\n                            );\n                        }}\n                        className={className}\n                    >\n                        <HighlightedString\n                            string={result[1]}\n                            highlightClass={styles.highlight}\n                            searchTerm={searchTerm}\n                        />\n                    </div>\n                );\n            });\n        }\n\n        const searchText = () => {\n            this.props.onSearchText(text, searchTerm);\n        };\n        if (searchResults !== null)\n            return (\n                <CellMeasurer\n                    columnIndex={0}\n                    key={key}\n                    parent={parent}\n                    rowIndex={index}\n                    cache={cache}\n                >\n                    <div\n                        key={`listkeys-${key}`}\n                        style={style}\n                        className={className}\n                    >\n                        {searchTerm && (\n                            <div\n                                className={styles.textNameRow}\n                                onClick={() => {\n                                    onSelectedText(texts[index]);\n                                }}\n                            >\n                                {nameHtml} {resultsCount}\n                            </div>\n                        )}\n                        {textSearchResults.length > 0 && (\n                            <div className={styles.searchResults}>\n                                {textSearchResultRows}\n                            </div>\n                        )}\n                        {extraRemaining && (\n                            <div\n                                className={styles.loadMore}\n                                onClick={searchText}\n                            >\n                                <LoadMore loading={loadingResults} />\n                            </div>\n                        )}\n                    </div>\n                </CellMeasurer>\n            );\n        else return null;\n    }\n    findRowHeight({ searchTerm }) {\n        return searchTerm ? null : 40;\n    }\n    render() {\n        const texts = this.props.texts;\n        let rowCount = texts.length;\n        return (\n            <div className={styles.textList}>\n                {this.props.texts && this.props.texts.length > 0 ? (\n                    <AutoSizer>\n                        {({ height, width }) => (\n                            <List\n                                ref={(list) => (this.list = list)}\n                                height={height}\n                                rowCount={rowCount}\n                                rowHeight={\n                                    this.findRowHeight(this.props) ||\n                                    this.cache.rowHeight\n                                }\n                                rowRenderer={this.rowRenderer}\n                                width={width}\n                                overscanRowCount={1}\n                                deferredMeasurementCache={this.cache}\n                            ></List>\n                        )}\n                    </AutoSizer>\n                ) : this.props.searching ? (\n                    <div className={styles.textListLoader}>\n                        <Loader loaded={!this.props.searching} scale={0.5} />\n                        <p className={styles.searching}>Searching…</p>\n                    </div>\n                ) : (\n                    <ul className=\"textList\" />\n                )}\n            </div>\n        );\n    }\n}\n\nexport default TextList;\n","// @flow\nimport React from \"react\";\nimport classnames from \"classnames\";\nimport styles from \"components/TextList/TextListTab.css\";\n\ntype Props = {\n    textListIsVisible: boolean,\n    tabClicked: (e: SyntheticEvent<>) => void\n};\n\nconst TextListTab = (props: Props) => {\n    let tabClassnames = [styles.tab];\n    if (props.textListIsVisible) {\n        tabClassnames.push(styles.hideTab);\n    } else {\n        tabClassnames.push(styles.showTab);\n    }\n    return (\n        <div\n            className={classnames(...tabClassnames)}\n            onClick={props.tabClicked}\n        >\n            Text List\n        </div>\n    );\n};\n\nexport default TextListTab;\n","// @flow\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport { batchActions } from \"redux-batched-actions\";\n\nimport { getTextListVisible } from \"reducers\";\nimport { changedTextListVisible, changedActiveAnnotation } from \"actions\";\n\nimport TextListTab from \"components/TextList/TextListTab\";\n\nconst mapStateToProps = state => {\n    return {\n        textListIsVisible: getTextListVisible(state)\n    };\n};\n\nconst mapStateToDispatch = dispatch => {\n    return {\n        tabClicked: () => {\n            const textListIsVisible = true;\n            dispatch(changedTextListVisible(textListIsVisible));\n        }\n    };\n};\n\nconst TextListTabContainer = connect(mapStateToProps, mapStateToDispatch)(\n    TextListTab\n);\n\nexport default TextListTabContainer;\n","// @flow\nimport React, { useTransition } from \"react\";\nimport styles from \"./TextsSearch.css\";\nimport * as constants from \"app_constants\";\n\nimport { injectIntl } from \"react-intl\";\nimport Button from \"components/UI/Button\";\nimport SearchIcon from \"images/search.svg\";\n\ntype Props = {\n    searchValue: string,\n    searchChanged: (searchTerm: string) => void,\n    selectedSearchOption?: (e: SyntheticEvent<HTMLSelectElement>) => void,\n    minimiseButtonClicked: () => void,\n    intl: { formatMessage: ({ [id: string]: string }) => string },\n    searchTerm: string,\n    textListWidth: number,\n};\n\nconst TextsSearch = (props: Props) => {\n    let textInput: { current: null | HTMLInputElement } = React.createRef();\n    const [ispending, startTransition] = useTransition();\n\n    const initiateSearch = (e: SyntheticEvent<HTMLElement>) => {\n        e.preventDefault();\n        if (textInput.current instanceof HTMLInputElement) {\n            const searchTerm = textInput.current.value;\n            startTransition(() => {\n                props.searchChanged(searchTerm);\n            });\n        }\n    };\n\n    const handleChange = (e) => {\n        startTransition(() => {\n            if (e.target.value === \"\") {\n                props.searchChanged(null);\n                return;\n            }\n            props.searchChanged(e.target.value);\n        });\n    };\n    console.log(props.textListWidth);\n    return (\n        <div\n            className={styles.textsSearchContainer}\n            style={{ maxWidth: props.textListWidth }}\n        >\n            <div className={styles.textsSearch}>\n                <form onSubmit={initiateSearch}>\n                    <input\n                        onChange={handleChange}\n                        style={{ outline: \"none\", width: 150 }}\n                        type=\"text\"\n                        id=\"textSearchInput\"\n                        placeholder={props.intl.formatMessage({\n                            id: \"leftbar.search\",\n                        })}\n                        ref={textInput}\n                    />\n                    <Button\n                        backgroundColor=\"#35BF5C\"\n                        onClick={initiateSearch}\n                        // title={props.intl.formatMessage({\n                        //     id: \"leftbar.search\",\n                        // })}\n                        noBezel={true}\n                        icon={<SearchIcon />}\n                    />\n                </form>\n            </div>\n        </div>\n    );\n};\n\nexport default injectIntl(TextsSearch);\n","// @flow\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport TextsSearch from \"./TextsSearch\";\nimport { changedSearchValue } from \"actions\";\nimport type { AppState } from \"reducers\";\nimport * as reducers from \"reducers\";\nconst mapStateToProps = (state: AppState) => {\n    return {\n        searchTerm: reducers.getSearchValue(state),\n        searchValue: state.ui.searchValue,\n        textListWidth: reducers.getTextListWidth(state),\n    };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n    // const { dispatch } = dispatchProps;\n    // const { selectedText } = stateProps;\n    return {\n        searchChanged: (searchTerm: string) => {\n            dispatch(changedSearchValue(searchTerm));\n        },\n    };\n};\n\nconst TextsSearchContainer = connect(\n    mapStateToProps,\n    mapDispatchToProps\n)(TextsSearch);\n\nexport default TextsSearchContainer;\n","import React from \"react\";\nimport styles from \"./Accessory.css\";\nimport colours from \"css/colour.css\";\n\nexport const accessoryTypes = {\n    ADD: \"+\",\n    DELETE: \"\\u00d7\"\n};\nexport type AccessoryType = $Keys<typeof accessoryTypes>;\n\ntype Props = {\n    type: AccessoryType,\n    title?: string,\n    onClick?: () => void,\n    backgroundColor?: string,\n    color?: string\n};\n\nconst Accessory = (props: Props) => {\n    let style = {};\n    style.backgroundColor = props.backgroundColor || \"\";\n    style.color = props.color || \"#fff\";\n\n    return (\n        <div\n            className={styles.accessory}\n            title={props.title}\n            onClick={props.onClick}\n            style={style}\n        >\n            {accessoryTypes[props.type]}\n        </div>\n    );\n};\n\nexport default Accessory;\n","import React from \"react\";\nimport { FormattedMessage, injectIntl } from \"react-intl\";\nimport { Tooltip, Tootip } from \"@mui/material\";\nfunction ApplyTooltip({\n    children,\n    tooltipName,\n    format = null,\n    className = \"\",\n    shortcut = \"\",\n    on = false,\n}) {\n    return (\n        <>\n            <div\n                data-tip\n                data-for={tooltipName}\n                className={className}\n                style={{ width: \"100%\" }}\n            >\n                {!on ? (\n                    <Tooltip\n                        placement=\"top\"\n                        followCursor\n                        title={\n                            format ? (\n                                <FormattedMessage id={format} />\n                            ) : (\n                                <span>\n                                    {tooltipName}\n                                    {` [${shortcut}]`}\n                                </span>\n                            )\n                        }\n                    >\n                        {children}\n                    </Tooltip>\n                ) : (\n                    children\n                )}\n            </div>\n        </>\n    );\n}\n\nexport default ApplyTooltip;\n","import React from \"react\";\nimport classnames from \"classnames\";\nimport colours from \"css/colour.css\";\nimport styles from \"./Button.css\";\nimport Accessory from \"./Accessory\";\nimport ApplyTooltip from \"./ApplyTooltip\";\nexport type Alignment = \"left\" | \"center\" | \"right\";\n\ntype Props = {\n    title: string,\n    color?: string,\n    backgroundColor?: string,\n    icon?: any,\n    align?: Alignment,\n    isActive?: boolean,\n    accessoryType?: AccessoryType,\n    onClick?: () => void,\n    noBezel?: boolean,\n    disabled?: boolean,\n    tooltipTitle: String,\n    shortcut?: String,\n};\n\nexport default class Button extends React.Component<Props> {\n    render() {\n        let color = this.props.color || \"#ffffff\";\n        let bgColour = this.props.backgroundColor || colours.mainTint;\n        let fontSize = this.props.fontSize || \"14px\";\n        let classNames = this.props.noBezel\n            ? [styles.buttonNoBezel]\n            : [styles.button];\n        let tooltipTitle = this.props.tooltipTitle || \"\";\n        if (this.props.isActive) classNames.push(styles.active);\n        const className = classnames(...classNames);\n        let shortcut = this.props.shortcut || \"\";\n        let style = {\n            fontSize,\n            color: color,\n            backgroundColor: bgColour,\n        };\n        if (this.props.align) style.textAlign = this.props.align;\n\n        return (\n            <ApplyTooltip\n                tooltipName={tooltipTitle}\n                shortcut={shortcut}\n                on={this.props.disabled}\n            >\n                <button\n                    style={style}\n                    className={className}\n                    onClick={this.props.onClick}\n                    disabled={this.props.disabled}\n                >\n                    {this.props.icon && (\n                        <div className={styles.icon}>{this.props.icon}</div>\n                    )}\n                    {this.props.title && (\n                        <span className={styles.title}>{this.props.title}</span>\n                    )}\n                    {this.props.accessoryType && (\n                        <Accessory type={this.props.accessoryType} />\n                    )}\n                </button>\n            </ApplyTooltip>\n        );\n    }\n}\n","import React, { useEffect, useState } from \"react\";\nimport styles from \"./Slider.css\";\nimport _ from \"lodash\";\nfunction Slider({\n    max,\n    min,\n    initialvalue,\n    changeSize = (r) => console.log(r),\n}) {\n    let initialPercent = (initialvalue / max) * 100;\n    const [tempValue, setTempValue] = useState(initialPercent);\n    const submitValue = _.debounce((e) => {\n        let currentPercent = (tempValue / 100) * max;\n        changeSize(Math.floor(parseInt(currentPercent)));\n    }, 500);\n\n    return (\n        <div className={styles.inputRanges}>\n            <span\n                style={{ fontSize: 13, top: \"-5px\" }}\n                onClick={() => changeSize(initialvalue - 2)}\n            >\n                ཀ\n            </span>\n            <input\n                type=\"range\"\n                style={{ width: \"70%\" }}\n                className={styles.inputRange}\n                min={40}\n                max={100}\n                smooth=\"yes\"\n                step={1}\n                value={tempValue}\n                onChange={(e) => setTempValue(e.target.value)}\n                onMouseUp={submitValue}\n                onTouchEnd={submitValue}\n            />\n            <span\n                style={{ fontSize: 18, top: \"-10px\" }}\n                onClick={() => changeSize(initialvalue + 2)}\n            >\n                ཀ\n            </span>\n        </div>\n    );\n}\n\nexport default Slider;\n","import React from \"react\";\nimport styles from \"./Placeholder.css\";\nimport ArrowUpwardIcon from \"@mui/icons-material/ArrowUpward\";\nfunction Placeholder() {\n    return (\n        <div className={styles.placeholder}>\n            <ArrowUpwardIcon color=\"inherit\" />\n        </div>\n    );\n}\n\nexport default React.memo(Placeholder);\n","import React, { useEffect } from \"react\";\n\nexport default function DiscourseForum({topicId}) {\n    useEffect(() => {\n        window.DiscourseEmbed = {\n            discourseUrl: \"https://lopenling.org/\",\n            topicId:topicId,\n        };\n        const d = document.createElement(\"script\");\n        d.type = \"text/javascript\";\n        d.async = true;\n        d.src = window.DiscourseEmbed.discourseUrl + \"javascripts/embed.js\";\n        (\n            document.getElementsByTagName(\"head\")[0] ||\n            document.getElementsByTagName(\"body\")[0]\n        ).appendChild(d);\n    }, [topicId]);\n\n    return (\n        <div>\n            <div id=\"discourse-comments\"></div>\n        </div>\n    );\n}\n","import {useState,useEffect} from 'react'\n\nfunction getSavedValue(key,initialValue){\n    const savedValue=JSON.parse(localStorage.getItem(key))\n    if (savedValue) return savedValue\n    \n    // if (initialValue instanceof function) return initialValue()\n\n    return initialValue\n}\n\nexport default function useLocalStorage(key,initialValue){\n    const [value,setValue]=useState(()=>{\n        return getSavedValue(key,initialValue)\n         })\n\n\n         useEffect(()=>{\n        localStorage.setItem(key,JSON.stringify(value))\n         },[value])\n    return [value,setValue]\n\n}","// @flow\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport TextList from \"components/TextList\";\nimport * as actions from \"actions\";\nimport { getSelectedText } from \"reducers\";\nimport type { AppState } from \"reducers\";\nimport * as api from \"api\";\nimport * as reducers from \"reducers\";\nimport { batchActions } from \"redux-batched-actions\";\n\nconst mapStateToProps = (state: AppState) => {\n    const searchValue = reducers.getSearchValue(state);\n    const searchResults = reducers.getSearchResults(state, searchValue);\n    const selectedSearchResult = reducers.getSelectedSearchResult(state);\n    // TODO: display search results or spinner depending on when anything\n    // returned\n\n    let searching = false;\n    let texts = state.data.texts;\n    if (searchValue.length > 0) {\n        if (searchResults === null) {\n            searching = true;\n            texts = [];\n        } else {\n            texts = texts.filter((text) =>\n                searchResults.hasOwnProperty(text.id)\n            );\n        }\n    }\n\n    return {\n        texts: texts,\n        selectedText: getSelectedText(state),\n        searchTerm: searchValue,\n        searchResults,\n        selectedSearchResult,\n        searching,\n    };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n    return {\n        onSelectedText: (text: api.TextData) => {\n            dispatch(actions.selectedText(text));\n        },\n        onSelectedSearchResult: (\n            text: api.TextData,\n            start: number,\n            length: number,\n            selectedText: api.TextData | null\n        ) => {\n            if (!selectedText || selectedText.id !== text.id) {\n                dispatch(\n                    batchActions([\n                        actions.selectedSearchResult(text.id, start, length),\n                        actions.selectedText(text),\n                    ])\n                );\n            } else {\n                dispatch(actions.selectedSearchResult(text.id, start, length));\n            }\n        },\n        onSearchText: (text: api.TextData, searchTerm: string) => {\n            dispatch(actions.searchedText(text.id, searchTerm));\n        },\n    };\n};\n\nconst TextListContainer = connect(\n    mapStateToProps,\n    mapDispatchToProps\n)(TextList);\n\nexport default TextListContainer;\n","// @flow\nimport SegmentedText from \"./SegmentedText\";\nimport AnnotatedText from \"./AnnotatedText\";\n\nexport type Splitter = (string) => number[];\n\nexport default class SplitText {\n    annotatedText: AnnotatedText;\n    splitter: Splitter;\n    _texts: SegmentedText[] | null;\n    _textsId: string | null;\n    _textsFinalPositions: number[];\n\n    constructor(annotatedText: AnnotatedText, splitter: Splitter) {\n        this.annotatedText = annotatedText;\n        this.splitter = splitter;\n        this._texts = null;\n        this._textsId = null;\n        this._textsFinalPositions = [];\n    }\n\n    get texts(): SegmentedText[] {\n        if (!this.annotatedText) {\n            return [];\n        }\n        if (\n            !this._texts ||\n            this._textsId !== this.annotatedText.getUniqueId()\n        ) {\n            this._textsFinalPositions = [];\n            const segmentedText = this.annotatedText.segmentedText;\n            const textString = segmentedText.getText();\n            let splitPositions = this.splitter(textString).filter(\n                (l) => l !== 0\n            );\n            if (splitPositions.length === 0) {\n                this._textsFinalPositions.push(textString.length);\n                return [segmentedText];\n            }\n            let lastPosition = splitPositions[splitPositions.length - 1];\n            if (lastPosition + 1 < textString.length) {\n                splitPositions.push(textString.length - 1);\n            }\n            const segments = segmentedText.segments;\n            let startIndex = 0;\n            let texts = [];\n            for (let i = 0; i < splitPositions.length; i++) {\n                const position = splitPositions[i];\n                const endIndex = segmentedText.indexOfSegmentAtPosition(\n                    position - 1\n                );\n                let textSegments;\n                if (i == splitPositions.length - 1) {\n                    // final position\n                    textSegments = segments.slice(startIndex);\n                } else {\n                    textSegments = segments.slice(startIndex, endIndex + 1);\n                }\n\n                const text = new SegmentedText(textSegments);\n                texts.push(text);\n                startIndex = endIndex + 1;\n                if (endIndex >= 0) {\n                    const finalSegment = segments[endIndex];\n                    this._textsFinalPositions.push(finalSegment.end);\n                }\n            }\n\n            this._texts = texts.filter((l) => l.segments.length > 0);\n            this._textsId = this.annotatedText.getUniqueId();\n        }\n        return this._texts || [];\n    }\n\n    getTextsFinalPositions(): number[] {\n        this.texts;\n        return this._textsFinalPositions;\n    }\n\n    /**\n     * Return the index of the text portion that contains the given position.\n     *\n     * @param position\n     * @returns number\n     */\n    getTextIndexOfPosition(position: number): number {\n        const textsFinalPositions = this.getTextsFinalPositions();\n        let lastPosition = 0;\n        let textIndex = null;\n        for (let i = 0; i < textsFinalPositions.length; i++) {\n            let endPosition = textsFinalPositions[i];\n            if (position >= lastPosition && position <= endPosition) {\n                textIndex = i;\n                break;\n            }\n            lastPosition = endPosition;\n        }\n        if (textIndex === null) {\n            // Likely an insertion at the end of a text\n            console.warn(\"no index for position %d\", position);\n            textIndex = textsFinalPositions.length - 1;\n        }\n        return textIndex;\n    }\n}\n","export default function shallowEqual(objA, objB) {\n    if (objA === objB) {\n        return true;\n    }\n\n    let aKeys = Object.keys(objA);\n    let bKeys = Object.keys(objB);\n    let len = aKeys.length;\n\n    if (bKeys.length !== len) {\n        return false;\n    }\n\n    for (let i = 0; i < len; i++) {\n        let key = aKeys[i];\n\n        if (objA[key] !== objB[key]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n","// @flow\nimport type { Splitter } from \"lib/SplitText\";\n\n/**\n * Returns a function that accepts a string but simply\n * returns the initial array of positions passed to it.\n *\n * @param positions - The positions where a string should be split\n */\nexport default function positionSplitter(positions: number[]): Splitter {\n    const newPositions = [...positions];\n    if (newPositions[0] === 0) {\n        newPositions.shift();\n    }\n    return string => newPositions;\n}\n","// @flow\nimport * as reducers from \"reducers\";\nimport type { AppState } from \"reducers\";\nimport AnnotatedText from \"lib/AnnotatedText\";\nimport Witness from \"lib/Witness\";\nimport Annotation, { ANNOTATION_TYPES } from \"lib/Annotation\";\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\nimport type { AnnotationData, TextData } from \"api\";\nimport segmentTibetanText from \"lib/segmentTibetanText\";\nimport SegmentedText from \"lib/SegmentedText\";\nimport _ from \"lodash\";\n\nlet store: { [witnessId: number]: AnnotatedText } = {};\n\nexport const getWitnessText = (\n    state: AppState,\n    witnessId: number\n): AnnotatedText | null => {\n    let text: AnnotatedText | null = null;\n\n    if (witnessId) {\n        text = generateAnnotatedText(state, witnessId);\n        if (text) {\n            store[witnessId] = text;\n        }\n    }\n\n    return text;\n};\n\nexport const addTextAnnotation = (\n    state: AppState,\n    witnessId: number,\n    annotation: Annotation\n) => {\n    const text = getWitnessText(state, witnessId);\n    if (text) {\n        text.addAnnotation(annotation);\n    }\n    // If witnessId is present, assume that getWitnessAnnotations\n    // has already been called.\n    if (annotationStore.hasOwnProperty(witnessId)) {\n        if (\n            !annotationStore[witnessId].appliedAnnotations.hasOwnProperty(\n                annotation.uniqueId\n            )\n        ) {\n            annotationStore[witnessId].appliedAnnotations[annotation.uniqueId] =\n                annotation;\n        }\n        if (\n            !annotationStore[witnessId].allAnnotations.hasOwnProperty(\n                annotation.uniqueId\n            )\n        ) {\n            annotationStore[witnessId].allAnnotations[annotation.uniqueId] =\n                annotation;\n        }\n    }\n};\n\nexport const removeTextAnnotation = (\n    state: AppState,\n    witnessId: number,\n    annotationId: AnnotationUniqueId\n) => {\n    const text = getWitnessText(state, witnessId);\n    if (text) {\n        text.removeAnnotation(annotationId);\n    }\n    if (annotationStore.hasOwnProperty(witnessId)) {\n        if (\n            annotationStore[witnessId].appliedAnnotations.hasOwnProperty(\n                annotationId\n            )\n        ) {\n            delete annotationStore[witnessId].appliedAnnotations[annotationId];\n        }\n    }\n};\n\nexport const deleteTextAnnotation = (\n    state: AppState,\n    witnessId: number,\n    annotationId: AnnotationUniqueId\n) => {\n    const text = getWitnessText(state, witnessId);\n    if (text) {\n        text.removeAnnotation(annotationId);\n    }\n    if (annotationStore.hasOwnProperty(witnessId)) {\n        if (\n            annotationStore[witnessId].allAnnotations.hasOwnProperty(\n                annotationId\n            )\n        ) {\n            delete annotationStore[witnessId].allAnnotations[annotationId];\n        }\n        if (\n            annotationStore[witnessId].appliedAnnotations.hasOwnProperty(\n                annotationId\n            )\n        ) {\n            delete annotationStore[witnessId].appliedAnnotations[annotationId];\n        }\n    }\n};\n\nlet annotationStore: {\n    [witnessId: number]: {\n        appliedAnnotations: { [AnnotationUniqueId]: Annotation },\n        allAnnotations: { [AnnotationUniqueId]: Annotation },\n    },\n} = {};\n\nexport const getWitnessAnnotations = (\n    state: AppState,\n    witness: Witness,\n    workingWitness: Witness\n): [\n    { [AnnotationUniqueId]: Annotation },\n    { [AnnotationUniqueId]: Annotation }\n] => {\n    if (annotationStore.hasOwnProperty(witness.id)) {\n        return [\n            annotationStore[witness.id].appliedAnnotations,\n            annotationStore[witness.id].allAnnotations,\n        ];\n    }\n\n    const text = witness.text;\n\n    let workingAnnotationList = reducers.getAnnotationsForWitnessId(\n        state,\n        workingWitness.id\n    );\n\n    let appliedAnnotations = getActiveAnnotations(\n        state,\n        witness.id,\n        workingWitness.id\n    );\n\n    let removedDefaultAnnotations = null;\n    // Default annotations removed by the user.\n    // Usually these are available when viewing\n    // a non-working edition.\n    let nonActiveAnnotations = {};\n\n    if (witness.id !== workingWitness.id) {\n        // If we are not viewing the working version,\n        // get all the annotations created by the selected witness\n        // BUT NOT BY A USER to apply to the base text.\n        // User-created annotations need to be in appliedAnnotations.\n\n        removedDefaultAnnotations =\n            reducers.getRemovedDefaultAnnotationsForWitnessId(\n                state,\n                witness.id\n            );\n\n        let selectedWitnessAnnotations = {};\n\n        for (let key in workingAnnotationList) {\n            if (workingAnnotationList.hasOwnProperty(key)) {\n                let annotationData = workingAnnotationList[key];\n                if (\n                    annotationData.creator_witness === witness.id &&\n                    !removedDefaultAnnotations.hasOwnProperty(\n                        annotationData.unique_id\n                    )\n                ) {\n                    selectedWitnessAnnotations[annotationData.unique_id] =\n                        annotationData;\n                } else if (annotationData.creator_witness === witness.id) {\n                    nonActiveAnnotations[annotationData.unique_id] =\n                        annotationData;\n                }\n            }\n        }\n\n        let selectedWitnessAnnotationsList = annotationsMapFromData(\n            state,\n            selectedWitnessAnnotations\n        );\n\n        appliedAnnotations = {\n            ...selectedWitnessAnnotationsList,\n            ...appliedAnnotations,\n        };\n\n        workingAnnotationList = selectedWitnessAnnotations;\n    }\n\n    let annotations = annotationsMapFromData(state, workingAnnotationList);\n    nonActiveAnnotations = annotationsMapFromData(state, nonActiveAnnotations);\n    if (Object.keys(nonActiveAnnotations).length > 0) {\n        annotations = {\n            ...annotations,\n            ...nonActiveAnnotations,\n        };\n    }\n\n    annotations = {\n        ...appliedAnnotations,\n        ...annotations,\n    };\n\n    annotations = _.pickBy(\n        annotations,\n        (annotation: Annotation, key: AnnotationUniqueId) => {\n            return !(\n                witness &&\n                annotation.type === ANNOTATION_TYPES.lineBreak &&\n                annotation.creatorWitness.id !== witness.id\n            );\n        }\n    );\n\n    // Only cache if annotations have been loaded\n    if (\n        reducers.hasLoadedWitnessAnnotations2(state, witness.id) &&\n        reducers.hasLoadedWitnessAppliedAnnotations(state, witness.id)\n    ) {\n        annotationStore[witness.id] = {\n            appliedAnnotations: appliedAnnotations,\n            allAnnotations: annotations,\n        };\n    }\n\n    return [appliedAnnotations, annotations];\n};\n\nconst generateAnnotatedText = (\n    state: AppState,\n    witnessId: number\n): AnnotatedText | null => {\n    const witness = reducers.getWitness2(state, witnessId);\n    if (!witness) {\n        console.warn(\"no witness\");\n        return null;\n    }\n    const text = witness.text;\n    const workingWitness = reducers.getWorkingWitness2(state, text.id);\n    const baseWitness = reducers.getBaseWitness2(state, text.id);\n\n    if (!workingWitness || !baseWitness) {\n        return null;\n    }\n\n    let [appliedAnnotations, availableAnnotations] = getWitnessAnnotations(\n        state,\n        witness,\n        workingWitness\n    );\n    let segmentedWorkingWitness = getSegmentedWitness(workingWitness);\n    let annotatedText = new AnnotatedText(\n        segmentedWorkingWitness,\n        (Object.values(appliedAnnotations): any),\n        (text) => segmentTibetanText(text).segments,\n        workingWitness,\n        witness\n    );\n\n    return annotatedText;\n};\n\nconst getActiveAnnotations = (\n    state: AppState,\n    witnessId,\n    baseWitnessId\n): { [AnnotationUniqueId]: Annotation } => {\n    const loadedAppliedAnnotations =\n        reducers.hasLoadedWitnessAppliedAnnotations(state, witnessId);\n    if (!loadedAppliedAnnotations) {\n        return {};\n    }\n    const activeAnnotationList = reducers.getActiveAnnotationsForWitnessId(\n        state,\n        witnessId\n    );\n    if (!activeAnnotationList) {\n        return {};\n    }\n\n    let activeAnnotationDataList = {};\n    for (let activeAnnotationId in activeAnnotationList) {\n        if (activeAnnotationList.hasOwnProperty(activeAnnotationId)) {\n            let activeAnnotationData = reducers.getAnnotationData(\n                state,\n                baseWitnessId,\n                activeAnnotationId\n            );\n            if (activeAnnotationData) {\n                activeAnnotationDataList[activeAnnotationData.unique_id] =\n                    activeAnnotationData;\n            }\n        }\n    }\n\n    return annotationsMapFromData(state, activeAnnotationDataList);\n};\n\nconst annotationsMapFromData = (\n    state: AppState,\n    annotationList: { [AnnotationUniqueId]: AnnotationData }\n): { [AnnotationUniqueId]: Annotation } => {\n    let annotations = {};\n    for (let key in annotationList) {\n        if (annotationList.hasOwnProperty(key)) {\n            let annotationData = annotationList[key];\n            let annotation = reducers.annotationFromData(state, annotationData);\n            if (annotation) {\n                annotations[key] = annotation;\n            }\n        }\n    }\n    return annotations;\n};\n\n// TODO: clear cache when changing texts\nlet _segmentedWitnesses: { [number]: SegmentedText } = {};\nfunction getSegmentedWitness(witness: Witness): SegmentedText {\n    if (!_segmentedWitnesses[witness.id]) {\n        _segmentedWitnesses[witness.id] = segmentTibetanText(\n            witness.content || \"\"\n        );\n    }\n\n    return _segmentedWitnesses[witness.id];\n}\n","export default __webpack_public_path__ + \"8967124136190c7842d863e4a862a528.png\";","export default __webpack_public_path__ + \"ea9a1cd4d17aad5a9c5bdfde6acaad2e.png\";","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"EditorContainer---container\",\"interface\":\"EditorContainer---interface\",\"listContainer\":\"EditorContainer---listContainer\",\"showListContainer\":\"EditorContainer---showListContainer\",\"hideListContainer\":\"EditorContainer---hideListContainer\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Resizer\":\"resizerStyle---Resizer\",\"horizontal\":\"resizerStyle---horizontal\",\"vertical\":\"resizerStyle---vertical\",\"disabled\":\"resizerStyle---disabled\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"header-height\":\"40px\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"headerHeight\":\"40px\",\"header\":\"Header---header\",\"logo\":\"Header---logo\",\"navigationButton\":\"Header---navigationButton\",\"loginButton\":\"Header---loginButton\",\"ButtonText\":\"Header---ButtonText\",\"buttonLink\":\"Header---buttonLink\",\"controls\":\"Header---controls\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"ThirdWindow-Height\":\"300px\",\"header-Height\":\"35px\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"ThirdWindowHeight\":\"250px\",\"ThirdWindow\":\"Image---ThirdWindow\",\"ThirdWindowPortrait\":\"Image---ThirdWindowPortrait\",\"header\":\"Image---header\",\"listOfImages\":\"Image---listOfImages\",\"ImageStyle\":\"Image---ImageStyle\",\"imageSection\":\"Image---imageSection\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"MediaOption\":\"MediaOptions---MediaOption\",\"header\":\"MediaOptions---header\",\"closeBtn\":\"MediaOptions---closeBtn\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"Resources\":\"Sidebar---Resources\",\"ResourceDetail\":\"Sidebar---ResourceDetail\",\"optionlist\":\"Sidebar---optionlist\",\"css-heg063-MuiTabs-flexContainer\":\"Sidebar---css-heg063-MuiTabs-flexContainer\"};","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Dictionary\":\"ResourceOption---Dictionary\"};","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"button\":\"AddButton---button\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"inlineWidth\":\"280px\",\"annotationControls\":\"AnnotationControls---annotationControls\",\"annotationContent\":\"AnnotationControls---annotationContent\",\"subTitle\":\"AnnotationControls---subTitle\",\"title\":\"AnnotationControls---title\",\"sectionHeading\":\"AnnotationControls---sectionHeading\",\"text\":\"AnnotationControls---text\",\"padding\":\"AnnotationControls---padding\",\"arrowTop\":\"AnnotationControls---arrowTop\",\"arrowLeft\":\"AnnotationControls---arrowLeft\",\"arrowRight\":\"AnnotationControls---arrowRight\",\"inline\":\"AnnotationControls---inline\",\"arrow\":\"AnnotationControls---arrow\",\"arrowDs\":\"AnnotationControls---arrowDs\",\"nothingSelected\":\"AnnotationControls---nothingSelected\",\"anonymousMessage\":\"AnnotationControls---anonymousMessage\",\"noNotes\":\"AnnotationControls---noNotes\",\"breakButtons\":\"AnnotationControls---breakButtons\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"header\":\"AnnotationControlsHeader---header\",\"Anotation_closeBtn\":\"AnnotationControlsHeader---Anotation_closeBtn\",\"edit\":\"AnnotationControlsHeader---edit\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"heading\":\"AnnotationControlsHeading---heading\",\"title\":\"AnnotationControlsHeading---title\",\"button\":\"AnnotationControlsHeading---button\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"annotationDetail\":\"AnnotationDetail---annotationDetail\",\"active\":\"AnnotationDetail---active\",\"annotationHeader\":\"AnnotationDetail---annotationHeader\",\"activeIcon\":\"AnnotationDetail---activeIcon\",\"editing\":\"AnnotationDetail---editing\",\"actionButtons\":\"AnnotationDetail---actionButtons\",\"edit\":\"AnnotationDetail---edit\",\"editImage\":\"AnnotationDetail---editImage\",\"save\":\"AnnotationDetail---save\",\"cancel\":\"AnnotationDetail---cancel\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"name\":\"AnswerView---name\",\"answer\":\"AnswerView---answer\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"save\":\"Button---save\",\"cancel\":\"Button---cancel\",\"buttonContainer\":\"Button---buttonContainer\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"highlight\":\"SearchStyle---highlight\",\"searchListItem\":\"SearchStyle---searchListItem\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"note\":\"Note---note\",\"header\":\"Note---header\",\"info\":\"Note---info\",\"content\":\"Note---content\",\"delete\":\"Note---delete\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"editorContainer\":\"NoteEditor---editorContainer\",\"textEditor\":\"NoteEditor---textEditor\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"editorContainer\":\"QuestionEditor---editorContainer\",\"textEditor\":\"QuestionEditor---textEditor\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"question\":\"QuestionView---question\",\"threadLink\":\"QuestionView---threadLink\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"loading\":\"QuestionsLoading---loading\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"selectVersion\":\"SelectVersion---selectVersion\",\"selectEmpty\":\"SelectVersion---selectEmpty\",\"selectOptions\":\"SelectVersion---selectOptions\",\"styled-select\":\"SelectVersion---styled-select\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"inlineWidth\":\"280px\",\"annotationControls\":\"SplitText---annotationControls\",\"annotationContent\":\"SplitText---annotationContent\",\"subTitle\":\"SplitText---subTitle\",\"title\":\"SplitText---title\",\"sectionHeading\":\"SplitText---sectionHeading\",\"text\":\"SplitText---text\",\"padding\":\"SplitText---padding\",\"arrowTop\":\"SplitText---arrowTop\",\"arrowLeft\":\"SplitText---arrowLeft\",\"arrowRight\":\"SplitText---arrowRight\",\"inline\":\"SplitText---inline\",\"arrow\":\"SplitText---arrow\",\"arrowDs\":\"SplitText---arrowDs\",\"nothingSelected\":\"SplitText---nothingSelected\",\"anonymousMessage\":\"SplitText---anonymousMessage\",\"noNotes\":\"SplitText---noNotes\",\"breakButtons\":\"SplitText---breakButtons\",\"splitText\":\"SplitText---splitText\",\"splitTextRowContent\":\"SplitText---splitTextRowContent\",\"splitTextRow\":\"SplitText---splitTextRow\",\"pechaImage\":\"SplitText---pechaImage\",\"image\":\"SplitText---image\",\"controlsPlaceholder\":\"SplitText---controlsPlaceholder\",\"hide\":\"SplitText---hide\",\"pageNumber\":\"SplitText---pageNumber\",\"image-loading\":\"SplitText---image-loading\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"TableContent\":\"TableOfContent---TableContent\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"paddingSide\":\"20px\",\"maxWidth\":\"600px\",\"text\":\"Text---text\",\"syncIdClass\":\"Text---syncIdClass\",\"textFirstRow\":\"Text---textFirstRow\",\"textLine\":\"Text---textLine\",\"textline\":\"Text---textline\",\"limitWidth\":\"Text---limitWidth\",\"textContainer\":\"Text---textContainer\",\"annotation\":\"Text---annotation\",\"selectedAnnotation\":\"Text---selectedAnnotation\",\"removedByAnnotation\":\"Text---removedByAnnotation\",\"insertion\":\"Text---insertion\",\"highlight\":\"Text---highlight\",\"activeHighlight\":\"Text---activeHighlight\",\"lineBreak\":\"Text---lineBreak\",\"pageBreak\":\"Text---pageBreak\",\"selectedRangelight\":\"Text---selectedRangelight\",\"selectedRangeDark\":\"Text---selectedRangeDark\",\"selectedImage\":\"Text---selectedImage\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"textDetail\":\"TextDetail---textDetail\",\"textContainer\":\"TextDetail---textContainer\",\"tableContent\":\"TextDetail---tableContent\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"button_group_menu\":\"TextDetailHeading---button_group_menu\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"textlist\":\"TextList---textlist\",\"open\":\"TextList---open\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"highlight\":\"SearchStyle---highlight\",\"searchListItem\":\"SearchStyle---searchListItem\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"selectVersion\":\"SelectVersion---selectVersion\",\"selectEmpty\":\"SelectVersion---selectEmpty\",\"selectOptions\":\"SelectVersion---selectOptions\",\"styled-select\":\"SelectVersion---styled-select\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"textlist\":\"TextList---textlist\",\"open\":\"TextList---open\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"button_group_menu\":\"textDetailHeading---button_group_menu\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"LoadMore---container\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"textList\":\"TextList---textList\",\"textListRow\":\"TextList---textListRow\",\"selectedRow\":\"TextList---selectedRow\",\"textNameRow\":\"TextList---textNameRow\",\"textName\":\"TextList---textName\",\"highlight\":\"TextList---highlight\",\"searchResults\":\"TextList---searchResults\",\"searchResult\":\"TextList---searchResult\",\"selectedSearchResult\":\"TextList---selectedSearchResult\",\"searchTotal\":\"TextList---searchTotal\",\"textListLoader\":\"TextList---textListLoader\",\"searching\":\"TextList---searching\",\"loadMore\":\"TextList---loadMore\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"tab\":\"TextListTab---tab\",\"showTab\":\"TextListTab---showTab\",\"hideTab\":\"TextListTab---hideTab\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"textsSearchContainer\":\"TextsSearch---textsSearchContainer\",\"textsSearch\":\"TextsSearch---textsSearch\",\"minify\":\"TextsSearch---minify\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"accessory\":\"Accessory---accessory\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"button\":\"Button---button\",\"buttonNoBezel\":\"Button---buttonNoBezel\",\"active\":\"Button---active\",\"leftAlign\":\"Button---leftAlign\",\"title\":\"Button---title\",\"icon\":\"Button---icon\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"inputRanges\":\"Slider---inputRanges\",\"inputRange\":\"Slider---inputRange\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"placeholder\":\"Placeholder---placeholder\",\"example\":\"Placeholder---example\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\"};"],"names":[],"sourceRoot":""}