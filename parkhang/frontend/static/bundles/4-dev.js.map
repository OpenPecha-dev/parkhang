{"version":3,"file":"4-dev.js","sources":["webpack://parkhang/./app/components/TextDetail2/SplitText.css","webpack://parkhang/./app/components/TextDetail2/SplitText.js","webpack://parkhang/./app/components/TextDetail2/TableOfContent/TableOfContent.js","webpack://parkhang/./app/components/TextDetail2/Text2.css","webpack://parkhang/./app/components/TextDetail2/Text2.js","webpack://parkhang/./app/components/TextDetail2/TextDetail.css","webpack://parkhang/./app/components/TextDetail2/TextDetail.js","webpack://parkhang/./app/components/TextDetail2/TextDetailContainer.js","webpack://parkhang/./app/components/TextDetail2/TextDetailHeadingContainer.js","webpack://parkhang/./app/lib/SplitText.js","webpack://parkhang/./app/state_helpers/TextStore2.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"inlineWidth\":\"280px\",\"annotationControls\":\"SplitText---annotationControls\",\"annotationContent\":\"SplitText---annotationContent\",\"subTitle\":\"SplitText---subTitle\",\"title\":\"SplitText---title\",\"sectionHeading\":\"SplitText---sectionHeading\",\"text\":\"SplitText---text\",\"padding\":\"SplitText---padding\",\"arrowTop\":\"SplitText---arrowTop\",\"arrowLeft\":\"SplitText---arrowLeft\",\"arrowRight\":\"SplitText---arrowRight\",\"inline\":\"SplitText---inline\",\"arrow\":\"SplitText---arrow\",\"arrowDs\":\"SplitText---arrowDs\",\"nothingSelected\":\"SplitText---nothingSelected\",\"anonymousMessage\":\"SplitText---anonymousMessage\",\"noNotes\":\"SplitText---noNotes\",\"breakButtons\":\"SplitText---breakButtons\",\"splitText2\":\"SplitText---splitText2\",\"splitTextRowContent\":\"SplitText---splitTextRowContent\",\"splitTextRow\":\"SplitText---splitTextRow\",\"pechaImage\":\"SplitText---pechaImage\",\"controlsPlaceholder\":\"SplitText---controlsPlaceholder\",\"pageNumber\":\"SplitText---pageNumber\",\"hightlighter\":\"SplitText---hightlighter\",\"pulse\":\"SplitText---pulse\"};","// @flow\r\nimport * as React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { AutoSizer } from \"react-virtualized/dist/es/AutoSizer\";\r\nimport { List } from \"react-virtualized\";\r\nimport {\r\n    CellMeasurer,\r\n    CellMeasurerCache,\r\n} from \"react-virtualized/dist/es/CellMeasurer\";\r\nimport \"react-virtualized/styles.css\";\r\nimport Text2 from \"./Text2\";\r\nimport SplitText from \"lib/SplitText\";\r\nimport styles from \"./SplitText.css\";\r\nimport _, { split } from \"lodash\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport Witness from \"lib/Witness\";\r\nimport GraphemeSplitter from \"grapheme-splitter\";\r\n\r\nlet _searchResultsCache: {\r\n    [splitTextUniqueId: string]: {\r\n        [searchTerm: string]: {\r\n            [index: number]: { [position: number]: [number, number] },\r\n        },\r\n    },\r\n} = {};\r\n\r\nexport type Props = {\r\n    splitText: SplitText,\r\n    didSelectSegmentIds: (segmentIds: string[]) => void,\r\n    limitWidth: boolean,\r\n    // selectedAnnotatedSegments: Array<TextSegment | number>,\r\n    selectedSegmentId: (segmentId: string) => void,\r\n    selectedWitness: Witness | null,\r\n    // selectedSearchResult: {\r\n    //     textId: number,\r\n    //     start: number,\r\n    //     length: number\r\n    // } | null,\r\n    // searchValue: string | null,\r\n    fontSize: number,\r\n    isPanelLinked: Boolean,\r\n    textAlignment: {},\r\n    textAlignmentById: {},\r\n    changeSyncIdOnScroll2: () => void,\r\n    selectedWindow: Boolean,\r\n    selectedTargetRange: [],\r\n    selectedSourceRange: [],\r\n    syncIdOnSearch: String,\r\n};\r\n\r\nexport default class SplitTextComponent extends React.PureComponent<Props> {\r\n    list: List | null;\r\n    splitText: HTMLDivElement | null;\r\n    didSelectSegmentIds;\r\n    cache: CellMeasurerCache;\r\n    rowRenderer: (params: {\r\n        key: string,\r\n        index: number,\r\n        parent: {},\r\n        style: {},\r\n    }) => React.Element<CellMeasurer>;\r\n    resizeHandler: () => void;\r\n    selectionHandler: (e: Event) => void;\r\n    textListVisible: boolean;\r\n    editMenuVisible: Boolean;\r\n    activeSelection: Selection | null;\r\n    selectedNodes: Node[] | null;\r\n    // Whether the mouse button is down\r\n    textAlignmentById;\r\n    changeSyncIdOnScroll2: () => void;\r\n\r\n    selectedTextIndex: number | null;\r\n    splitTextRect: ClientRect | null;\r\n    firstSelectedSegment: TextSegment | null;\r\n    selectedElementId: string | null;\r\n    selectedElementIds: string[] | null;\r\n    selectedWindow: Boolean;\r\n    scrollEvent: () => void;\r\n    mouseEnter: () => void;\r\n    mouseLeft: () => void;\r\n    scrollTop;\r\n    constructor(props: Props) {\r\n        super(props);\r\n        this.textAlignmentById = [];\r\n        this.changeSyncIdOnScroll2 = props.changeSyncIdOnScroll2;\r\n\r\n        this.list = null;\r\n        this.splitText = null;\r\n        this.cache = new CellMeasurerCache({\r\n            fixedWidth: true,\r\n            defaultHeight: 300,\r\n        });\r\n        this.rowRenderer = this.rowRenderer.bind(this);\r\n        this.isPanelLinked = this.props.isPanelLinked;\r\n        this.activeSelection = null;\r\n        this.selectedNodes = null;\r\n        this._mouseDown = false;\r\n        this._activeWitness = null;\r\n        this._didSetInitialScrollPosition = false;\r\n        this._modifyingSelection = false;\r\n        this.imageHeight = null;\r\n        this.imageWidth = null;\r\n        this.calculatedImageHeight = null;\r\n        this.selectedWindow = this.props.selectedWindow;\r\n        this.scrollEvent = this.scrollEvent.bind(this);\r\n        // this.processProps(props);\r\n        this.scrollTop = 0;\r\n    }\r\n    scrollEvent(e) {\r\n        if (this.selectedWindow === 1) return null;\r\n        if (this.selectedWindow === 2 && this.isPanelLinked) {\r\n            let list = [];\r\n            this.textAlignmentById.map((l) => {\r\n                let number = document.getElementById(\"s2_\" + l.start);\r\n                if (number) {\r\n                    let position = number.getBoundingClientRect();\r\n                    if (position.top > 102) {\r\n                        list.push({\r\n                            id: l.id,\r\n                            start: l.start,\r\n                            target: l.TStart,\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n            if (list.length > 0) {\r\n                this.changeSyncIdOnScroll2(list[0].target);\r\n            }\r\n        }\r\n    }\r\n\r\n    selectedListRow(props: Props): number | null {\r\n        let row = null;\r\n        if (props.activeAnnotation) {\r\n            row = props.splitText.getTextIndexOfPosition(\r\n                props.activeAnnotation.start\r\n            );\r\n        }\r\n        return row;\r\n    }\r\n    handleSelection(e: Event) {\r\n        if (!this._modifyingSelection) {\r\n            this.activeSelection = document.getSelection();\r\n\r\n            let selectedId =\r\n                this.activeSelection?.anchorNode?.parentElement?.id;\r\n\r\n            this.updateId(selectedId);\r\n\r\n            if (!this._mouseDown) {\r\n                // sometimes, this gets called after the mouseDown event handler\r\n                this.mouseUp();\r\n            }\r\n        } else {\r\n            e.stopPropagation();\r\n            // Need to set this here. If set at callsite, the event will not\r\n            // have time to propagate.\r\n            this._modifyingSelection = false;\r\n        }\r\n    }\r\n    mouseDown() {\r\n        this._mouseDown = true;\r\n    }\r\n\r\n    mouseUp() {\r\n        this._mouseDown = false;\r\n        if (this.activeSelection) {\r\n            // let segmentIds = this.processSelection(this.activeSelection);\r\n            // if (!segmentIds) {\r\n            //     segmentIds = [];\r\n            // }\r\n            // this.props.didSelectSegmentIds(segmentIds);\r\n            this.activeSelection = null;\r\n        }\r\n    }\r\n\r\n    // processSelection(selection: Selection): string[] | null {\r\n    //     if (\r\n    //         selection.rangeCount === 0 ||\r\n    //         selection.isCollapsed ||\r\n    //         selection.type === \"Caret\"\r\n    //     ) {\r\n    //         this.selectedNodes = null;\r\n    //         return null;\r\n    //     }\r\n\r\n    //     const range = selection.getRangeAt(0);\r\n    //     const start = range.startContainer;\r\n    //     const startSpan = this.getNodeSegmentSpan(start);\r\n    //     if (!(startSpan && startSpan.parentNode)) {\r\n    //         If the selection is not a text segment, ignore.\r\n    //         Assuming if the first node is a non-segment, they\r\n    //         all are.\r\n    //         return null;\r\n    //     }\r\n\r\n    //     let nodes = this.getRangeNodes(range, startSpan.parentNode);\r\n    //     Check if the selection starts after the end of a node, and\r\n    //     if so remove that node.\r\n    //     if (nodes.length > 0) {\r\n    //         let firstNode = nodes[0];\r\n    //         if (range.startOffset === firstNode.textContent.length) {\r\n    //             nodes.shift();\r\n    //         }\r\n    //     }\r\n\r\n    //     const end = range.endContainer;\r\n    //     const endSpan = this.getNodeSegmentSpan(end);\r\n    //     if (!(endSpan && endSpan.parentNode)) {\r\n    //         return null;\r\n    //     }\r\n    //     if (endSpan && startSpan.parentNode !== endSpan.parentNode) {\r\n    //         Selection is spanning Texts.\r\n    //         We assume a selection can only run across a maximum\r\n    //         of two Texts.\r\n    //         nodes = nodes.concat(this.getRangeNodes(range, endSpan.parentNode));\r\n    //     } else {\r\n    //         Check if the selection ends before the start of a node, and\r\n    //         if so remove that node.\r\n    //         if (range.endOffset === 0) {\r\n    //             nodes.pop();\r\n    //         }\r\n    //     }\r\n    //     this.selectedNodes = nodes;\r\n    //     let nodeIds = [];\r\n    //     nodes.reduce((accumulator: string[], current: Node) => {\r\n    //         if (current instanceof Element) {\r\n    //             accumulator.push(current.id);\r\n    //         }\r\n    //         return accumulator;\r\n    //     }, nodeIds);\r\n\r\n    //     return nodeIds;\r\n    // }\r\n    // getRangeNodes(range: Range, parentNode: Node): Node[] {\r\n    //     let rangeSpans = [];\r\n    //     for (let i = 0, len = parentNode.childNodes.length; i < len; i++) {\r\n    //         const node = parentNode.childNodes[i];\r\n    //         // TODO: add polyfill for i.e.?\r\n    //         // e.g. https://gist.github.com/jonathansampson/6d09bd6d2e8c22c53868aec42e66b0f9\r\n    //         if (range.intersectsNode(node)) {\r\n    //             rangeSpans.push(node);\r\n    //         }\r\n    //     }\r\n    //     return rangeSpans;\r\n    // }\r\n    getNodeSegmentSpan(node: Node): Element | null {\r\n        let currentNode = node;\r\n        let span = null;\r\n        const test = /^(i|s|ds)_/;\r\n        while (!span && currentNode.parentNode) {\r\n            if (currentNode instanceof Element && test.test(currentNode.id)) {\r\n                span = currentNode;\r\n            }\r\n            currentNode = currentNode.parentNode;\r\n        }\r\n\r\n        return span;\r\n    }\r\n\r\n    updateId(id) {\r\n        // if (id && id.includes(\"s2\")) {\r\n        //     let newId = id.replace(\"s2\", \"s\");\r\n        //     document\r\n        //         ?.getElementById(newId)\r\n        //         ?.scrollIntoView({ block: \"center\" });\r\n        //     let positionHighlight = document\r\n        //         .getElementById(newId)\r\n        //         .getBoundingClientRect();\r\n        //     let hightlighter = document.createElement(\"div\");\r\n        //     hightlighter.classList.add(styles.hightlighter);\r\n        //     hightlighter.style.border = \"2px solid blue\";\r\n        //     document.getElementById(newId).append(hightlighter);\r\n        //     document.getElementById(newId).style.color = \"blue\";\r\n        //     setTimeout(() => {\r\n        //         document.getElementById(newId).style.color = \"black\";\r\n        //         hightlighter.remove();\r\n        //     }, 500);\r\n        // }\r\n    }\r\n\r\n    updateList(\r\n        resetCache: boolean = true,\r\n        resetRows: number | number[] | null = null\r\n    ) {\r\n        if (\r\n            this.props.showImages &&\r\n            !this.calculatedImageHeight &&\r\n            this.imageHeight &&\r\n            this.imageWidth\r\n        ) {\r\n            this.calculatedImageHeight = this.calculateImageHeight();\r\n        }\r\n        if (this.list) {\r\n            const list = this.list;\r\n            if (resetCache) {\r\n                if (resetRows !== null) {\r\n                    if (!Array.isArray(resetRows)) {\r\n                        this.cache.clear(resetRows);\r\n                    } else if (Array.isArray(resetRows)) {\r\n                        for (let i = 0; i < resetRows.length; i++) {\r\n                            let resetRow = resetRows[i];\r\n                            this.cache.clear(resetRow);\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.cache.clearAll();\r\n                    list.measureAllRows();\r\n                    list.recomputeRowHeights(0);\r\n                }\r\n            }\r\n            list.forceUpdateGrid();\r\n        }\r\n    }\r\n\r\n    processProps(props: Props) {\r\n        let changedWitness = false;\r\n        if (\r\n            !this.props.selectedWitness ||\r\n            (props.selectedWitness &&\r\n                props.selectedWitness.id !== this.props.selectedWitness.id)\r\n        ) {\r\n            changedWitness = true;\r\n            this._didSetInitialScrollPosition = false;\r\n        }\r\n\r\n        if (\r\n            props.selectedSearchResult &&\r\n            (!this.props.selectedSearchResult ||\r\n                props.selectedSearchResult.start !==\r\n                    this.props.selectedSearchResult.start ||\r\n                props.selectedSearchResult.textId !==\r\n                    this.props.selectedSearchResult.textId)\r\n        ) {\r\n            console.log(\"resetting scroll position from search result\");\r\n            this._didSetInitialScrollPosition = false;\r\n        }\r\n\r\n        // TODO: check if new selectedSearchResult and if so\r\n        // set this._didSetInitialScrollPosition = false\r\n\r\n        // make sure there's no numbers in selectedAnnotatedSegments\r\n        // as we want to pass it to Text which only expects TextSegments\r\n        // this._filteredSelectedAnnotatedSegments = props.selectedAnnotatedSegments.reduce(\r\n        //     (acc, current: TextSegment | number) => {\r\n        //         if (current instanceof TextSegment) acc.push(current);\r\n        //         return acc;\r\n        //     },\r\n        //     []\r\n        // );\r\n\r\n        const controlsMeasurements = this.getControlsMeasurements(props);\r\n        if (controlsMeasurements) {\r\n            this.selectedTextIndex = controlsMeasurements.selectedTextIndex;\r\n            this.firstSelectedSegment =\r\n                controlsMeasurements.firstSelectedSegment;\r\n            this.splitTextRect = controlsMeasurements.splitTextRect;\r\n            this.selectedElementId = controlsMeasurements.selectedElementId;\r\n            this.selectedElementIds = controlsMeasurements.selectedElementIds;\r\n        }\r\n\r\n        if (\r\n            props.textListVisible !== this.textListVisible ||\r\n            props.editMenuVisible !== this.editMenuVisible\r\n        ) {\r\n            setTimeout(() => {\r\n                this.textListVisible = props.textListVisible;\r\n                this.editMenuVisible = props.editMenuVisible;\r\n                this.updateList(true);\r\n            }, 500);\r\n        } else {\r\n            if (changedWitness) {\r\n                this.updateList(true);\r\n            } else if (this.pageBreaksChanged(this.props, props)) {\r\n                let selectedRows = null;\r\n                let currentSelectedRow = this.selectedListRow(this.props);\r\n                let newSelectedRow = this.selectedListRow(props);\r\n                if (currentSelectedRow && newSelectedRow) {\r\n                    let firstChangedRow =\r\n                        currentSelectedRow > newSelectedRow\r\n                            ? newSelectedRow\r\n                            : currentSelectedRow;\r\n\r\n                    let splitRowTexts = this.props.splitText.texts;\r\n                    selectedRows = [];\r\n                    for (\r\n                        let i = firstChangedRow, len = splitRowTexts.length;\r\n                        i < len;\r\n                        i++\r\n                    ) {\r\n                        selectedRows.push(i);\r\n                    }\r\n                }\r\n                this.updateList(true, selectedRows);\r\n            } else if (this.lineBreaksChanges(this.props, props)) {\r\n                let selectedRow = this.selectedListRow(props);\r\n                if (!selectedRow)\r\n                    selectedRow = this.selectedListRow(this.props);\r\n                let splitRowTexts = this.props.splitText.texts;\r\n                let selectedRows = [];\r\n                if (selectedRow !== null) {\r\n                    for (\r\n                        let i = selectedRow, len = splitRowTexts.length;\r\n                        i < len;\r\n                        i++\r\n                    ) {\r\n                        selectedRows.push(i);\r\n                    }\r\n                    this.updateList(true, selectedRows);\r\n                }\r\n            } else if (this.props.fontSize !== props.fontSize) {\r\n                this.updateList(true);\r\n            } else if (\r\n                this.props.activeAnnotation &&\r\n                props.activeAnnotation &&\r\n                this.annotationsInSameLocation(\r\n                    this.props.activeAnnotation,\r\n                    props.activeAnnotation\r\n                )\r\n            ) {\r\n                this.updateList(true, this.selectedListRow(props));\r\n            } else {\r\n                this.updateList(this.shouldResetListCache(this.props, props));\r\n            }\r\n        }\r\n    }\r\n\r\n    pageBreaksChanged(oldProps: Props, newProps: Props) {\r\n        const oldTextBreaks = oldProps.splitText.getTextsFinalPositions();\r\n        const newTextBreaks = newProps.splitText.getTextsFinalPositions();\r\n\r\n        if (oldTextBreaks.length !== newTextBreaks.length) return true;\r\n\r\n        return JSON.stringify(oldTextBreaks) !== JSON.stringify(newTextBreaks);\r\n    }\r\n\r\n    lineBreaksChanges(oldProps: Props, newProps: Props) {\r\n        let oldActiveAnnotation = oldProps.activeAnnotation;\r\n        let newActiveAnnotation = newProps.activeAnnotation;\r\n        let hasChanged = false;\r\n\r\n        if (\r\n            oldActiveAnnotation &&\r\n            oldActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) &&\r\n            newProps.activeAnnotations &&\r\n            !newProps.activeAnnotations.hasOwnProperty(\r\n                oldActiveAnnotation.uniqueId\r\n            )\r\n        ) {\r\n            hasChanged = true;\r\n        }\r\n\r\n        if (\r\n            newActiveAnnotation &&\r\n            newActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) &&\r\n            oldProps.activeAnnotations &&\r\n            !oldProps.activeAnnotations.hasOwnProperty(\r\n                newActiveAnnotation.uniqueId\r\n            )\r\n        ) {\r\n            hasChanged = true;\r\n        }\r\n\r\n        return hasChanged;\r\n    }\r\n    shouldResetListCache(oldProps: Props, newProps: Props) {\r\n        let shouldReset = false;\r\n        if (\r\n            oldProps.showImages !== newProps.showImages ||\r\n            this.pageBreaksChanged(oldProps, newProps)\r\n        ) {\r\n            shouldReset = true;\r\n        }\r\n\r\n        return shouldReset;\r\n    }\r\n\r\n    UNSAFE_componentWillReceiveProps(props: Props) {\r\n        this.processProps(props);\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.resizeHandler = _.throttle(() => {\r\n            this.calculatedImageHeight = null;\r\n            this.updateList();\r\n        }, 500).bind(this);\r\n        window.addEventListener(\"resize\", this.resizeHandler);\r\n\r\n        this.selectionHandler = _.debounce((e) => {\r\n            this.handleSelection(e);\r\n        }, 200).bind(this);\r\n\r\n        document.addEventListener(\"selectionchange\", this.selectionHandler);\r\n\r\n        document.addEventListener(\"mousedown\", this.mouseDown.bind(this), true);\r\n        document.addEventListener(\"mouseup\", this.mouseUp.bind(this), true);\r\n\r\n        this.processProps(this.props);\r\n        this.componentDidUpdate();\r\n    }\r\n\r\n    componentDidUpdate(prevProps, prevState) {\r\n        this.selectedWindow = this.props.selectedWindow;\r\n        let SearchSyncId = this.props.syncIdOnSearch || null;\r\n        let list = this.list;\r\n        let result = this.props.searchResults;\r\n        let Alignment = this.props.textAlignment;\r\n        let condition = Alignment.target === this.props.selectedWitness.id;\r\n        let con =\r\n            prevProps?.searchResults !== this.props?.searchResults ||\r\n            prevProps?.syncIdOnSearch !== this.props?.syncIdOnSearch;\r\n        if (con && result) {\r\n            if (SearchSyncId) {\r\n                let selectedTextIndex =\r\n                    this.props.splitText.getTextIndexOfPosition(SearchSyncId);\r\n                setTimeout(() => {\r\n                    list.scrollToRow(selectedTextIndex);\r\n                    setTimeout(() => {\r\n                        list.scrollToPosition(list.props.scrollTop - 300);\r\n                    }, 0);\r\n                }, 100);\r\n            }\r\n        }\r\n        if (this.selectedWindow === 1 && this.isPanelLinked && condition) {\r\n            let targetId = this.props.syncIdOnScroll;\r\n            let targetId2 = this.props.syncIdOnClick;\r\n\r\n            this.isPanelLinked = this.props.isPanelLinked;\r\n            let list = this.list;\r\n            this.textAlignmentById = this.props.textAlignmentById;\r\n            this.splitText.style.scrollBehavior = \"smooth\";\r\n            if (Alignment && this.isPanelLinked) {\r\n                if (targetId !== null) {\r\n                    let selectedTextIndex =\r\n                        this.props.splitText.getTextIndexOfPosition(targetId);\r\n\r\n                    setTimeout(() => {\r\n                        list.scrollToRow(selectedTextIndex);\r\n\r\n                        setTimeout(() => {\r\n                            list.scrollToPosition(list.props.scrollTop - 300);\r\n                            this.resizeHandler();\r\n                        }, 0);\r\n                    }, 100);\r\n                } else {\r\n                    let clickIdObj = Alignment.alignment.find(\r\n                        (l) =>\r\n                            targetId2 >= l.source_segment.start &&\r\n                            targetId2 < l.source_segment.end\r\n                    );\r\n                    let syncClickTargetId = clickIdObj?.target_segment?.start;\r\n\r\n                    let selectedTextIndex =\r\n                        this.props.splitText.getTextIndexOfPosition(\r\n                            syncClickTargetId\r\n                        );\r\n\r\n                    setTimeout(() => {\r\n                        list.scrollToRow(selectedTextIndex);\r\n\r\n                        setTimeout(() => {\r\n                            list.scrollToPosition(list.props.scrollTop - 300);\r\n                            this.resizeHandler();\r\n                        }, 0);\r\n                    }, 100);\r\n                }\r\n            }\r\n        }\r\n\r\n        // if (this.selectedNodes && this.selectedNodes.length > 0) {\r\n        //     const selectedNodes = this.selectedNodes;\r\n        //     const selectedSegments = this.props.selectedAnnotatedSegments;\r\n        //     setTimeout(() => {\r\n        //         let selRange = document.createRange();\r\n        //         let startNode = selectedNodes[0];\r\n        //         let endNode = selectedNodes[selectedNodes.length - 1];\r\n        //         // let lastSegment = selectedSegments[selectedSegments.length - 1];\r\n        //         if (lastSegment instanceof TextSegment) {\r\n        //             let lastElement = document.getElementById(\r\n        //                 idForSegment(lastSegment)\r\n        //             );\r\n        //             if (lastElement) endNode = lastElement;\r\n        //         }\r\n        //         if (\r\n        //             startNode instanceof Element &&\r\n        //             endNode instanceof Element\r\n        //         ) {\r\n        //             startNode = document.getElementById(startNode.id);\r\n        //             endNode = document.getElementById(endNode.id);\r\n        //             if (startNode && endNode) {\r\n        //                 selRange.setStart(startNode, 0);\r\n        //                 selRange.setEnd(endNode, endNode.childNodes.length);\r\n        //                 let sel = document.getSelection();\r\n        //                 if (sel) {\r\n        //                     this._modifyingSelection = true;\r\n        //                     sel.removeAllRanges();\r\n        //                     sel.addRange(selRange);\r\n        //                     this.selectedNodes = null;\r\n        //                 }\r\n        //             }\r\n        //         }\r\n        //     }, 0);\r\n        // }\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        document.removeEventListener(\"mousedown\", this);\r\n        document.removeEventListener(\"mouseup\", this);\r\n        window.removeEventListener(\"resize\", this.resizeHandler);\r\n        document.removeEventListener(\"selectionchange\", this.selectionHandler);\r\n    }\r\n\r\n    getSelectedTextIndex(): number {\r\n        let selectedTextIndex = 0;\r\n        let startPos = null;\r\n        if (this.props.activeAnnotation) {\r\n            [startPos] =\r\n                this.props.splitText.annotatedText.getPositionOfAnnotation(\r\n                    this.props.activeAnnotation\r\n                );\r\n        } else if (this.props.selectedSearchResult) {\r\n            let segment =\r\n                this.props.splitText.annotatedText.segmentAtOriginalPosition(\r\n                    this.props.selectedSearchResult.start\r\n                );\r\n            if (segment instanceof TextSegment) {\r\n                startPos = segment.start;\r\n            } else if (typeof segment === \"number\") {\r\n                startPos = segment;\r\n            }\r\n        }\r\n        if (startPos) {\r\n            selectedTextIndex =\r\n                this.props.splitText.getTextIndexOfPosition(startPos);\r\n        }\r\n        return selectedTextIndex;\r\n    }\r\n    getControlsMeasurements(props: Props): {\r\n        selectedTextIndex: number,\r\n        firstSelectedSegment: TextSegment,\r\n        selectedElementId: string,\r\n        splitTextRect: ClientRect,\r\n        selectedElementIds: string[],\r\n    } | null {\r\n        if (!this.splitText) {\r\n            return null;\r\n        }\r\n        let splitTextComponent = this.splitText;\r\n        let selectedTextIndex = null;\r\n        let firstSelectedSegment = null;\r\n        let selectedElementId = null;\r\n        let splitTextRect = null;\r\n        let segmentIdFunction: null | ((segment: TextSegment) => string) = null;\r\n        let selectedElementIds = [];\r\n        let startPos = 0;\r\n        if (props.activeAnnotation) {\r\n            let activeAnnotation = props.activeAnnotation;\r\n            [startPos] =\r\n                props.splitText.annotatedText.getPositionOfAnnotation(\r\n                    activeAnnotation\r\n                );\r\n            if (startPos === null) {\r\n                console.warn(\"No startPos in getControlsMeasurements\");\r\n                return null;\r\n            }\r\n            if (activeAnnotation.type === ANNOTATION_TYPES.pageBreak) {\r\n                startPos -= 1;\r\n            }\r\n            if (activeAnnotation.type === ANNOTATION_TYPES.lineBreak) {\r\n                startPos -= 1;\r\n            }\r\n\r\n            // Index of text containing end of annotation\r\n            let positionEnd = startPos + activeAnnotation.length;\r\n            if (activeAnnotation.length > 0) positionEnd -= 1;\r\n            selectedTextIndex =\r\n                props.splitText.getTextIndexOfPosition(positionEnd);\r\n            splitTextRect = splitTextComponent.getBoundingClientRect();\r\n        }\r\n        let selectedAnnotatedSegments = [];\r\n        if (\r\n            props.selectedAnnotatedSegments &&\r\n            props.selectedAnnotatedSegments.length > 0\r\n        ) {\r\n            selectedAnnotatedSegments = props.selectedAnnotatedSegments;\r\n            for (let i = 0; i < selectedAnnotatedSegments.length; i++) {\r\n                let segment = selectedAnnotatedSegments[i];\r\n                if (\r\n                    firstSelectedSegment === null &&\r\n                    segment instanceof TextSegment\r\n                ) {\r\n                    firstSelectedSegment = segment;\r\n                    break;\r\n                }\r\n            }\r\n            if (firstSelectedSegment) {\r\n                if (\r\n                    firstSelectedSegment.length === 0 &&\r\n                    props.activeAnnotation &&\r\n                    props.activeAnnotation.isInsertion\r\n                ) {\r\n                    selectedElementId = idForInsertion(firstSelectedSegment);\r\n                    segmentIdFunction = idForInsertion;\r\n                } else {\r\n                    selectedElementId = idForSegment(firstSelectedSegment);\r\n                    segmentIdFunction = idForSegment;\r\n                }\r\n            }\r\n        } else if (props.activeAnnotation) {\r\n            if (props.activeAnnotation.isDeletion) {\r\n                let segment = new TextSegment(startPos, \"\");\r\n                selectedElementId = idForDeletedSegment(segment);\r\n                segmentIdFunction = idForDeletedSegment;\r\n                firstSelectedSegment = segment;\r\n                selectedAnnotatedSegments = [firstSelectedSegment];\r\n            } else if (props.activeAnnotation.isInsertion) {\r\n                const [start] =\r\n                    props.splitText.annotatedText.getPositionOfAnnotation(\r\n                        props.activeAnnotation\r\n                    );\r\n                if (start) {\r\n                    let segment = new TextSegment(start, \"\");\r\n                    selectedElementId = idForInsertion(segment);\r\n                    segmentIdFunction = idForInsertion;\r\n                    firstSelectedSegment = segment;\r\n                    selectedAnnotatedSegments = [firstSelectedSegment];\r\n                }\r\n            } else if (\r\n                props.activeAnnotation.type === ANNOTATION_TYPES.pageBreak\r\n            ) {\r\n                let segment = new TextSegment(startPos + 1, \"\");\r\n                let prevSegment = new TextSegment(startPos, \"\");\r\n                selectedElementId = idForPageBreak(prevSegment);\r\n                firstSelectedSegment = segment;\r\n                selectedAnnotatedSegments = [segment];\r\n                selectedElementIds = [selectedElementId];\r\n            } else if (\r\n                props.activeAnnotation.type === ANNOTATION_TYPES.lineBreak\r\n            ) {\r\n                let segment = new TextSegment(startPos + 1, \"\");\r\n                let prevSegment = new TextSegment(startPos, \"\");\r\n                selectedElementId = idForLineBreak(prevSegment);\r\n                firstSelectedSegment = segment;\r\n                selectedAnnotatedSegments = [segment];\r\n                selectedElementIds = [selectedElementId];\r\n            }\r\n        }\r\n        if (segmentIdFunction) {\r\n            for (let i = 0; i < selectedAnnotatedSegments.length; i++) {\r\n                let segment = selectedAnnotatedSegments[i];\r\n                if (segment instanceof TextSegment) {\r\n                    const segmentId = segmentIdFunction(segment);\r\n                    selectedElementIds.push(segmentId);\r\n                }\r\n            }\r\n        }\r\n        if (\r\n            selectedTextIndex != null &&\r\n            firstSelectedSegment &&\r\n            selectedElementId &&\r\n            splitTextRect\r\n        ) {\r\n            return {\r\n                selectedTextIndex: selectedTextIndex,\r\n                firstSelectedSegment: firstSelectedSegment,\r\n                selectedElementId: selectedElementId,\r\n                splitTextRect: splitTextRect,\r\n                selectedElementIds: selectedElementIds,\r\n            };\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const props = this.props;\r\n        const rowRenderer = this.rowRenderer;\r\n        const cache = this.cache;\r\n        const key = props.selectedWitness ? props.selectedWitness.id : 0;\r\n\r\n        return (\r\n            <div\r\n                className={styles.splitText2}\r\n                ref={(div) => (this.splitText = div)}\r\n                key={key}\r\n            >\r\n                <button\r\n                    id=\"updateList2\"\r\n                    style={{ display: \"none\" }}\r\n                    onClick={() => this.updateList(true)}\r\n                ></button>\r\n                <AutoSizer>\r\n                    {({ height, width }) => (\r\n                        <List\r\n                            ref={(list) => (this.list = list)}\r\n                            height={height}\r\n                            rowCount={props.splitText.texts.length}\r\n                            rowHeight={cache.rowHeight}\r\n                            rowRenderer={rowRenderer}\r\n                            width={width}\r\n                            overscanRowCount={1}\r\n                            deferredMeasurementCache={cache}\r\n                            onScroll={this.scrollEvent}\r\n                            scrollToAlignment=\"start\"\r\n                        ></List>\r\n                    )}\r\n                </AutoSizer>\r\n            </div>\r\n        );\r\n    }\r\n    getStringPositions(\r\n        text: SegmentedText,\r\n        string: string,\r\n        index: number\r\n    ): { [position: number]: [number, number] } {\r\n        const uniqueId = this.props.splitText.annotatedText.getUniqueId();\r\n\r\n        if (!_searchResultsCache.hasOwnProperty(uniqueId)) {\r\n            _searchResultsCache = {\r\n                [uniqueId]: {},\r\n            };\r\n        }\r\n\r\n        if (!_searchResultsCache[uniqueId].hasOwnProperty(string)) {\r\n            _searchResultsCache[uniqueId] = {\r\n                [string]: {},\r\n            };\r\n        }\r\n\r\n        if (_searchResultsCache[uniqueId][string].hasOwnProperty(index)) {\r\n            return _searchResultsCache[uniqueId][string][index];\r\n        }\r\n\r\n        const splitter = new GraphemeSplitter();\r\n        const content = text.getText();\r\n        const firstSegment = text.segments[0];\r\n        const startingPosition = firstSegment.start;\r\n        let positions = [];\r\n        let position = content.indexOf(string);\r\n        while (position !== -1) {\r\n            positions.push(position);\r\n            position = content.indexOf(string, position + 1);\r\n        }\r\n\r\n        // Position needs to be position in complete text\r\n        let verifiedPositions: { [position: number]: [number, number] } = {};\r\n        if (positions.length > 0) {\r\n            const graphemes = splitter.splitGraphemes(content);\r\n            let position = 0;\r\n            let activePosition = null;\r\n            for (let i = 0; i < graphemes.length; i++) {\r\n                const grapheme = graphemes[i];\r\n                const graphemeEnd = position + (grapheme.length - 1);\r\n                if (activePosition !== null) {\r\n                    let expectedEnd = activePosition + (string.length - 1);\r\n                    if (graphemeEnd >= expectedEnd) {\r\n                        verifiedPositions[activePosition + startingPosition] = [\r\n                            activePosition + startingPosition,\r\n                            graphemeEnd + startingPosition,\r\n                        ];\r\n                        activePosition = null;\r\n                    }\r\n                } else if (positions.indexOf(position) !== -1) {\r\n                    if (string.length === grapheme.length) {\r\n                        verifiedPositions[position + startingPosition] = [\r\n                            position + startingPosition,\r\n                            graphemeEnd + startingPosition,\r\n                        ];\r\n                    } else if (string.length > grapheme.length) {\r\n                        activePosition = position;\r\n                    }\r\n                } else {\r\n                    activePosition = null;\r\n                }\r\n\r\n                position += grapheme.length;\r\n            }\r\n        }\r\n\r\n        _searchResultsCache[uniqueId][string][index] = verifiedPositions;\r\n\r\n        return verifiedPositions;\r\n    }\r\n\r\n    rowRenderer({\r\n        key,\r\n        index,\r\n        parent,\r\n        style,\r\n    }: {\r\n        key: string,\r\n        index: number,\r\n        parent: {},\r\n        style: {},\r\n    }): React.Element<CellMeasurer> {\r\n        const props = this.props;\r\n        const cache = this.cache;\r\n\r\n        let searchStringPositions = {};\r\n        let searchValue = this.props.searchValue;\r\n        if (searchValue && searchValue.length > 0 && props.splitText) {\r\n            searchStringPositions = this.getStringPositions(\r\n                props.splitText.texts[index],\r\n                searchValue,\r\n                index\r\n            );\r\n        }\r\n\r\n        let newStyle = { ...style, height: style.height + 10 };\r\n        return (\r\n            <CellMeasurer\r\n                columnIndex={0}\r\n                key={key}\r\n                parent={parent}\r\n                rowIndex={index}\r\n                cache={cache}\r\n            >\r\n                <div\r\n                    key={key}\r\n                    style={newStyle}\r\n                    ref={this.splitTextRef}\r\n                    id={`index2_${index}`}\r\n                    className={styles.splitTextRow}\r\n                >\r\n                    <div className={styles.splitTextRowContent}>\r\n                        <Text2\r\n                            segmentedText={props.splitText.texts[index]}\r\n                            row={index}\r\n                            selectedSegmentId={props.selectedSegmentId}\r\n                            // searchValue={searchValue}\r\n                            // selectedSearchResult={\r\n                            //     this.props.selectedSearchResult\r\n                            // }\r\n                            searchStringPositions={searchStringPositions}\r\n                            textAlignmentById={props.textAlignmentById}\r\n                            fontSize={props.fontSize}\r\n                            selectedSourceRange={props.selectedSourceRange}\r\n                            selectedTargetRange={props.selectedTargetRange}\r\n                            changeSelectedRange={props.changeSelectedRange}\r\n                        ></Text2>\r\n                    </div>\r\n                </div>\r\n            </CellMeasurer>\r\n        );\r\n    }\r\n}\r\n","import React from \"react\";\r\nimport { Box, Typography } from \"@mui/material\";\r\nfunction TableOfContent() {\r\n    return (\r\n        <>\r\n            <Typography textTransform={\"uppercase\"}>\r\n                Table Of Content\r\n            </Typography>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default TableOfContent;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"paddingSide\":\"20px\",\"maxWidth\":\"600px\",\"text\":\"Text2---text\",\"textFirstRow\":\"Text2---textFirstRow\",\"textLine\":\"Text2---textLine\",\"limitWidth\":\"Text2---limitWidth\",\"textContainer\":\"Text2---textContainer\",\"annotation\":\"Text2---annotation\",\"selectedAnnotation\":\"Text2---selectedAnnotation\",\"removedByAnnotation\":\"Text2---removedByAnnotation\",\"insertion\":\"Text2---insertion\",\"highlight\":\"Text2---highlight\",\"activeHighlight\":\"Text2---activeHighlight\",\"lineBreak\":\"Text2---lineBreak\",\"pageBreak\":\"Text2---pageBreak\",\"syncIdClass\":\"Text2---syncIdClass\",\"selectedRange\":\"Text2---selectedRange\"};","// @flow\r\nimport React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport styles from \"./Text2.css\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport {\r\n    INSERTION_KEY,\r\n    DELETION_KEY,\r\n    PAGE_BREAK_KEY,\r\n    LINE_BREAK_KEY,\r\n} from \"lib/AnnotatedText\";\r\nimport _ from \"lodash\";\r\nimport SegmentedText from \"lib/SegmentedText\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport Witness from \"lib/Witness\";\r\nimport { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport GraphemeSplitter from \"grapheme-splitter\";\r\n\r\nexport function idForSegment(segment: TextSegment): string {\r\n    return \"s2_\" + segment.start;\r\n}\r\n\r\nexport function idForDeletedSegment(segment: TextSegment): string {\r\n    return \"ds_\" + segment.start;\r\n}\r\n\r\n// export function idForInsertion(segment: TextSegment): string {\r\n//     return \"i_\" + segment.start;\r\n// }\r\n\r\n// export function idForPageBreak(segment: TextSegment): string {\r\n//     return \"p_\" + (segment.end + 1);\r\n// }\r\n\r\n// export function idForLineBreak(segment: TextSegment): string {\r\n//     return \"l_\" + (segment.end + 1);\r\n// }\r\n\r\nexport type Props = {\r\n    segmentedText: SegmentedText,\r\n    annotationPositions: { [string]: Annotation[] },\r\n    selectedSegmentId: (id: string) => void,\r\n    activeAnnotations: { [AnnotationUniqueId]: Annotation } | null,\r\n    getBaseAnnotation: (annotation: Annotation) => Annotation,\r\n    selectedAnnotatedSegments: TextSegment[],\r\n    row: number,\r\n    activeAnnotation: Annotation | null,\r\n    searchValue: string | null,\r\n    selectedSearchResult: {\r\n        textId: number,\r\n        start: number,\r\n        length: number,\r\n    } | null,\r\n    searchStringPositions: { [position: number]: [number, number] },\r\n    fontSize?: number,\r\n    activeWitness: Witness,\r\n    textAlignmentById: {},\r\n    selectedSourceRange: [],\r\n    selectedTargetRange: [],\r\n};\r\n\r\nexport type State = {\r\n    segmentedText: SegmentedText,\r\n};\r\n\r\n// import ReactDOMServer from \"react-dom/server\";\r\n// import PageBreakIcon from \"images/page_break_icon.svg\";\r\n// const PARA_SYMBOL = String.fromCharCode(182);\r\n// const pageBreakIconString = ReactDOMServer.renderToStaticMarkup(\r\n//     <PageBreakIcon />\r\n// );\r\n\r\nexport default class Text2 extends React.Component<Props, State> {\r\n    _renderedSegments: TextSegment[] | null;\r\n    _renderedHtml: { __html: string } | null;\r\n    textAlignmentById;\r\n\r\n    constructor(props: Props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            segmentedText: props.segmentedText,\r\n        };\r\n        this.textAlignmentById = [];\r\n\r\n        this._renderedSegments = null;\r\n        this._renderedHtml = null;\r\n    }\r\n\r\n    UNSAFE_componentWillReceiveProps(nextProps: Props) {\r\n        this.setState((prevState: State, props: Props) => {\r\n            return {\r\n                ...prevState,\r\n                segmentedText: nextProps.segmentedText,\r\n            };\r\n        });\r\n    }\r\n\r\n    // annotationsForSegment(segment: TextSegment): Annotation[] {\r\n    //     let annotations: Annotation[] = [];\r\n    //     const foundAnnotations = this.props.annotationPositions[\r\n    //         String(segment.start)\r\n    //     ];\r\n    //     if (foundAnnotations) {\r\n    //         annotations = foundAnnotations;\r\n    //     }\r\n    //     const insertions =\r\n    //         this.props.annotationPositions[INSERTION_KEY + segment.start] || [];\r\n    //     const deletions =\r\n    //         this.props.annotationPositions[DELETION_KEY + segment.start] || [];\r\n    //     const pageBreaks =\r\n    //         this.props.annotationPositions[\r\n    //             PAGE_BREAK_KEY + (segment.end + 1)\r\n    //         ] || [];\r\n    //     const lineBreaks =\r\n    //         this.props.annotationPositions[\r\n    //             LINE_BREAK_KEY + (segment.end + 1)\r\n    //         ] || [];\r\n\r\n    //     return annotations.concat(\r\n    //         insertions,\r\n    //         deletions,\r\n    //         pageBreaks,\r\n    //         lineBreaks\r\n    //     );\r\n    // }\r\n\r\n    // segmentsContainSegment(segments: TextSegment[], segment: TextSegment) {\r\n    //     for (let i = 0; i < segments.length; i++) {\r\n    //         let listSegment = segments[i];\r\n    //         if (\r\n    //             listSegment.start === segment.start &&\r\n    //             listSegment.text === segment.text\r\n    //         ) {\r\n    //             return true;\r\n    //         }\r\n    //     }\r\n    //     return false;\r\n    // }\r\n\r\n    selectedElement(element: Element) {\r\n        const selection = document.getSelection();\r\n        // console.log(selection)\r\n        if (selection && selection.type === \"Range\") {\r\n            return;\r\n        }\r\n        this.props.selectedSegmentId(element.id);\r\n    }\r\n\r\n    generateHtml(renderProps: Props, renderState: State): { __html: string } {\r\n        let segments = renderState.segmentedText.segments;\r\n        let textLineClass = styles.textLine;\r\n        let segmentHTML = '<p class=\"' + textLineClass + '\">';\r\n        if (segments.length === 0) return { __html: segmentHTML };\r\n\r\n        const endPosition = segments[segments.length - 1].end + 1;\r\n\r\n        let highlightClass = styles.highlight;\r\n        let activeHighlightClass = styles.activeHighlight;\r\n        let activeSearchResultEnd = null;\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let segment = segments[i];\r\n            let classAttribute = \"\";\r\n            let classes = [];\r\n            let selectedCurrentDeletion = false;\r\n            let selectedCurrentPageBreak = false;\r\n            let selectedCurrentLineBreak = false;\r\n            let lineBreakAnnotation = false;\r\n            let pageBreakAnnotation = null;\r\n\r\n            // It's an insertion at the end of the text, which should have just been added to the html.\r\n            // So break as we don't want anymore segment html adding.\r\n            if (segment.start === endPosition) {\r\n                break;\r\n            }\r\n            let id = null;\r\n            if (segment.length === 0) {\r\n                // id = idForDeletedSegment(segment);\r\n                // classes.push(styles.removedByAnnotation);\r\n                // if (deletionText) {\r\n                //     segment = new TextSegment(segment.start, deletionText);\r\n                // }\r\n            } else {\r\n                id = idForSegment(segment);\r\n            }\r\n\r\n            // if (\r\n            //     this.segmentsContainSegment(\r\n            //         renderProps.selectedAnnotatedSegments,\r\n            //         segment\r\n            //     ) ||\r\n            //     selectedCurrentDeletion\r\n            // ) {\r\n            //     classes.push(styles.selectedAnnotation);\r\n            // }\r\n            if (renderProps.selectedTargetRange?.includes(segment.start)) {\r\n                classes.push(styles.selectedRange);\r\n            }\r\n\r\n            if (classes.length > 0) {\r\n                let className = classnames(...classes);\r\n                classAttribute = 'class=\"' + className + '\"';\r\n            }\r\n\r\n            let segmentContent = segment.text;\r\n            // Add search result highlight if required.\r\n            if (renderProps.searchStringPositions) {\r\n                let segmentStart = segment.start;\r\n                let position = segmentStart;\r\n                segmentContent = \"\";\r\n\r\n                let highlight = highlightClass;\r\n                if (\r\n                    renderProps.selectedSearchResult &&\r\n                    renderProps.selectedSearchResult.start <= position &&\r\n                    renderProps.selectedSearchResult.start +\r\n                        renderProps.selectedSearchResult.length >\r\n                        position\r\n                ) {\r\n                    highlight = activeHighlightClass;\r\n                }\r\n\r\n                for (let j = 0; j < segment.text.length; j++) {\r\n                    let char = segment.text.charAt(j);\r\n                    position = segmentStart + j;\r\n                    if (activeSearchResultEnd) {\r\n                        let [start, end] = activeSearchResultEnd;\r\n                        if (j === 0) {\r\n                            segmentContent +=\r\n                                '<span class=\"' + highlight + '\">';\r\n                        }\r\n                        if (position === end) {\r\n                            segmentContent += char + \"</span>\";\r\n                            activeSearchResultEnd = null;\r\n                        } else if (j === segment.text.length - 1) {\r\n                            segmentContent += char + \"</span>\";\r\n                        } else {\r\n                            segmentContent += char;\r\n                        }\r\n                    } else if (position in renderProps.searchStringPositions) {\r\n                        let [start, end] =\r\n                            renderProps.searchStringPositions[position];\r\n                        segmentContent +=\r\n                            '<span class=\"' + highlight + '\">' + char;\r\n                        if (j === segment.text.length - 1 || position === end) {\r\n                            segmentContent += \"</span>\";\r\n                        }\r\n                        if (position < end) {\r\n                            activeSearchResultEnd = [start, end];\r\n                        }\r\n                    } else {\r\n                        segmentContent += char;\r\n                    }\r\n                }\r\n            }\r\n            if (\r\n                this.props.textAlignmentById !== null\r\n                // && selectedTextId === TargetId\r\n            ) {\r\n                let r = this.props.textAlignmentById.find(\r\n                    (d) => d.TStart === segment.start\r\n                );\r\n                if (r) {\r\n                    segmentHTML +=\r\n                        \"<span id='alignment2_\" +\r\n                        segment.start +\r\n                        \"'>\" +\r\n                        `<sup class=` +\r\n                        styles.syncIdClass +\r\n                        `>${r.id}</sup>` +\r\n                        \"</span>\";\r\n                }\r\n            }\r\n\r\n            segmentHTML +=\r\n                \"<span id=\" +\r\n                id +\r\n                \" key=\" +\r\n                id +\r\n                \" \" +\r\n                classAttribute +\r\n                \">\" +\r\n                segmentContent +\r\n                \"</span>\";\r\n        }\r\n\r\n        this._renderedSegments = segments;\r\n        segmentHTML += \"</p>\";\r\n\r\n        const html = {\r\n            __html: segmentHTML,\r\n        };\r\n        return html;\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps: Props, nextState: State) {\r\n        const renderedHtml = this.generateHtml(nextProps, nextState);\r\n        if (this.props.fontSize !== nextProps.fontSize) {\r\n            return true;\r\n        } else if (\r\n            this._renderedHtml &&\r\n            renderedHtml.__html === this._renderedHtml.__html\r\n        ) {\r\n            return false;\r\n        } else {\r\n            this._renderedHtml = renderedHtml;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    render() {\r\n        let classes = [styles.text];\r\n        if (this.props.row === 0) {\r\n            classes.push(styles.textFirstRow);\r\n        }\r\n\r\n        // Generate HTML manually as it is much faster when\r\n        // creating large numbers of elements, such as these spans.\r\n        const html = this._renderedHtml\r\n            ? this._renderedHtml\r\n            : this.generateHtml(this.props, this.state);\r\n        if (!this._renderedHtml) {\r\n            this._renderedHtml = html;\r\n        }\r\n\r\n        return (\r\n            <div className={styles.textContainer}>\r\n                <div\r\n                    className={classnames(...classes)}\r\n                    dangerouslySetInnerHTML={html}\r\n                    onClick={(e) => this.selectedElement(e.target)}\r\n                    style={{\r\n                        fontSize: this.props.fontSize,\r\n                    }}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"textDetail2\":\"TextDetail---textDetail2\",\"textContainer\":\"TextDetail---textContainer\"};","import React, { useEffect, useState, useRef } from \"react\";\r\nimport TextDetailHeading from \"./TextDetailHeadingContainer\";\r\nimport SplitTextComponent from \"./SplitText\";\r\nimport SplitText from \"lib/SplitText\";\r\nimport Loader from \"react-loader\";\r\nimport lengthSplitter from \"lib/text_splitters/lengthSplitter\";\r\nimport styles from \"./TextDetail.css\";\r\nimport { Box, Slide } from \"@mui/material\";\r\nimport TableOfContent from \"./TableOfContent/TableOfContent\";\r\nimport utilStyles from \"css/util.css\";\r\nimport classnames from \"classnames\";\r\n\r\nimport imageStyle from \"../Editors/MediaComponent/Image.css\";\r\nfunction TextDetail(props) {\r\n    const ref = useRef();\r\n    let text = {\r\n        name: \"\",\r\n    };\r\n    if (props.text) {\r\n        text = props.text;\r\n    }\r\n    useEffect(() => {\r\n        let element = ref.current;\r\n        element.addEventListener(\"mouseenter\", mouseEnter);\r\n        return () => {\r\n            element.removeEventListener(\"mouseenter\", mouseEnter);\r\n        };\r\n    }, []);\r\n\r\n    function mouseEnter() {\r\n        props.changeSelectedWindow(2);\r\n    }\r\n\r\n    let inlineControls = false;\r\n    let textComponent = null;\r\n    let splitText = null;\r\n    if (!props.annotatedText || !props.text || props.loading) {\r\n        textComponent = <div key={`key-${Math.random()}`} />;\r\n    } else {\r\n        let limitWidth = false;\r\n        let splitter;\r\n        if (props.paginated) {\r\n            splitter = positionSplitter(props.pageBreaks);\r\n        } else {\r\n            splitter = lengthSplitter(800, /^།[\\s]+(?!།[\\s]+)/, 2, 5);\r\n        }\r\n\r\n        let key = 12;\r\n        splitText = new SplitText(props.annotatedText, splitter);\r\n        inlineControls = true;\r\n        textComponent = (\r\n            <SplitTextComponent\r\n                splitText={splitText}\r\n                // annotations={this.props.annotations}\r\n                // activeAnnotations={this.props.activeAnnotations}\r\n                // activeAnnotation={this.props.activeAnnotation}\r\n                limitWidth={limitWidth}\r\n                // didSelectSegmentIds={props.didSelectSegmentIds}\r\n                selectedSegmentId={props.selectedSegmentId}\r\n                annotationPositions={props.annotationPositions}\r\n                selectedAnnotatedSegments={props?.selectedAnnotatedSegments}\r\n                // textListVisible={this.props.textListVisible}\r\n                // showImages={this.props.pageImagesVisible}\r\n                // imagesBaseUrl={this.props.imagesBaseUrl}\r\n                selectedWitness={props.selectedWitness}\r\n                key={key}\r\n                // selectedSearchResult={this.props.selectedSearchResult}\r\n                // searchValue={this.props.searchValue}\r\n                fontSize={props.textFontSize}\r\n                syncIdOnScroll={props.syncIdOnScroll}\r\n                syncIdOnClick={props.syncIdOnClick}\r\n                textAlignment={props.textAlignment}\r\n                textAlignmentById={props.textAlignmentById}\r\n                isPanelLinked={props.isPanelLinked}\r\n                changeSyncIdOnScroll2={props.changeSyncIdOnScroll2}\r\n                selectedWindow={props.selectedWindow}\r\n                selectedSourceRange={props.selectedSourceRange}\r\n                selectedTargetRange={props.selectedTargetRange}\r\n                changeSelectedRange={props.changeSelectedRange}\r\n                searchResults={props.searchResults}\r\n                searchValue={props.searchValue}\r\n                selectedText={props.text}\r\n                syncIdOnSearch={props.syncIdOnSearch}\r\n            ></SplitTextComponent>\r\n        );\r\n    }\r\n\r\n    let textComponents = [textComponent];\r\n    let thirdWindowHeight = imageStyle.ThirdWindowHeight;\r\n    let bodyHeight = \"calc(100% - \" + thirdWindowHeight + \")\";\r\n    // let condition = props.isPanelVisible;\r\n    return (\r\n        <Box\r\n            ref={ref}\r\n            className={styles.textDetail2}\r\n            style={{\r\n                height: \"100%\",\r\n                flex: 1,\r\n            }}\r\n        >\r\n            <TextDetailHeading />\r\n            <Loader loaded={!props.loading} />\r\n            <Box\r\n                style={{\r\n                    display: \"flex\",\r\n                    height: \"100%\",\r\n                    width: \"100%\",\r\n                    position: \"relative\",\r\n                }}\r\n            >\r\n                <Box\r\n                    style={{ flex: 1 }}\r\n                    className={classnames(\r\n                        styles.textContainer2,\r\n                        utilStyles.flex\r\n                    )}\r\n                >\r\n                    {!props.loading ? textComponents : <div />}\r\n                </Box>\r\n\r\n                <Slide\r\n                    direction=\"left\"\r\n                    in={props.showTableContent}\r\n                    container={ref.current}\r\n                >\r\n                    <Box\r\n                        sx={{\r\n                            position: \"absolute\",\r\n                            height: \"100%\",\r\n                            minWidth: \"50%\",\r\n                            right: 0,\r\n                            background: \"#eee\",\r\n                            borderLeft: \"1px solid gray\",\r\n                            padding: 2,\r\n                        }}\r\n                    >\r\n                        <TableOfContent />\r\n                    </Box>\r\n                </Slide>\r\n            </Box>\r\n        </Box>\r\n    );\r\n}\r\n\r\nexport default TextDetail;\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport TextDetail from \"./TextDetail\";\r\nimport * as actions from \"actions\";\r\nimport * as reducers from \"reducers\";\r\nimport AnnotatedText from \"lib/AnnotatedText\";\r\nimport _ from \"lodash\";\r\nimport * as TextStore2 from \"state_helpers/TextStore2\";\r\nimport {\r\n    showPageImages,\r\n    getAnnotationsForWitnessId,\r\n    getActiveAnnotationsForWitnessId,\r\n    getActiveAnnotation,\r\n    getActiveTextAnnotation,\r\n    getBaseWitness,\r\n    getWorkingWitness,\r\n    getSelectedText,\r\n    annotationFromData,\r\n    getAnnotationData,\r\n    getUser,\r\n    getTextListVisible,\r\n    getSelectedTextWitnessId,\r\n    getTextWitnesses,\r\n    getWitness,\r\n    hasLoadedWitnessAnnotations,\r\n    getRemovedDefaultAnnotationsForWitnessId,\r\n    hasLoadedWitnessAppliedAnnotations,\r\n    getScrollPosition,\r\n    getSelectedSearchResult,\r\n    getTextFontSize,\r\n    isSecondWindowOpen,\r\n    getImageData,\r\n    getSelectedImage,\r\n    isImagePortrait,\r\n    isPanelVisible,\r\n    getSelectedTargetRange,\r\n    getSelectedSourceRange,\r\n    getSearchResults2,\r\n} from \"reducers\";\r\n\r\nconst DISMISS_CONTROLS_ON_CLICK = true;\r\n\r\nfunction getInsertionKey(annotation) {\r\n    return [annotation.start, annotation.length].join(\"-\");\r\n}\r\n\r\nlet _posAnnotatedText;\r\nlet _posAnnotations;\r\nlet _positions;\r\nlet _posVersion;\r\nconst getAnnotationPositions = (\r\n    annotatedText: AnnotatedText,\r\n    annotations: Annotation[]\r\n): { [string]: Annotation[] } => {\r\n    if (\r\n        annotatedText === _posAnnotatedText &&\r\n        annotations === _posAnnotations &&\r\n        annotatedText.version === _posVersion\r\n    ) {\r\n        return _positions;\r\n    }\r\n\r\n    let positions = {};\r\n    let activeInsertions = {};\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n        let annotation = annotations[i];\r\n        let [startPos, length] =\r\n            annotatedText.getPositionOfAnnotation(annotation);\r\n        if (startPos == null) {\r\n            continue;\r\n        }\r\n        if (length === 0) {\r\n            if (annotation.isInsertion) {\r\n                // group with any active insertions at the same position\r\n                const activeKey = getInsertionKey(annotation);\r\n                const activeInsertionPositions = activeInsertions[activeKey];\r\n                if (activeInsertionPositions) {\r\n                    activeInsertionPositions.map((pos) =>\r\n                        positions[pos].push(annotation)\r\n                    );\r\n                    continue;\r\n                }\r\n                startPos = INSERTION_KEY + startPos;\r\n            }\r\n            if (annotation.isDeletion && annotation.length > 0) {\r\n                // active deletion\r\n                startPos = DELETION_KEY + startPos;\r\n            }\r\n            if (annotation.type === ANNOTATION_TYPES.pageBreak) {\r\n                startPos = PAGE_BREAK_KEY + startPos;\r\n            }\r\n            if (annotation.type === ANNOTATION_TYPES.lineBreak) {\r\n                startPos = LINE_BREAK_KEY + startPos;\r\n            }\r\n            if (positions[startPos] === undefined) {\r\n                positions[startPos] = [];\r\n            }\r\n            if (positions[startPos].indexOf(annotation) === -1) {\r\n                positions[startPos].push(annotation);\r\n            }\r\n        } else {\r\n            let annotationPositions = [];\r\n            for (let j = startPos; j < startPos + length; j++) {\r\n                if (positions[j] === undefined) {\r\n                    positions[j] = [];\r\n                }\r\n                if (positions[j].indexOf(annotation) === -1) {\r\n                    positions[j].push(annotation);\r\n                }\r\n                annotationPositions.push(j);\r\n            }\r\n            // Store the positions this annotation is displayed at.\r\n            // This can then be used later to group with inactive insertions\r\n            if (annotation.isInsertion) {\r\n                const key = getInsertionKey(annotation);\r\n                activeInsertions[key] = annotationPositions;\r\n            }\r\n        }\r\n    }\r\n\r\n    _posAnnotatedText = annotatedText;\r\n    _posAnnotations = annotations;\r\n    _positions = positions;\r\n    _posVersion = annotatedText.version;\r\n    return positions;\r\n};\r\n\r\nconst mapStateToProps = (state: AppState): {} => {\r\n    let selectedWitness = {};\r\n    let annotatedText = null;\r\n    let workingWitness;\r\n    let textFontSize = reducers.getTextFontSize2(state);\r\n    let selectedText = reducers.getSelectedText2(state);\r\n    let annotationPositions = {};\r\n    let annotations = [];\r\n    if (selectedText) {\r\n        workingWitness = reducers.getWorkingWitness2(state, selectedText.id);\r\n        let selectedWitnessId = reducers.getSelectedTextWitnessId2(\r\n            state,\r\n            selectedText.id\r\n        );\r\n        if (selectedWitnessId) {\r\n            selectedWitness = reducers.getWitness2(state, selectedWitnessId);\r\n        }\r\n        if (!selectedWitness) {\r\n            selectedWitness = workingWitness;\r\n        }\r\n    }\r\n    annotatedText = TextStore2.getWitnessText(state, selectedWitness.id);\r\n    const loading = state.data2.loadingWitnesses;\r\n\r\n    if (annotatedText) {\r\n        annotationPositions = getAnnotationPositions(\r\n            annotatedText,\r\n            (Object.values(annotations): any)\r\n        );\r\n    }\r\n    const isPanelLinked = reducers.isPanelLinked(state);\r\n    const syncIdOnScroll = reducers.getSyncIdOnScroll(state);\r\n    const syncIdOnClick = reducers.getSyncIdOnClick(state);\r\n    const textAlignment = reducers.getTextAlignment(state);\r\n    const selectedWindow = reducers.getSelectedWindow(state);\r\n    const searchValue = reducers.getSearchValue2(state);\r\n    return {\r\n        text: selectedText,\r\n        textFontSize,\r\n        annotatedText,\r\n        selectedWitness,\r\n        loading: loading,\r\n        annotationPositions,\r\n        isSecondWindowOpen: isSecondWindowOpen(state),\r\n        imageData: getImageData(state),\r\n        isPanelLinked,\r\n        selectedImage: getSelectedImage(state),\r\n        isImagePortrait: isImagePortrait(state),\r\n        isPanelVisible: isPanelVisible(state),\r\n        syncIdOnScroll,\r\n        syncIdOnClick,\r\n        textAlignment,\r\n        textAlignmentById: reducers.getTextAlignmentById(state),\r\n        selectedWindow,\r\n        selectedSourceRange: getSelectedSourceRange(state),\r\n        selectedTargetRange: getSelectedTargetRange(state),\r\n        showTableContent: reducers.getShowTableContent2(state),\r\n        searchResults: getSearchResults2(state, searchValue),\r\n        searchValue,\r\n        syncIdOnSearch: reducers.getSyncIdOnSearch2(state),\r\n    };\r\n};\r\n\r\nconst mergeProps = (stateProps, dispatchProps, ownProps) => {\r\n    const { annotatedText, annotationPositions } = stateProps;\r\n    const { dispatch } = dispatchProps;\r\n\r\n    const isDeletion = (id) => {\r\n        return id.indexOf(\"ds2_\") !== -1;\r\n    };\r\n    const isInsertion = (id) => {\r\n        return id.indexOf(\"i2_\") !== -1;\r\n    };\r\n    const isPageBreak = (id) => {\r\n        return id.indexOf(\"p2_\") !== -1;\r\n    };\r\n\r\n    const isLineBreak = (id) => {\r\n        return id.indexOf(\"l2_\") !== -1;\r\n    };\r\n\r\n    const idFromSegmentId = (id) => {\r\n        let start = 0;\r\n        if (isInsertion(id)) {\r\n            start = id.substr(2);\r\n        } else if (isDeletion(id)) {\r\n            start = id.substr(3);\r\n        } else {\r\n            start = id.substr(2);\r\n        }\r\n\r\n        return start;\r\n    };\r\n\r\n    const didSelectSegmentPosition = (segmentPosition, start, length) => {\r\n        let segmentAnnotations = annotationPositions[segmentPosition];\r\n        let segmentVariants = [];\r\n        let segmentPageBreaks = [];\r\n        let segmentLineBreaks = [];\r\n        if (segmentAnnotations) {\r\n            segmentVariants = segmentAnnotations.filter(\r\n                (annotation: Annotation) =>\r\n                    annotation.type === ANNOTATION_TYPES.variant\r\n            );\r\n            segmentPageBreaks = segmentAnnotations.filter(\r\n                (annotation: Annotation) =>\r\n                    annotation.type === ANNOTATION_TYPES.pageBreak\r\n            );\r\n            segmentLineBreaks = segmentAnnotations.filter(\r\n                (annotation: Annotation) =>\r\n                    annotation.type === ANNOTATION_TYPES.lineBreak\r\n            );\r\n        }\r\n        let activeAnnotations = _.intersectionWith(\r\n            segmentVariants.concat(segmentPageBreaks, segmentLineBreaks),\r\n            annotatedText.annotations,\r\n            (a, b) => a.toString() == b.toString()\r\n        );\r\n        let activeAnnotation = null;\r\n        if (activeAnnotations.length > 0) {\r\n            // get any active annotations\r\n            activeAnnotation = activeAnnotations[0];\r\n        } else if (segmentVariants && segmentVariants.length > 0) {\r\n            // get base text annotation for longest annotation highlighted in text\r\n            let longestAvailable = getLongestAnnotation(segmentVariants);\r\n            let [start, textLength] =\r\n                annotatedText.getPositionOfAnnotation(longestAvailable);\r\n            if (longestAvailable && longestAvailable.isInsertion) {\r\n                textLength = 0;\r\n            }\r\n            activeAnnotation = annotatedText.getBaseAnnotation(\r\n                start,\r\n                textLength\r\n            );\r\n        } else {\r\n            // get base annotation of just the segment\r\n            activeAnnotation = annotatedText.getBaseAnnotation(start, length);\r\n        }\r\n\r\n        // dispatch(actions.changedActiveTextAnnotation(activeAnnotation));\r\n    };\r\n\r\n    return {\r\n        ...ownProps,\r\n        ...stateProps,\r\n        onChangedFontSize: (fontSize: number) => {\r\n            dispatch(actions.changedTextFontSize(fontSize));\r\n        },\r\n\r\n        didSelectSegmentIds: (segmentIds) => {\r\n            if (segmentIds.length === 0) {\r\n                return;\r\n            }\r\n            let segmentAnnotations = [];\r\n            let segments = [];\r\n            for (let segmentId of segmentIds) {\r\n                if (isDeletion(segmentId) || isInsertion(segmentId)) {\r\n                    continue;\r\n                }\r\n\r\n                let segmentPosition = idFromSegmentId(segmentId);\r\n                let textSegment =\r\n                    annotatedText.segmentedText.segmentAtPosition(\r\n                        segmentPosition\r\n                    );\r\n                segments.push(textSegment);\r\n                const annotations = annotationPositions[textSegment.start];\r\n                if (annotations) {\r\n                    segmentAnnotations = segmentAnnotations.concat(annotations);\r\n                }\r\n            }\r\n            segmentAnnotations = _.uniqWith(\r\n                segmentAnnotations,\r\n                (a, b) => a.toString() == b.toString()\r\n            );\r\n\r\n            let activeAnnotations = _.intersectionWith(\r\n                segmentAnnotations,\r\n                annotatedText.annotations,\r\n                (a, b) => a.toString() == b.toString()\r\n            );\r\n\r\n            const range = getSegmentsRange(\r\n                segments,\r\n                activeAnnotations,\r\n                segmentAnnotations,\r\n                stateProps.annotatedText\r\n            );\r\n            if (!range) {\r\n                console.warn(\r\n                    \"No range for selected segment ids: %o\",\r\n                    segmentIds\r\n                );\r\n                return;\r\n            }\r\n            const baseAnnotation = annotatedText.getBaseAnnotation(\r\n                range.start,\r\n                range.length\r\n            );\r\n            let activeAnnotation = null;\r\n            if (range.annotation) {\r\n                activeAnnotation = range.annotation;\r\n            } else if (activeAnnotations.length > 0) {\r\n                const content = annotatedText.segmentedText\r\n                    .segmentsInRange(range.start, range.length)\r\n                    .reduce((content, segment) => content + segment.text, \"\");\r\n                // TODO: test this when editing non-working edition.\r\n                // Check if getTextWorkingWitness works as required\r\n                if (!stateProps.selectedWitness) {\r\n                    console.log(\r\n                        \"no stateProps.selectedWitness: %o\",\r\n                        stateProps.selectedWitness\r\n                    );\r\n                }\r\n                activeAnnotation = new Annotation(\r\n                    WORKING_VERSION_ANNOTATION_ID,\r\n                    getTextWorkingWitness(stateProps.text),\r\n                    baseAnnotation.start,\r\n                    baseAnnotation.length,\r\n                    content,\r\n                    ANNOTATION_TYPES.variant,\r\n                    stateProps.selectedWitness,\r\n                    stateProps.user\r\n                );\r\n            } else {\r\n                activeAnnotation = baseAnnotation;\r\n            }\r\n            // dispatch(changedActiveTextAnnotation(activeAnnotation));\r\n        },\r\n        changeSyncIdOnScroll2: (payload) =>\r\n            dispatch(actions.changeSyncIdOnScroll2(payload)),\r\n        changeSelectedWindow: (payload) => {\r\n            dispatch(actions.changeSelectedWindow(payload));\r\n        },\r\n        changeSelectedRange: (payload) => {\r\n            dispatch(actions.changeSelectedRange(payload));\r\n        },\r\n        changeShowTableContent: (payload) => {\r\n            dispatch(actions.showTableContent2(payload));\r\n        },\r\n        selectedSegmentId: (segmentId) => {\r\n            let start = idFromSegmentId(segmentId);\r\n            let positionKey = start;\r\n            if (isInsertion(segmentId)) {\r\n                positionKey = INSERTION_KEY + start;\r\n            } else if (isDeletion(segmentId)) {\r\n                positionKey = DELETION_KEY + start;\r\n            } else if (isPageBreak(segmentId)) {\r\n                positionKey = PAGE_BREAK_KEY + start;\r\n            } else if (isLineBreak(segmentId)) {\r\n                positionKey = LINE_BREAK_KEY + start;\r\n            }\r\n\r\n            let segmentAnnotations = annotationPositions[positionKey];\r\n            if (DISMISS_CONTROLS_ON_CLICK && stateProps.activeAnnotation) {\r\n                const activeAnnotation = stateProps.activeAnnotation;\r\n                if (activeAnnotation) {\r\n                    const dismissTextAnnotation =\r\n                        actions.changedActiveTextAnnotation(null);\r\n                    dispatch(dismissTextAnnotation);\r\n                }\r\n            }\r\n            //  else {\r\n            //     if (\r\n            //         isInsertion(segmentId) ||\r\n            //         isDeletion(segmentId) ||\r\n            //         isPageBreak(segmentId) ||\r\n            //         isLineBreak(segmentId)\r\n            //     ) {\r\n            //         const length = 0;\r\n            //         didSelectSegmentPosition(positionKey, start, length);\r\n            //     } else {\r\n            //         let segmentPosition = Number(idFromSegmentId(segmentId));\r\n            //         let textSegment = annotatedText.segmentedText.segmentAtPosition(\r\n            //             segmentPosition\r\n            //         );\r\n            //         if (textSegment) {\r\n            //             didSelectSegmentPosition(\r\n            //                 textSegment.start,\r\n            //                 textSegment.start,\r\n            //                 textSegment.length\r\n            //             );\r\n            //         }\r\n            //     }\r\n            // }\r\n        },\r\n    };\r\n};\r\n\r\nconst TextDetailContainer = connect(\r\n    mapStateToProps,\r\n    null,\r\n    mergeProps\r\n)(TextDetail);\r\n\r\nexport default TextDetailContainer;\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport TextDetailHeading from \"./TextDetailHeading\";\r\nimport * as actions from \"actions\";\r\nimport * as reducers from \"reducers\";\r\nimport type { AppState } from \"reducers\";\r\nimport {\r\n    getTextListVisible,\r\n    getAccountOverlayVisible,\r\n    getShowTableContent2,\r\n} from \"reducers\";\r\n\r\nconst mapStateToProps = (state: AppState): {} => {\r\n    const user = reducers.getUser(state);\r\n    const selectedText = reducers.getSelectedText2(state);\r\n    let witnesses = [];\r\n    let exportingWitness = false;\r\n    let selectedWitness;\r\n    if (selectedText) {\r\n        witnesses = reducers.getTextWitnesses2(state, selectedText.id);\r\n        const selectedWitnessId = reducers.getSelectedTextWitnessId2(\r\n            state,\r\n            selectedText.id\r\n        );\r\n        if (selectedWitnessId) {\r\n            selectedWitness = reducers.getWitness2(state, selectedWitnessId);\r\n            // exportingWitness = reducers.getExportingWitness(\r\n            //     state,\r\n            //     selectedWitnessId\r\n            // );\r\n        } else {\r\n            selectedWitness = reducers.getWorkingWitness2(\r\n                state,\r\n                selectedText.id\r\n            );\r\n        }\r\n    }\r\n    let textFontSize = reducers.getTextFontSize2(state);\r\n    let showTableContent = getShowTableContent2(state);\r\n    let searchValue = reducers.getSearchValue2(state);\r\n    return {\r\n        witnesses,\r\n        selectedText,\r\n        selectedWitness,\r\n        textListIsVisible: getTextListVisible(state),\r\n        accountOverlayVisible: getAccountOverlayVisible(state),\r\n        textFontSize,\r\n        user,\r\n        searchValue,\r\n        showTableContent,\r\n        searchResults: reducers.getSearchResults2(state, searchValue),\r\n    };\r\n};\r\n\r\nconst mergeProps = (stateProps, dispatchProps, ownProps) => {\r\n    const navigationButtonClicked = () => {\r\n        dispatchProps.dispatch(\r\n            actions.changedTextListVisible(!stateProps.textListIsVisible)\r\n        );\r\n    };\r\n\r\n    const { dispatch } = dispatchProps;\r\n    const { selectedText } = stateProps;\r\n\r\n    return {\r\n        ...ownProps,\r\n        ...stateProps,\r\n        navigationButtonClicked,\r\n        onSelectedWitness: (witness: Witness) => {\r\n            dispatch(actions.selectedTextWitness2(selectedText.id, witness.id));\r\n        },\r\n        onChangedFontSize: (fontSize: number) => {\r\n            dispatch(actions.changedTextFontSize2(fontSize));\r\n        },\r\n        changeShowTableContent: (payload) => {\r\n            dispatch(actions.showTableContent2(payload));\r\n        },\r\n        searchChanged: (searchTerm: string) => {\r\n            dispatch(actions.changedSearchValue2(searchTerm));\r\n        },\r\n        changeSelectSyncId: (payload) => {\r\n            dispatch(actions.changeSyncIdOnSearch2(payload));\r\n        },\r\n    };\r\n};\r\n\r\nconst TextDetailHeadingContainer = connect(\r\n    mapStateToProps,\r\n    null,\r\n    mergeProps\r\n)(TextDetailHeading);\r\n\r\nexport default TextDetailHeadingContainer;\r\n","// @flow\r\nimport SegmentedText from \"./SegmentedText\";\r\nimport AnnotatedText from \"./AnnotatedText\";\r\n\r\nexport type Splitter = (string) => number[];\r\n\r\nexport default class SplitText {\r\n    annotatedText: AnnotatedText;\r\n    splitter: Splitter;\r\n    _texts: SegmentedText[] | null;\r\n    _textsId: string | null;\r\n    _textsFinalPositions: number[];\r\n\r\n    constructor(annotatedText: AnnotatedText, splitter: Splitter) {\r\n        this.annotatedText = annotatedText;\r\n        this.splitter = splitter;\r\n        this._texts = null;\r\n        this._textsId = null;\r\n        this._textsFinalPositions = [];\r\n    }\r\n\r\n    get texts(): SegmentedText[] {\r\n        if (!this.annotatedText) {\r\n            return [];\r\n        }\r\n        if (\r\n            !this._texts ||\r\n            this._textsId !== this.annotatedText.getUniqueId()\r\n        ) {\r\n            this._textsFinalPositions = [];\r\n            const segmentedText = this.annotatedText.segmentedText;\r\n            const textString = segmentedText.getText();\r\n            let splitPositions = this.splitter(textString).filter(\r\n                (l) => l !== 0\r\n            );\r\n            if (splitPositions.length === 0) {\r\n                this._textsFinalPositions.push(textString.length);\r\n                return [segmentedText];\r\n            }\r\n            let lastPosition = splitPositions[splitPositions.length - 1];\r\n            if (lastPosition + 1 < textString.length) {\r\n                splitPositions.push(textString.length - 1);\r\n            }\r\n            const segments = segmentedText.segments;\r\n            let startIndex = 0;\r\n            let texts = [];\r\n            for (let i = 0; i < splitPositions.length; i++) {\r\n                const position = splitPositions[i];\r\n                const endIndex = segmentedText.indexOfSegmentAtPosition(\r\n                    position - 1\r\n                );\r\n                let textSegments;\r\n                if (i == splitPositions.length - 1) {\r\n                    // final position\r\n                    textSegments = segments.slice(startIndex);\r\n                } else {\r\n                    textSegments = segments.slice(startIndex, endIndex + 1);\r\n                }\r\n\r\n                const text = new SegmentedText(textSegments);\r\n                texts.push(text);\r\n                startIndex = endIndex + 1;\r\n                if (endIndex >= 0) {\r\n                    const finalSegment = segments[endIndex];\r\n                    this._textsFinalPositions.push(finalSegment.end);\r\n                }\r\n            }\r\n\r\n            this._texts = texts.filter((l) => l.segments.length > 0);\r\n            this._textsId = this.annotatedText.getUniqueId();\r\n        }\r\n        return this._texts || [];\r\n    }\r\n\r\n    getTextsFinalPositions(): number[] {\r\n        this.texts;\r\n        return this._textsFinalPositions;\r\n    }\r\n\r\n    /**\r\n     * Return the index of the text portion that contains the given position.\r\n     *\r\n     * @param position\r\n     * @returns number\r\n     */\r\n    getTextIndexOfPosition(position: number): number {\r\n        const textsFinalPositions = this.getTextsFinalPositions();\r\n        let lastPosition = 0;\r\n        let textIndex = null;\r\n        for (let i = 0; i < textsFinalPositions.length; i++) {\r\n            let endPosition = textsFinalPositions[i];\r\n            if (position >= lastPosition && position <= endPosition) {\r\n                textIndex = i;\r\n                break;\r\n            }\r\n            lastPosition = endPosition;\r\n        }\r\n        if (textIndex === null) {\r\n            // Likely an insertion at the end of a text\r\n            console.warn(\"no index for position %d\", position);\r\n            textIndex = textsFinalPositions.length - 1;\r\n        }\r\n        return textIndex;\r\n    }\r\n}\r\n","// @flow\r\nimport * as reducers from \"reducers\";\r\nimport type { AppState } from \"reducers\";\r\nimport AnnotatedText from \"lib/AnnotatedText\";\r\nimport Witness from \"lib/Witness\";\r\nimport Annotation, { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport type { AnnotationData, TextData } from \"api\";\r\nimport segmentTibetanText from \"lib/segmentTibetanText\";\r\nimport SegmentedText from \"lib/SegmentedText\";\r\nimport _ from \"lodash\";\r\n\r\nlet store: { [witnessId: number]: AnnotatedText } = {};\r\n\r\nexport const getWitnessText = (\r\n    state: AppState,\r\n    witnessId: number\r\n): AnnotatedText | null => {\r\n    let text: AnnotatedText | null = null;\r\n  \r\n        if (\r\n            witnessId\r\n        ) {\r\n            text = generateAnnotatedText(state, witnessId);\r\n            if (text) {\r\n                store[witnessId] = text;\r\n                \r\n            }\r\n    }\r\n\r\n    return text;\r\n};\r\n\r\nexport const addTextAnnotation = (\r\n    state: AppState,\r\n    witnessId: number,\r\n    annotation: Annotation\r\n) => {\r\n    const text = getWitnessText(state, witnessId);\r\n    if (text) {\r\n        text.addAnnotation(annotation);\r\n    }\r\n    // If witnessId is present, assume that getWitnessAnnotations\r\n    // has already been called.\r\n    if (annotationStore.hasOwnProperty(witnessId)) {\r\n        if (\r\n            !annotationStore[witnessId].appliedAnnotations.hasOwnProperty(\r\n                annotation.uniqueId\r\n            )\r\n        ) {\r\n            annotationStore[witnessId].appliedAnnotations[\r\n                annotation.uniqueId\r\n            ] = annotation;\r\n        }\r\n        if (\r\n            !annotationStore[witnessId].allAnnotations.hasOwnProperty(\r\n                annotation.uniqueId\r\n            )\r\n        ) {\r\n            annotationStore[witnessId].allAnnotations[\r\n                annotation.uniqueId\r\n            ] = annotation;\r\n        }\r\n    }\r\n};\r\n\r\nexport const removeTextAnnotation = (\r\n    state: AppState,\r\n    witnessId: number,\r\n    annotationId: AnnotationUniqueId\r\n) => {\r\n    const text = getWitnessText(state, witnessId);\r\n    if (text) {\r\n        text.removeAnnotation(annotationId);\r\n    }\r\n    if (annotationStore.hasOwnProperty(witnessId)) {\r\n        if (\r\n            annotationStore[witnessId].appliedAnnotations.hasOwnProperty(\r\n                annotationId\r\n            )\r\n        ) {\r\n            delete annotationStore[witnessId].appliedAnnotations[\r\n                annotationId\r\n            ];\r\n        }\r\n    }\r\n};\r\n\r\nexport const deleteTextAnnotation = (\r\n    state: AppState,\r\n    witnessId: number,\r\n    annotationId: AnnotationUniqueId\r\n) => {\r\n    const text = getWitnessText(state, witnessId);\r\n    if (text) {\r\n        text.removeAnnotation(annotationId);\r\n    }\r\n    if (annotationStore.hasOwnProperty(witnessId)) {\r\n        if (\r\n            annotationStore[witnessId].allAnnotations.hasOwnProperty(\r\n                annotationId\r\n            )\r\n        ) {\r\n            delete annotationStore[witnessId].allAnnotations[\r\n                annotationId\r\n            ];\r\n        }\r\n        if (\r\n            annotationStore[witnessId].appliedAnnotations.hasOwnProperty(\r\n                annotationId\r\n            )\r\n        ) {\r\n            delete annotationStore[witnessId].appliedAnnotations[\r\n                annotationId\r\n            ];\r\n        }\r\n    }\r\n}\r\n\r\nlet annotationStore: {\r\n    [witnessId: number]: {\r\n        appliedAnnotations: { [AnnotationUniqueId]: Annotation },\r\n        allAnnotations: { [AnnotationUniqueId]: Annotation }\r\n    }\r\n} = {};\r\n\r\nexport const getWitnessAnnotations = (\r\n    state: AppState,\r\n    witness: Witness,\r\n    workingWitness: Witness\r\n): [\r\n    { [AnnotationUniqueId]: Annotation },\r\n    { [AnnotationUniqueId]: Annotation }\r\n] => {\r\n    if (annotationStore.hasOwnProperty(witness.id)) {\r\n        return [\r\n            annotationStore[witness.id].appliedAnnotations,\r\n            annotationStore[witness.id].allAnnotations\r\n        ];\r\n    }\r\n\r\n    const text = witness.text;\r\n\r\n    let workingAnnotationList = reducers.getAnnotationsForWitnessId(\r\n        state,\r\n        workingWitness.id\r\n    );\r\n\r\n    let appliedAnnotations = getActiveAnnotations(\r\n        state,\r\n        witness.id,\r\n        workingWitness.id\r\n    );\r\n\r\n    let removedDefaultAnnotations = null;\r\n    // Default annotations removed by the user.\r\n    // Usually these are available when viewing\r\n    // a non-working edition.\r\n    let nonActiveAnnotations = {};\r\n\r\n    if (witness.id !== workingWitness.id) {\r\n        // If we are not viewing the working version,\r\n        // get all the annotations created by the selected witness\r\n        // BUT NOT BY A USER to apply to the base text.\r\n        // User-created annotations need to be in appliedAnnotations.\r\n\r\n        removedDefaultAnnotations = reducers.getRemovedDefaultAnnotationsForWitnessId(\r\n            state,\r\n            witness.id\r\n        );\r\n\r\n        let selectedWitnessAnnotations = {};\r\n\r\n        for (let key in workingAnnotationList) {\r\n            if (workingAnnotationList.hasOwnProperty(key)) {\r\n                let annotationData = workingAnnotationList[key];\r\n                if (\r\n                    annotationData.creator_witness === witness.id &&\r\n                    !removedDefaultAnnotations.hasOwnProperty(\r\n                        annotationData.unique_id\r\n                    )\r\n                ) {\r\n                    selectedWitnessAnnotations[\r\n                        annotationData.unique_id\r\n                    ] = annotationData;\r\n                } else if (annotationData.creator_witness === witness.id) {\r\n                    nonActiveAnnotations[\r\n                        annotationData.unique_id\r\n                    ] = annotationData;\r\n                }\r\n            }\r\n        }\r\n\r\n        let selectedWitnessAnnotationsList = annotationsMapFromData(\r\n            state,\r\n            selectedWitnessAnnotations\r\n        );\r\n\r\n        appliedAnnotations = {\r\n            ...selectedWitnessAnnotationsList,\r\n            ...appliedAnnotations\r\n        };\r\n\r\n        workingAnnotationList = selectedWitnessAnnotations;\r\n    }\r\n\r\n    let annotations = annotationsMapFromData(state, workingAnnotationList);\r\n    nonActiveAnnotations = annotationsMapFromData(state, nonActiveAnnotations);\r\n    if (Object.keys(nonActiveAnnotations).length > 0) {\r\n        annotations = {\r\n            ...annotations,\r\n            ...nonActiveAnnotations\r\n        };\r\n    }\r\n\r\n    annotations = {\r\n        ...appliedAnnotations,\r\n        ...annotations\r\n    };\r\n\r\n    annotations = _.pickBy(\r\n        annotations,\r\n        (annotation: Annotation, key: AnnotationUniqueId) => {\r\n            return !(\r\n                witness &&\r\n                annotation.type === ANNOTATION_TYPES.lineBreak &&\r\n                annotation.creatorWitness.id !== witness.id\r\n            );\r\n        }\r\n    );\r\n\r\n    // Only cache if annotations have been loaded\r\n    if (\r\n        reducers.hasLoadedWitnessAnnotations(state, witness.id) &&\r\n        reducers.hasLoadedWitnessAppliedAnnotations(state, witness.id)\r\n    ) {\r\n        annotationStore[witness.id] = {\r\n            appliedAnnotations: appliedAnnotations,\r\n            allAnnotations: annotations\r\n        };\r\n    }\r\n\r\n    return [appliedAnnotations, annotations];\r\n};\r\n\r\nconst generateAnnotatedText = (\r\n    state: AppState,\r\n    witnessId: number\r\n): AnnotatedText | null => {\r\n    const witness = reducers.getWitness2(state, witnessId);\r\n    if (!witness) {\r\n        console.warn(\"no witness\");\r\n        return null;\r\n    }\r\n    const text = witness.text;\r\n    const workingWitness = reducers.getWorkingWitness2(state, text.id);\r\n    const baseWitness = reducers.getBaseWitness2(state, text.id);\r\n   \r\n    if (!workingWitness || !baseWitness) {\r\n    \r\n        return null;\r\n    }\r\n\r\n    let [appliedAnnotations, availableAnnotations] = getWitnessAnnotations(\r\n        state,\r\n        witness,\r\n        workingWitness\r\n    );\r\n    let segmentedWorkingWitness = getSegmentedWitness(workingWitness);\r\n    let annotatedText = new AnnotatedText(\r\n        segmentedWorkingWitness,\r\n        (Object.values(appliedAnnotations): any),\r\n        text => segmentTibetanText(text).segments,\r\n        workingWitness,\r\n        witness\r\n    );\r\n\r\n    return annotatedText;\r\n};\r\n\r\nconst getActiveAnnotations = (\r\n    state: AppState,\r\n    witnessId,\r\n    baseWitnessId\r\n): { [AnnotationUniqueId]: Annotation } => {\r\n    const loadedAppliedAnnotations = reducers.hasLoadedWitnessAppliedAnnotations(\r\n        state,\r\n        witnessId\r\n    );\r\n    if (!loadedAppliedAnnotations) {\r\n        return {};\r\n    }\r\n    const activeAnnotationList = reducers.getActiveAnnotationsForWitnessId(\r\n        state,\r\n        witnessId\r\n    );\r\n    if (!activeAnnotationList) {\r\n        return {};\r\n    }\r\n\r\n    let activeAnnotationDataList = {};\r\n    for (let activeAnnotationId in activeAnnotationList) {\r\n        if (activeAnnotationList.hasOwnProperty(activeAnnotationId)) {\r\n            let activeAnnotationData = reducers.getAnnotationData(\r\n                state,\r\n                baseWitnessId,\r\n                activeAnnotationId\r\n            );\r\n            if (activeAnnotationData) {\r\n                activeAnnotationDataList[\r\n                    activeAnnotationData.unique_id\r\n                ] = activeAnnotationData;\r\n            }\r\n        }\r\n    }\r\n\r\n    return annotationsMapFromData(state, activeAnnotationDataList);\r\n};\r\n\r\nconst annotationsMapFromData = (\r\n    state: AppState,\r\n    annotationList: { [AnnotationUniqueId]: AnnotationData }\r\n): { [AnnotationUniqueId]: Annotation } => {\r\n    let annotations = {};\r\n    for (let key in annotationList) {\r\n        if (annotationList.hasOwnProperty(key)) {\r\n            let annotationData = annotationList[key];\r\n            let annotation = reducers.annotationFromData(state, annotationData);\r\n            if (annotation) {\r\n                annotations[key] = annotation;\r\n            }\r\n        }\r\n    }\r\n    return annotations;\r\n};\r\n\r\n// TODO: clear cache when changing texts\r\nlet _segmentedWitnesses: { [number]: SegmentedText } = {};\r\nfunction getSegmentedWitness(witness: Witness): SegmentedText {\r\n    if (!_segmentedWitnesses[witness.id]) {\r\n        _segmentedWitnesses[witness.id] = segmentTibetanText(\r\n            witness.content || \"\"\r\n        );\r\n    }\r\n\r\n    return _segmentedWitnesses[witness.id];\r\n}\r\n"],"mappings":";;;;;;;;;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AA+BA;;;;;AAiBA;AAcA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;AA0BA;AACA;;;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AACA;;;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;;;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAGA;AAAA;AACA;AAAA;AAMA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAEA;AAEA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;;;AACA;AAOA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AACA;AADA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAHA;AAMA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAHA;AAMA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AADA;AAiBA;;;AACA;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAEA;AAUA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAOA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAPA;AAQA;AACA;AACA;AACA;AACA;AACA;AAbA;AAmBA;;;;AA93BA;AACA;;;;;;;;;;;;;ACnDA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAKA;AACA;AACA;;;;;;;;;;;ACZA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AA4BA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AADA;AAGA;AAEA;AACA;AATA;AAUA;AACA;;;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAXA;AAAA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AA7HA;AACA;AAUA;AAAA;AACA;AADA;AA4HA;AACA;AACA;AACA;AAEA;AACA;AADA;AAGA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AADA;AAJA;AAUA;;;;AAzQA;AACA;;;;;;;;;;;;AC1EA;AACA;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAJA;AAKA;AALA;AAOA;AACA;AACA;AAEA;AACA;AAZA;AAaA;AACA;AAEA;AAhBA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/BA;AAkCA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAJA;AADA;AASA;AAAA;AAAA;AACA;AAFA;AAWA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AADA;AAiBA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/IA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAjEA;AACA;AAWA;AAAA;AACA;AADA;AAsDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvBA;AAyBA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AANA;AAAA;AACA;AADA;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AArBA;AAAA;AAAA;AAAA;AAAA;AACA;AAqBA;AAEA;AAAA;AACA;AAEA;AAGA;AAAA;AACA;AAEA;AACA;AAKA;AACA;AAIA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AAIA;AACA;AAAA;AAUA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AA/IA;AAiJA;AACA;AACA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvaA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAoBA;AACA;AACA;AAMA;;;;;;;;;;;;;;;;;;;;;;AC5FA;AACA;AACA;AAGA;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtGA;AAEA;AACA;AACA;AAGA;AACA;AAGA;AAEA;AAIA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AAKA;AAGA;AACA;AAAA;AAKA;AAGA;AACA;AACA;AAEA;AAKA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAKA;AAGA;AACA;AACA;AAEA;AAKA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAKA;AAGA;AACA;AAAA;AAKA;AAGA;AACA;AACA;AAEA;AAOA;AAQA;AACA;AAIA;AACA;AACA;AAEA;AAKA;AAMA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AAMA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AAKA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AAKA;AAGA;AAKA;AACA;AAGA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AAGA;AAAA;AAKA;AACA;AACA;AACA;AAKA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;A","sourceRoot":""}