{"version":3,"file":"34.parkhang-dev.js","sources":["webpack://parkhang/./app/components/TextDetail2/TextDetailContainer.js","webpack://parkhang/./app/state_helpers/TextStore2.js"],"sourcesContent":["// @flow\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport TextDetail from \"./TextDetail\";\r\nimport * as actions from \"actions\";\r\nimport * as reducers from \"reducers\";\r\nimport AnnotatedText from \"lib/AnnotatedText\";\r\nimport _ from \"lodash\";\r\nimport * as TextStore2 from \"state_helpers/TextStore2\";\r\nimport {\r\n    showPageImages,\r\n    getAnnotationsForWitnessId,\r\n    getActiveAnnotationsForWitnessId,\r\n    getActiveAnnotation,\r\n    getActiveTextAnnotation,\r\n    getBaseWitness,\r\n    getWorkingWitness,\r\n    getSelectedText,\r\n    annotationFromData,\r\n    getAnnotationData,\r\n    getUser,\r\n    getTextListVisible,\r\n    getSelectedTextWitnessId,\r\n    getTextWitnesses,\r\n    getWitness,\r\n    hasLoadedWitnessAnnotations,\r\n    getRemovedDefaultAnnotationsForWitnessId,\r\n    hasLoadedWitnessAppliedAnnotations,\r\n    getScrollPosition,\r\n    getSelectedSearchResult,\r\n    getTextFontSize,\r\n    isSecondWindowOpen,\r\n    getImageData,\r\n    getSelectedImage,\r\n    isImagePortrait,\r\n    isPanelVisible,\r\n    getSelectedTargetRange,\r\n    getSelectedSourceRange,\r\n    getSearchResults2,\r\n} from \"reducers\";\r\n\r\nconst DISMISS_CONTROLS_ON_CLICK = true;\r\n\r\nfunction getInsertionKey(annotation) {\r\n    return [annotation.start, annotation.length].join(\"-\");\r\n}\r\n\r\nlet _posAnnotatedText;\r\nlet _posAnnotations;\r\nlet _positions;\r\nlet _posVersion;\r\nconst getAnnotationPositions = (\r\n    annotatedText: AnnotatedText,\r\n    annotations: Annotation[]\r\n): { [string]: Annotation[] } => {\r\n    if (\r\n        annotatedText === _posAnnotatedText &&\r\n        annotations === _posAnnotations &&\r\n        annotatedText.version === _posVersion\r\n    ) {\r\n        return _positions;\r\n    }\r\n\r\n    let positions = {};\r\n    let activeInsertions = {};\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n        let annotation = annotations[i];\r\n        let [startPos, length] =\r\n            annotatedText.getPositionOfAnnotation(annotation);\r\n        if (startPos == null) {\r\n            continue;\r\n        }\r\n        if (length === 0) {\r\n            if (annotation.isInsertion) {\r\n                // group with any active insertions at the same position\r\n                const activeKey = getInsertionKey(annotation);\r\n                const activeInsertionPositions = activeInsertions[activeKey];\r\n                if (activeInsertionPositions) {\r\n                    activeInsertionPositions.map((pos) =>\r\n                        positions[pos].push(annotation)\r\n                    );\r\n                    continue;\r\n                }\r\n                startPos = INSERTION_KEY + startPos;\r\n            }\r\n            if (annotation.isDeletion && annotation.length > 0) {\r\n                // active deletion\r\n                startPos = DELETION_KEY + startPos;\r\n            }\r\n            if (annotation.type === ANNOTATION_TYPES.pageBreak) {\r\n                startPos = PAGE_BREAK_KEY + startPos;\r\n            }\r\n            if (annotation.type === ANNOTATION_TYPES.lineBreak) {\r\n                startPos = LINE_BREAK_KEY + startPos;\r\n            }\r\n            if (positions[startPos] === undefined) {\r\n                positions[startPos] = [];\r\n            }\r\n            if (positions[startPos].indexOf(annotation) === -1) {\r\n                positions[startPos].push(annotation);\r\n            }\r\n        } else {\r\n            let annotationPositions = [];\r\n            for (let j = startPos; j < startPos + length; j++) {\r\n                if (positions[j] === undefined) {\r\n                    positions[j] = [];\r\n                }\r\n                if (positions[j].indexOf(annotation) === -1) {\r\n                    positions[j].push(annotation);\r\n                }\r\n                annotationPositions.push(j);\r\n            }\r\n            // Store the positions this annotation is displayed at.\r\n            // This can then be used later to group with inactive insertions\r\n            if (annotation.isInsertion) {\r\n                const key = getInsertionKey(annotation);\r\n                activeInsertions[key] = annotationPositions;\r\n            }\r\n        }\r\n    }\r\n\r\n    _posAnnotatedText = annotatedText;\r\n    _posAnnotations = annotations;\r\n    _positions = positions;\r\n    _posVersion = annotatedText.version;\r\n    return positions;\r\n};\r\n\r\nconst mapStateToProps = (state: AppState): {} => {\r\n    let selectedWitness = {};\r\n    let annotatedText = null;\r\n    let workingWitness;\r\n    let textFontSize = reducers.getTextFontSize2(state);\r\n    let selectedText = reducers.getSelectedText2(state);\r\n    let annotationPositions = {};\r\n    let annotations = [];\r\n    if (selectedText) {\r\n        workingWitness =\r\n            reducers.getWorkingWitness2(state, selectedText.id) || {};\r\n        let selectedWitnessId = reducers.getSelectedTextWitnessId2(\r\n            state,\r\n            selectedText.id\r\n        );\r\n        if (selectedWitnessId) {\r\n            selectedWitness = reducers.getWitness2(state, selectedWitnessId);\r\n        }\r\n        if (_.isEmpty(selectedWitness) && !_.isEmpty(workingWitness));\r\n        {\r\n            selectedWitness = workingWitness;\r\n        }\r\n    }\r\n\r\n    annotatedText = TextStore2.getWitnessText(state, selectedWitness?.id);\r\n\r\n    const loading = state.data2.loadingWitnesses;\r\n\r\n    if (annotatedText) {\r\n        annotationPositions = getAnnotationPositions(\r\n            annotatedText,\r\n            (Object.values(annotations): any)\r\n        );\r\n    }\r\n    const isPanelLinked = reducers.isPanelLinked(state);\r\n    const scrollToId = reducers.getScrollToId(state);\r\n    const syncIdOnClick = reducers.getSyncIdOnClick(state);\r\n    const textAlignment = reducers.getTextAlignment(state);\r\n    const selectedWindow = reducers.getSelectedWindow(state);\r\n    const searchValue = reducers.getSearchValue2(state);\r\n    return {\r\n        text: selectedText,\r\n        textFontSize,\r\n        annotatedText,\r\n        selectedWitness,\r\n        loading,\r\n        annotationPositions,\r\n        isSecondWindowOpen: isSecondWindowOpen(state),\r\n        imageData: getImageData(state),\r\n        isPanelLinked,\r\n        selectedImage: getSelectedImage(state),\r\n        isImagePortrait: isImagePortrait(state),\r\n        isPanelVisible: isPanelVisible(state),\r\n        scrollToId,\r\n        syncIdOnClick,\r\n        textAlignment,\r\n        textAlignmentById: reducers.getTextAlignmentById(state),\r\n        selectedWindow,\r\n        selectedSourceRange: getSelectedSourceRange(state),\r\n        selectedTargetRange: getSelectedTargetRange(state),\r\n        showTableContent: reducers.getShowTableContent2(state),\r\n        searchResults: getSearchResults2(state, searchValue),\r\n        searchValue,\r\n        syncIdOnSearch: reducers.getSyncIdOnSearch2(state),\r\n    };\r\n};\r\n\r\nconst mergeProps = (stateProps, dispatchProps, ownProps) => {\r\n    const { annotatedText, annotationPositions } = stateProps;\r\n    const { dispatch } = dispatchProps;\r\n\r\n    const isDeletion = (id) => {\r\n        return id.indexOf(\"ds2_\") !== -1;\r\n    };\r\n    const isInsertion = (id) => {\r\n        return id.indexOf(\"i2_\") !== -1;\r\n    };\r\n    const isPageBreak = (id) => {\r\n        return id.indexOf(\"p2_\") !== -1;\r\n    };\r\n\r\n    const isLineBreak = (id) => {\r\n        return id.indexOf(\"l2_\") !== -1;\r\n    };\r\n\r\n    const idFromSegmentId = (id) => {\r\n        let start = 0;\r\n        if (isInsertion(id)) {\r\n            start = id.substr(2);\r\n        } else if (isDeletion(id)) {\r\n            start = id.substr(3);\r\n        } else {\r\n            start = id.substr(2);\r\n        }\r\n\r\n        return start;\r\n    };\r\n\r\n    const didSelectSegmentPosition = (segmentPosition, start, length) => {\r\n        let segmentAnnotations = annotationPositions[segmentPosition];\r\n        let segmentVariants = [];\r\n        let segmentPageBreaks = [];\r\n        let segmentLineBreaks = [];\r\n        if (segmentAnnotations) {\r\n            segmentVariants = segmentAnnotations.filter(\r\n                (annotation: Annotation) =>\r\n                    annotation.type === ANNOTATION_TYPES.variant\r\n            );\r\n            segmentPageBreaks = segmentAnnotations.filter(\r\n                (annotation: Annotation) =>\r\n                    annotation.type === ANNOTATION_TYPES.pageBreak\r\n            );\r\n            segmentLineBreaks = segmentAnnotations.filter(\r\n                (annotation: Annotation) =>\r\n                    annotation.type === ANNOTATION_TYPES.lineBreak\r\n            );\r\n        }\r\n        let activeAnnotations = _.intersectionWith(\r\n            segmentVariants.concat(segmentPageBreaks, segmentLineBreaks),\r\n            annotatedText.annotations,\r\n            (a, b) => a.toString() == b.toString()\r\n        );\r\n        let activeAnnotation = null;\r\n        if (activeAnnotations.length > 0) {\r\n            // get any active annotations\r\n            activeAnnotation = activeAnnotations[0];\r\n        } else if (segmentVariants && segmentVariants.length > 0) {\r\n            // get base text annotation for longest annotation highlighted in text\r\n            let longestAvailable = getLongestAnnotation(segmentVariants);\r\n            let [start, textLength] =\r\n                annotatedText.getPositionOfAnnotation(longestAvailable);\r\n            if (longestAvailable && longestAvailable.isInsertion) {\r\n                textLength = 0;\r\n            }\r\n            activeAnnotation = annotatedText.getBaseAnnotation(\r\n                start,\r\n                textLength\r\n            );\r\n        } else {\r\n            // get base annotation of just the segment\r\n            activeAnnotation = annotatedText.getBaseAnnotation(start, length);\r\n        }\r\n\r\n        // dispatch(actions.changedActiveTextAnnotation(activeAnnotation));\r\n    };\r\n\r\n    return {\r\n        ...ownProps,\r\n        ...stateProps,\r\n        onChangedFontSize: (fontSize: number) => {\r\n            dispatch(actions.changedTextFontSize(fontSize));\r\n        },\r\n\r\n        didSelectSegmentIds: (segmentIds) => {\r\n            if (segmentIds.length === 0) {\r\n                return;\r\n            }\r\n            let segmentAnnotations = [];\r\n            let segments = [];\r\n            for (let segmentId of segmentIds) {\r\n                if (isDeletion(segmentId) || isInsertion(segmentId)) {\r\n                    continue;\r\n                }\r\n\r\n                let segmentPosition = idFromSegmentId(segmentId);\r\n                let textSegment =\r\n                    annotatedText.segmentedText.segmentAtPosition(\r\n                        segmentPosition\r\n                    );\r\n                segments.push(textSegment);\r\n                const annotations = annotationPositions[textSegment.start];\r\n                if (annotations) {\r\n                    segmentAnnotations = segmentAnnotations.concat(annotations);\r\n                }\r\n            }\r\n            segmentAnnotations = _.uniqWith(\r\n                segmentAnnotations,\r\n                (a, b) => a.toString() == b.toString()\r\n            );\r\n\r\n            let activeAnnotations = _.intersectionWith(\r\n                segmentAnnotations,\r\n                annotatedText.annotations,\r\n                (a, b) => a.toString() == b.toString()\r\n            );\r\n\r\n            const range = getSegmentsRange(\r\n                segments,\r\n                activeAnnotations,\r\n                segmentAnnotations,\r\n                stateProps.annotatedText\r\n            );\r\n            if (!range) {\r\n                console.warn(\r\n                    \"No range for selected segment ids: %o\",\r\n                    segmentIds\r\n                );\r\n                return;\r\n            }\r\n            const baseAnnotation = annotatedText.getBaseAnnotation(\r\n                range.start,\r\n                range.length\r\n            );\r\n            let activeAnnotation = null;\r\n            if (range.annotation) {\r\n                activeAnnotation = range.annotation;\r\n            } else if (activeAnnotations.length > 0) {\r\n                const content = annotatedText.segmentedText\r\n                    .segmentsInRange(range.start, range.length)\r\n                    .reduce((content, segment) => content + segment.text, \"\");\r\n                // TODO: test this when editing non-working edition.\r\n                // Check if getTextWorkingWitness works as required\r\n                if (!stateProps.selectedWitness) {\r\n                    console.log(\r\n                        \"no stateProps.selectedWitness: %o\",\r\n                        stateProps.selectedWitness\r\n                    );\r\n                }\r\n                activeAnnotation = new Annotation(\r\n                    WORKING_VERSION_ANNOTATION_ID,\r\n                    getTextWorkingWitness(stateProps.text),\r\n                    baseAnnotation.start,\r\n                    baseAnnotation.length,\r\n                    content,\r\n                    ANNOTATION_TYPES.variant,\r\n                    stateProps.selectedWitness,\r\n                    stateProps.user\r\n                );\r\n            } else {\r\n                activeAnnotation = baseAnnotation;\r\n            }\r\n            // dispatch(changedActiveTextAnnotation(activeAnnotation));\r\n        },\r\n        changeScrollToId: (payload) =>\r\n            dispatch(actions.changeScrollToId(payload)),\r\n        changeSyncIdOnClick: (payload) => {\r\n            dispatch(actions.changeSyncIdOnClick(payload));\r\n        },\r\n        changeSelectedWindow: (payload) => {\r\n            dispatch(actions.changeSelectedWindow(payload));\r\n        },\r\n        changeSelectedRange: (payload) => {\r\n            dispatch(actions.changeSelectedRange(payload));\r\n        },\r\n        changeShowTableContent: (payload) => {\r\n            dispatch(actions.showTableContent2(payload));\r\n        },\r\n        selectedSegmentId: (segmentId) => {\r\n            let start = idFromSegmentId(segmentId);\r\n            let positionKey = start;\r\n            if (isInsertion(segmentId)) {\r\n                positionKey = INSERTION_KEY + start;\r\n            } else if (isDeletion(segmentId)) {\r\n                positionKey = DELETION_KEY + start;\r\n            } else if (isPageBreak(segmentId)) {\r\n                positionKey = PAGE_BREAK_KEY + start;\r\n            } else if (isLineBreak(segmentId)) {\r\n                positionKey = LINE_BREAK_KEY + start;\r\n            }\r\n\r\n            let segmentAnnotations = annotationPositions[positionKey];\r\n            if (DISMISS_CONTROLS_ON_CLICK && stateProps.activeAnnotation) {\r\n                const activeAnnotation = stateProps.activeAnnotation;\r\n                if (activeAnnotation) {\r\n                    const dismissTextAnnotation =\r\n                        actions.changedActiveTextAnnotation(null);\r\n                    dispatch(dismissTextAnnotation);\r\n                }\r\n            }\r\n            //  else {\r\n            //     if (\r\n            //         isInsertion(segmentId) ||\r\n            //         isDeletion(segmentId) ||\r\n            //         isPageBreak(segmentId) ||\r\n            //         isLineBreak(segmentId)\r\n            //     ) {\r\n            //         const length = 0;\r\n            //         didSelectSegmentPosition(positionKey, start, length);\r\n            //     } else {\r\n            //         let segmentPosition = Number(idFromSegmentId(segmentId));\r\n            //         let textSegment = annotatedText.segmentedText.segmentAtPosition(\r\n            //             segmentPosition\r\n            //         );\r\n            //         if (textSegment) {\r\n            //             didSelectSegmentPosition(\r\n            //                 textSegment.start,\r\n            //                 textSegment.start,\r\n            //                 textSegment.length\r\n            //             );\r\n            //         }\r\n            //     }\r\n            // }\r\n        },\r\n    };\r\n};\r\n\r\nconst TextDetailContainer = connect(\r\n    mapStateToProps,\r\n    null,\r\n    mergeProps\r\n)(TextDetail);\r\n\r\nexport default React.memo(TextDetailContainer);\r\n","// @flow\r\nimport * as reducers from \"reducers\";\r\nimport type { AppState } from \"reducers\";\r\nimport AnnotatedText from \"lib/AnnotatedText\";\r\nimport Witness from \"lib/Witness\";\r\nimport Annotation, { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport type { AnnotationData, TextData } from \"api\";\r\nimport segmentTibetanText from \"lib/segmentTibetanText\";\r\nimport SegmentedText from \"lib/SegmentedText\";\r\nimport _ from \"lodash\";\r\n\r\nlet store: { [witnessId: number]: AnnotatedText } = {};\r\n\r\nexport const getWitnessText = (\r\n    state: AppState,\r\n    witnessId: number\r\n): AnnotatedText | null => {\r\n    let text: AnnotatedText | null = null;\r\n\r\n    if (witnessId) {\r\n        text = generateAnnotatedText(state, witnessId);\r\n        if (text) {\r\n            store[witnessId] = text;\r\n        }\r\n    }\r\n\r\n    return text;\r\n};\r\n\r\nexport const addTextAnnotation = (\r\n    state: AppState,\r\n    witnessId: number,\r\n    annotation: Annotation\r\n) => {\r\n    const text = getWitnessText(state, witnessId);\r\n    if (text) {\r\n        text.addAnnotation(annotation);\r\n    }\r\n    // If witnessId is present, assume that getWitnessAnnotations\r\n    // has already been called.\r\n    if (annotationStore.hasOwnProperty(witnessId)) {\r\n        if (\r\n            !annotationStore[witnessId].appliedAnnotations.hasOwnProperty(\r\n                annotation.uniqueId\r\n            )\r\n        ) {\r\n            annotationStore[witnessId].appliedAnnotations[annotation.uniqueId] =\r\n                annotation;\r\n        }\r\n        if (\r\n            !annotationStore[witnessId].allAnnotations.hasOwnProperty(\r\n                annotation.uniqueId\r\n            )\r\n        ) {\r\n            annotationStore[witnessId].allAnnotations[annotation.uniqueId] =\r\n                annotation;\r\n        }\r\n    }\r\n};\r\n\r\nexport const removeTextAnnotation = (\r\n    state: AppState,\r\n    witnessId: number,\r\n    annotationId: AnnotationUniqueId\r\n) => {\r\n    const text = getWitnessText(state, witnessId);\r\n    if (text) {\r\n        text.removeAnnotation(annotationId);\r\n    }\r\n    if (annotationStore.hasOwnProperty(witnessId)) {\r\n        if (\r\n            annotationStore[witnessId].appliedAnnotations.hasOwnProperty(\r\n                annotationId\r\n            )\r\n        ) {\r\n            delete annotationStore[witnessId].appliedAnnotations[annotationId];\r\n        }\r\n    }\r\n};\r\n\r\nexport const deleteTextAnnotation = (\r\n    state: AppState,\r\n    witnessId: number,\r\n    annotationId: AnnotationUniqueId\r\n) => {\r\n    const text = getWitnessText(state, witnessId);\r\n    if (text) {\r\n        text.removeAnnotation(annotationId);\r\n    }\r\n    if (annotationStore.hasOwnProperty(witnessId)) {\r\n        if (\r\n            annotationStore[witnessId].allAnnotations.hasOwnProperty(\r\n                annotationId\r\n            )\r\n        ) {\r\n            delete annotationStore[witnessId].allAnnotations[annotationId];\r\n        }\r\n        if (\r\n            annotationStore[witnessId].appliedAnnotations.hasOwnProperty(\r\n                annotationId\r\n            )\r\n        ) {\r\n            delete annotationStore[witnessId].appliedAnnotations[annotationId];\r\n        }\r\n    }\r\n};\r\n\r\nlet annotationStore: {\r\n    [witnessId: number]: {\r\n        appliedAnnotations: { [AnnotationUniqueId]: Annotation },\r\n        allAnnotations: { [AnnotationUniqueId]: Annotation },\r\n    },\r\n} = {};\r\n\r\nexport const getWitnessAnnotations = (\r\n    state: AppState,\r\n    witness: Witness,\r\n    workingWitness: Witness\r\n): [\r\n    { [AnnotationUniqueId]: Annotation },\r\n    { [AnnotationUniqueId]: Annotation }\r\n] => {\r\n    if (annotationStore.hasOwnProperty(witness.id)) {\r\n        return [\r\n            annotationStore[witness.id].appliedAnnotations,\r\n            annotationStore[witness.id].allAnnotations,\r\n        ];\r\n    }\r\n\r\n    const text = witness.text;\r\n\r\n    let workingAnnotationList = reducers.getAnnotationsForWitnessId(\r\n        state,\r\n        workingWitness.id\r\n    );\r\n\r\n    let appliedAnnotations = getActiveAnnotations(\r\n        state,\r\n        witness.id,\r\n        workingWitness.id\r\n    );\r\n\r\n    let removedDefaultAnnotations = null;\r\n    // Default annotations removed by the user.\r\n    // Usually these are available when viewing\r\n    // a non-working edition.\r\n    let nonActiveAnnotations = {};\r\n\r\n    if (witness.id !== workingWitness.id) {\r\n        // If we are not viewing the working version,\r\n        // get all the annotations created by the selected witness\r\n        // BUT NOT BY A USER to apply to the base text.\r\n        // User-created annotations need to be in appliedAnnotations.\r\n\r\n        removedDefaultAnnotations =\r\n            reducers.getRemovedDefaultAnnotationsForWitnessId(\r\n                state,\r\n                witness.id\r\n            );\r\n\r\n        let selectedWitnessAnnotations = {};\r\n\r\n        for (let key in workingAnnotationList) {\r\n            if (workingAnnotationList.hasOwnProperty(key)) {\r\n                let annotationData = workingAnnotationList[key];\r\n                if (\r\n                    annotationData.creator_witness === witness.id &&\r\n                    !removedDefaultAnnotations.hasOwnProperty(\r\n                        annotationData.unique_id\r\n                    )\r\n                ) {\r\n                    selectedWitnessAnnotations[annotationData.unique_id] =\r\n                        annotationData;\r\n                } else if (annotationData.creator_witness === witness.id) {\r\n                    nonActiveAnnotations[annotationData.unique_id] =\r\n                        annotationData;\r\n                }\r\n            }\r\n        }\r\n\r\n        let selectedWitnessAnnotationsList = annotationsMapFromData(\r\n            state,\r\n            selectedWitnessAnnotations\r\n        );\r\n\r\n        appliedAnnotations = {\r\n            ...selectedWitnessAnnotationsList,\r\n            ...appliedAnnotations,\r\n        };\r\n\r\n        workingAnnotationList = selectedWitnessAnnotations;\r\n    }\r\n\r\n    let annotations = annotationsMapFromData(state, workingAnnotationList);\r\n    nonActiveAnnotations = annotationsMapFromData(state, nonActiveAnnotations);\r\n    if (Object.keys(nonActiveAnnotations).length > 0) {\r\n        annotations = {\r\n            ...annotations,\r\n            ...nonActiveAnnotations,\r\n        };\r\n    }\r\n\r\n    annotations = {\r\n        ...appliedAnnotations,\r\n        ...annotations,\r\n    };\r\n\r\n    annotations = _.pickBy(\r\n        annotations,\r\n        (annotation: Annotation, key: AnnotationUniqueId) => {\r\n            return !(\r\n                witness &&\r\n                annotation.type === ANNOTATION_TYPES.lineBreak &&\r\n                annotation.creatorWitness.id !== witness.id\r\n            );\r\n        }\r\n    );\r\n\r\n    // Only cache if annotations have been loaded\r\n    if (\r\n        reducers.hasLoadedWitnessAnnotations2(state, witness.id) &&\r\n        reducers.hasLoadedWitnessAppliedAnnotations(state, witness.id)\r\n    ) {\r\n        annotationStore[witness.id] = {\r\n            appliedAnnotations: appliedAnnotations,\r\n            allAnnotations: annotations,\r\n        };\r\n    }\r\n\r\n    return [appliedAnnotations, annotations];\r\n};\r\n\r\nconst generateAnnotatedText = (\r\n    state: AppState,\r\n    witnessId: number\r\n): AnnotatedText | null => {\r\n    const witness = reducers.getWitness2(state, witnessId);\r\n    if (!witness) {\r\n        console.warn(\"no witness\");\r\n        return null;\r\n    }\r\n    const text = witness.text;\r\n    const workingWitness = reducers.getWorkingWitness2(state, text.id);\r\n    const baseWitness = reducers.getBaseWitness2(state, text.id);\r\n\r\n    if (!workingWitness || !baseWitness) {\r\n        return null;\r\n    }\r\n\r\n    let [appliedAnnotations, availableAnnotations] = getWitnessAnnotations(\r\n        state,\r\n        witness,\r\n        workingWitness\r\n    );\r\n    let segmentedWorkingWitness = getSegmentedWitness(workingWitness);\r\n    let annotatedText = new AnnotatedText(\r\n        segmentedWorkingWitness,\r\n        (Object.values(appliedAnnotations): any),\r\n        (text) => segmentTibetanText(text).segments,\r\n        workingWitness,\r\n        witness\r\n    );\r\n\r\n    return annotatedText;\r\n};\r\n\r\nconst getActiveAnnotations = (\r\n    state: AppState,\r\n    witnessId,\r\n    baseWitnessId\r\n): { [AnnotationUniqueId]: Annotation } => {\r\n    const loadedAppliedAnnotations =\r\n        reducers.hasLoadedWitnessAppliedAnnotations(state, witnessId);\r\n    if (!loadedAppliedAnnotations) {\r\n        return {};\r\n    }\r\n    const activeAnnotationList = reducers.getActiveAnnotationsForWitnessId(\r\n        state,\r\n        witnessId\r\n    );\r\n    if (!activeAnnotationList) {\r\n        return {};\r\n    }\r\n\r\n    let activeAnnotationDataList = {};\r\n    for (let activeAnnotationId in activeAnnotationList) {\r\n        if (activeAnnotationList.hasOwnProperty(activeAnnotationId)) {\r\n            let activeAnnotationData = reducers.getAnnotationData(\r\n                state,\r\n                baseWitnessId,\r\n                activeAnnotationId\r\n            );\r\n            if (activeAnnotationData) {\r\n                activeAnnotationDataList[activeAnnotationData.unique_id] =\r\n                    activeAnnotationData;\r\n            }\r\n        }\r\n    }\r\n\r\n    return annotationsMapFromData(state, activeAnnotationDataList);\r\n};\r\n\r\nconst annotationsMapFromData = (\r\n    state: AppState,\r\n    annotationList: { [AnnotationUniqueId]: AnnotationData }\r\n): { [AnnotationUniqueId]: Annotation } => {\r\n    let annotations = {};\r\n    for (let key in annotationList) {\r\n        if (annotationList.hasOwnProperty(key)) {\r\n            let annotationData = annotationList[key];\r\n            let annotation = reducers.annotationFromData(state, annotationData);\r\n            if (annotation) {\r\n                annotations[key] = annotation;\r\n            }\r\n        }\r\n    }\r\n    return annotations;\r\n};\r\n\r\n// TODO: clear cache when changing texts\r\nlet _segmentedWitnesses: { [number]: SegmentedText } = {};\r\nfunction getSegmentedWitness(witness: Witness): SegmentedText {\r\n    if (!_segmentedWitnesses[witness.id]) {\r\n        _segmentedWitnesses[witness.id] = segmentTibetanText(\r\n            witness.content || \"\"\r\n        );\r\n    }\r\n\r\n    return _segmentedWitnesses[witness.id];\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAjEA;AACA;AAWA;AAAA;AACA;AADA;AAsDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvBA;AAyBA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AANA;AAAA;AACA;AADA;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AArBA;AAAA;AAAA;AAAA;AAAA;AACA;AAqBA;AAEA;AAAA;AACA;AAEA;AAGA;AAAA;AACA;AAEA;AACA;AAKA;AACA;AAIA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AAIA;AACA;AAAA;AAUA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAlJA;AAoJA;AACA;AACA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9aA;AAEA;AACA;AACA;AAGA;AACA;AAGA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AAKA;AAEA;AACA;AAAA;AAKA;AAEA;AACA;AACA;AAEA;AAKA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAEA;AAOA;AAQA;AACA;AAIA;AACA;AACA;AAEA;AAKA;AAMA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AAMA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AAKA;AAGA;AAKA;AACA;AAGA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AAGA;AAAA;AAKA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;A","sourceRoot":""}