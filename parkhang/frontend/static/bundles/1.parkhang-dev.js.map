{"version":3,"file":"1.parkhang-dev.js","sources":["webpack://parkhang/./app/components/Editors/Editor.js","webpack://parkhang/./app/components/Editors/EditorContainer.css","webpack://parkhang/./app/components/Editors/EditorContainer.js","webpack://parkhang/./app/components/Editors/TextSheet.js","webpack://parkhang/./app/components/Editors/index.js","webpack://parkhang/./app/components/Editors/resizerStyle.css","webpack://parkhang/./app/components/ErrorBoundary/ErrorBoundary.js","webpack://parkhang/./app/components/MediaComponent/Audio.js","webpack://parkhang/./app/components/MediaComponent/DraggableMedia.js","webpack://parkhang/./app/components/MediaComponent/Image.css","webpack://parkhang/./app/components/MediaComponent/Image.js","webpack://parkhang/./app/components/MediaComponent/MediaContainer.js","webpack://parkhang/./app/components/MediaComponent/MediaOptions.css","webpack://parkhang/./app/components/MediaComponent/MediaOptions.js","webpack://parkhang/./app/components/MediaComponent/Video.js","webpack://parkhang/./app/components/MediaComponent/index.js","webpack://parkhang/./app/components/TextDetail/AddButton.css","webpack://parkhang/./app/components/TextDetail/AddButton.js","webpack://parkhang/./app/components/TextDetail/AnnotationControls.css","webpack://parkhang/./app/components/TextDetail/AnnotationControls.js","webpack://parkhang/./app/components/TextDetail/AnnotationControlsContainer.js","webpack://parkhang/./app/components/TextDetail/AnnotationControlsHeader.css","webpack://parkhang/./app/components/TextDetail/AnnotationControlsHeader.js","webpack://parkhang/./app/components/TextDetail/AnnotationControlsHeading.css","webpack://parkhang/./app/components/TextDetail/AnnotationControlsHeading.js","webpack://parkhang/./app/components/TextDetail/AnnotationDetail.css","webpack://parkhang/./app/components/TextDetail/AnnotationDetail.js","webpack://parkhang/./app/components/TextDetail/AnnotationDetailEdit.js","webpack://parkhang/./app/components/TextDetail/AnswerView.css","webpack://parkhang/./app/components/TextDetail/AnswerView.js","webpack://parkhang/./app/components/TextDetail/Button.css","webpack://parkhang/./app/components/TextDetail/HeaderMenu/HighlightedString.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/Refresh.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/Search.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/SearchList.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/SearchStyle.css","webpack://parkhang/./app/components/TextDetail/HeaderMenu/Settings.js","webpack://parkhang/./app/components/TextDetail/HeaderMenu/TableOfContent.js","webpack://parkhang/./app/components/TextDetail/Note.css","webpack://parkhang/./app/components/TextDetail/Note.js","webpack://parkhang/./app/components/TextDetail/NoteEditor.css","webpack://parkhang/./app/components/TextDetail/NoteEditor.js","webpack://parkhang/./app/components/TextDetail/QuestionEditor.css","webpack://parkhang/./app/components/TextDetail/QuestionEditor.js","webpack://parkhang/./app/components/TextDetail/QuestionView.css","webpack://parkhang/./app/components/TextDetail/QuestionView.js","webpack://parkhang/./app/components/TextDetail/QuestionsLoading.css","webpack://parkhang/./app/components/TextDetail/QuestionsLoading.js","webpack://parkhang/./app/components/TextDetail/SelectVersion.css","webpack://parkhang/./app/components/TextDetail/SelectVersion.js","webpack://parkhang/./app/components/TextDetail/SplitText.css","webpack://parkhang/./app/components/TextDetail/SplitText.js","webpack://parkhang/./app/components/TextDetail/TableOfContent/TableOfContent.css","webpack://parkhang/./app/components/TextDetail/TableOfContent/TableOfContent.js","webpack://parkhang/./app/components/TextDetail/Text.css","webpack://parkhang/./app/components/TextDetail/Text.js","webpack://parkhang/./app/components/TextDetail/TextDetail.css","webpack://parkhang/./app/components/TextDetail/TextDetail.js","webpack://parkhang/./app/components/TextDetail/TextDetailContainer.js","webpack://parkhang/./app/components/TextDetail/TextDetailHeading.js","webpack://parkhang/./app/components/TextDetail/TextDetailHeadingContainer.js","webpack://parkhang/./app/components/TextDetail/TextList.css","webpack://parkhang/./app/components/TextDetail/TextList.js","webpack://parkhang/./app/components/TextDetail/TextListContainer.js","webpack://parkhang/./app/components/TextDetail/index.js","webpack://parkhang/./app/components/TextDetail/textDetailHeading.css","webpack://parkhang/./app/components/TextDetail2/HeaderMenu/HighlightedString.js","webpack://parkhang/./app/components/TextDetail2/HeaderMenu/Refresh.js","webpack://parkhang/./app/components/TextDetail2/HeaderMenu/Search.js","webpack://parkhang/./app/components/TextDetail2/HeaderMenu/SearchList.js","webpack://parkhang/./app/components/TextDetail2/HeaderMenu/SearchStyle.css","webpack://parkhang/./app/components/TextDetail2/HeaderMenu/Settings.js","webpack://parkhang/./app/components/TextDetail2/HeaderMenu/TableOfContent.js","webpack://parkhang/./app/components/TextDetail2/SelectVersion.css","webpack://parkhang/./app/components/TextDetail2/SelectVersion.js","webpack://parkhang/./app/components/TextDetail2/SplitText.css","webpack://parkhang/./app/components/TextDetail2/SplitText.js","webpack://parkhang/./app/components/TextDetail2/TableOfContent/TableOfContent.js","webpack://parkhang/./app/components/TextDetail2/Text2.css","webpack://parkhang/./app/components/TextDetail2/Text2.js","webpack://parkhang/./app/components/TextDetail2/TextDetail.css","webpack://parkhang/./app/components/TextDetail2/TextDetail.js","webpack://parkhang/./app/components/TextDetail2/TextDetailContainer.js","webpack://parkhang/./app/components/TextDetail2/TextDetailHeading.js","webpack://parkhang/./app/components/TextDetail2/TextDetailHeadingContainer.js","webpack://parkhang/./app/components/TextDetail2/TextList.css","webpack://parkhang/./app/components/TextDetail2/TextList.js","webpack://parkhang/./app/components/TextDetail2/TextListContainer.js","webpack://parkhang/./app/components/TextDetail2/textDetailHeading.css","webpack://parkhang/./app/components/TextList/HighlightedString.js","webpack://parkhang/./app/components/TextList/LoadMore.css","webpack://parkhang/./app/components/TextList/LoadMore.js","webpack://parkhang/./app/components/TextList/ResultCount.js","webpack://parkhang/./app/components/TextList/TextList.css","webpack://parkhang/./app/components/TextList/TextList.js","webpack://parkhang/./app/components/TextList/TextListTab.css","webpack://parkhang/./app/components/TextList/TextListTab.js","webpack://parkhang/./app/components/TextList/TextListTabContainer.js","webpack://parkhang/./app/components/TextList/index.js","webpack://parkhang/./app/components/TextsSearch/TextsSearch.css","webpack://parkhang/./app/components/TextsSearch/TextsSearch.js","webpack://parkhang/./app/components/TextsSearch/TextsSearchContainer.js","webpack://parkhang/./app/components/UI/Accessory.css","webpack://parkhang/./app/components/UI/Accessory.js","webpack://parkhang/./app/components/UI/ApplyTooltip.js","webpack://parkhang/./app/components/UI/Button.css","webpack://parkhang/./app/components/UI/Button.js","webpack://parkhang/./app/components/UI/Slider.css","webpack://parkhang/./app/components/UI/Slider.js","webpack://parkhang/./app/containers/TextListContainer.js","webpack://parkhang/./app/css/colour.css","webpack://parkhang/./app/images/PencilAltIcon.svg","webpack://parkhang/./app/images/check_circle.svg","webpack://parkhang/./app/images/lopenling_logo.png","webpack://parkhang/./app/images/note.svg","webpack://parkhang/./app/images/options.svg","webpack://parkhang/./app/images/page_break_icon.svg","webpack://parkhang/./app/images/question_answer.svg","webpack://parkhang/./app/images/search.svg","webpack://parkhang/./app/images/wrench.svg","webpack://parkhang/./app/lib/SplitText.js","webpack://parkhang/./app/lib/shallowEqual.js","webpack://parkhang/./app/lib/text_splitters/positionSplitter.js","webpack://parkhang/./app/state_helpers/TextStore2.js"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\r\nimport TextsSearchContainer from \"components/TextsSearch/TextsSearchContainer\";\r\nimport TextListContainer from \"containers/TextListContainer\";\r\nimport TextListTabContainer from \"components/TextList/TextListTabContainer\";\r\nimport * as constants from \"app_constants\";\r\nimport lopenlingLogo from \"images/lopenling_logo.png\";\r\nimport headerStyles from \"components/Header/Header.css\";\r\nimport Sidebar from \"components/Sidebar\";\r\nimport SplitPane, { Pane } from \"react-split-pane\";\r\nimport styles from \"./EditorContainer.css\";\r\nimport classnames from \"classnames\";\r\nimport utilStyles from \"css/util.css\";\r\nimport TextSheet from \"./TextSheet\";\r\nimport {\r\n  SpeedDial,\r\n  SpeedDialAction,\r\n  SpeedDialIcon,\r\n  Snackbar,\r\n  Alert,\r\n  Collapse,\r\n} from \"@mui/material\";\r\n\r\nimport { Edit, Share, VerticalSplit, SyncAlt } from \"@mui/icons-material\";\r\nimport { Box } from \"@mui/system\";\r\nconst Editor = (props) => {\r\n  let textListClassnames = [styles.listContainer];\r\n  let bodyHeight;\r\n  let minSize = constants.MIN_TEXT_LIST_WIDTH;\r\n  let maxSize = constants.MAX_TEXT_LIST_WIDTH;\r\n\r\n  const [open, setOpen] = useState(false);\r\n\r\n  let defaultSize = constants.DEFAULT_TEXT_LIST_WIDTH;\r\n  let size = props.textListWidth;\r\n  if (props.textListIsVisible) {\r\n    textListClassnames.push(styles.showListContainer);\r\n  } else {\r\n    size = 0;\r\n    textListClassnames.push(styles.hideListContainer);\r\n  }\r\n\r\n  bodyHeight = \"calc(100vh - \" + headerStyles.headerHeight + \")\";\r\n\r\n  const image_location = lopenlingLogo;\r\n  const handleClose = (event, reason) => {\r\n    if (reason === \"clickaway\") {\r\n      return;\r\n    }\r\n    setOpen(false);\r\n  };\r\n  const handleShare = () => {\r\n    let textid = props.selectedText;\r\n    let textid2 = props.selectedText2;\r\n    let witnessid = props.selectedWitness;\r\n    let witnessid2 = props.selectedWitness2;\r\n    let url = \"\";\r\n    if (textid2 && witnessid2) {\r\n      url =\r\n        window.location.origin +\r\n        `/texts/${textid.id}/witnesses/${witnessid?.id}/texts2/${textid2.id}/witnesses2/${witnessid2.id}`;\r\n    } else {\r\n      url =\r\n        window.location.origin +\r\n        `/texts/${textid.id}/witnesses/${witnessid?.id}`;\r\n    }\r\n    navigator.clipboard\r\n      .writeText(url)\r\n      .then()\r\n      .catch((e) => console.log(e.message))\r\n      .finally(() => setOpen(true));\r\n  };\r\n  const actions = [\r\n    {\r\n      icon: <Edit htmlColor={props.isAnnotating ? \"#ff7961\" : undefined} />,\r\n      name: \"Annotate\",\r\n      condition: props.isAnnotating,\r\n      function: () => props.changeIsAnnotating(!props.isAnnotating),\r\n    },\r\n    {\r\n      icon: <SyncAlt htmlColor={props.isPanelLinked ? \"#ff7961\" : undefined} />,\r\n      name: \"Link Panel\",\r\n      condition: props.isPanelLinked,\r\n      function: () => props.onChangePanelLink(!props.isPanelLinked),\r\n    },\r\n    {\r\n      icon: <Share />,\r\n      name: \"Share\",\r\n      function: handleShare,\r\n    },\r\n    {\r\n      icon: (\r\n        <VerticalSplit\r\n          htmlColor={props.isSecondWindowOpen ? \"#ff7961\" : undefined}\r\n        />\r\n      ),\r\n      name: \"Split Window\",\r\n      condition: props.isSecondWindowOpen,\r\n      function: () => props.onChangeWindowOpen(!props.isSecondWindowOpen, 140),\r\n    },\r\n  ];\r\n  useEffect(() => {\r\n    let timer = setTimeout(() => {\r\n      window.dispatchEvent(new Event(\"resize\"));\r\n    }, 1000);\r\n    return () => clearTimeout(timer);\r\n  }, [props.textListIsVisible]);\r\n  return (\r\n    <div className={classnames(styles.interface, utilStyles.flex)}>\r\n      <SplitPane\r\n        size=\"fit-content\"\r\n        onDragFinished={(width: number) => {\r\n          if (width > 0) window.dispatchEvent(new Event(\"resize\"));\r\n        }}\r\n        resizerStyle={{ display: \"none\" }}\r\n        style={{ height: \"auto\", position: \"static\" }}\r\n      >\r\n        <Collapse\r\n          sx={{ height: \"100%\" }}\r\n          orientation=\"horizontal\"\r\n          in={props.textListIsVisible}\r\n          mountOnEnter\r\n          unmountOnExit\r\n        >\r\n          <Sidebar />\r\n        </Collapse>\r\n        <Box sx={{ height: \"100vh\", width: \"100%\" }}>\r\n          <TextSheet bodyHeight={bodyHeight} />\r\n        </Box>\r\n      </SplitPane>\r\n      <SpeedDial\r\n        ariaLabel=\"SpeedDial basic\"\r\n        sx={{ position: \"absolute\", bottom: 60, right: 16 }}\r\n        icon={<SpeedDialIcon />}\r\n      >\r\n        {actions.map((action) => (\r\n          <SpeedDialAction\r\n            key={action.name}\r\n            icon={action.icon}\r\n            tooltipTitle={action.name}\r\n            onClick={action.function}\r\n            open={action.condition}\r\n          />\r\n        ))}\r\n      </SpeedDial>\r\n      <Snackbar open={open} autoHideDuration={6000} onClose={handleClose}>\r\n        <Alert onClose={handleClose} severity=\"success\" sx={{ width: \"100%\" }}>\r\n          The Url Copied to Clipboard !\r\n        </Alert>\r\n      </Snackbar>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Editor;\r\n\r\n// return (\r\n//     <div className={classnames(styles.interface, utilStyles.flex)}>\r\n//         <SplitPane\r\n//             split=\"vertical\"\r\n//             minSize={minSize}\r\n//             maxSize={maxSize}\r\n//             defaultSize={defaultSize}\r\n//             size={size}\r\n//             paneStyle={{\r\n//                 display: \"flex\",\r\n//             }}\r\n//             style={{\r\n//                 height: bodyHeight,\r\n//             }}\r\n//             onDragFinished={(width: number) => {\r\n//                 if (width > 0) {\r\n//                     props.onChangedTextWidth(width);\r\n//                     if (!props.textListIsVisible) {\r\n//                         props.onChangedTextListVisible(true);\r\n//                     }\r\n//                 }\r\n//                 window.dispatchEvent(new Event(\"resize\"));\r\n//             }}\r\n//         >\r\n//             <div className={classnames(...textListClassnames)}>\r\n//                 <Resources />\r\n//             </div>\r\n\r\n//             <TextSheet bodyHeight={bodyHeight} />\r\n//         </SplitPane>\r\n//     </div>\r\n// );\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"EditorContainer---container\",\"interface\":\"EditorContainer---interface\",\"listContainer\":\"EditorContainer---listContainer\",\"showListContainer\":\"EditorContainer---showListContainer\",\"hideListContainer\":\"EditorContainer---hideListContainer\"};","import Editor from \"./Editor\";\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport * as reducers from \"reducers\";\r\nimport * as actions from \"actions\";\r\n\r\nconst mapStateToProps = (state) => {\r\n    const selectedText = reducers.getSelectedText(state);\r\n    const selectedText2 = reducers.getSelectedText2(state);\r\n\r\n    let selectedWitness;\r\n    let selectedWitness2;\r\n    let witnesses;\r\n    let witnesses2;\r\n    if (selectedText) {\r\n        witnesses = reducers.getTextWitnesses(state, selectedText.id);\r\n        const selectedWitnessId = reducers.getSelectedTextWitnessId(\r\n            state,\r\n            selectedText.id\r\n        );\r\n        if (selectedWitnessId) {\r\n            selectedWitness = reducers.getWitness(state, selectedWitnessId);\r\n        } else {\r\n            selectedWitness = reducers.getWorkingWitness(\r\n                state,\r\n                selectedText.id\r\n            );\r\n        }\r\n    }\r\n    if (selectedText2) {\r\n        witnesses2 = reducers.getTextWitnesses2(state, selectedText2.id);\r\n        const selectedWitnessId2 = reducers.getSelectedTextWitnessId2(\r\n            state,\r\n            selectedText2.id\r\n        );\r\n        if (selectedWitnessId2) {\r\n            selectedWitness2 = reducers.getWitness2(state, selectedWitnessId2);\r\n        } else {\r\n            selectedWitness2 = reducers.getWorkingWitness2(\r\n                state,\r\n                selectedText2.id\r\n            );\r\n        }\r\n    }\r\n\r\n    if (!state.user.userId === -1) {\r\n        user = state.user;\r\n    }\r\n    return {\r\n        selectedText,\r\n        selectedWitness,\r\n        selectedText2,\r\n        selectedWitness2,\r\n        title: reducers.getTranslation(state, \"header.title\"),\r\n        page: state.page,\r\n        isAnnotating: reducers.isAnnotating(state),\r\n        isSecondWindowOpen: reducers.isSecondWindowOpen(state),\r\n        theme: reducers.getTheme(state),\r\n        isPanelLinked: reducers.isPanelLinked(state),\r\n        textListIsVisible: reducers.getTextListVisible(state),\r\n    };\r\n};\r\n\r\nconst matchDispatchToProps = (dispatch) => {\r\n    return {\r\n        onChangedTextWidth: (width: number) => {\r\n            dispatch(actions.changedTextListWidth(width));\r\n        },\r\n        onChangedTextListVisible: (isVisible: boolean) => {\r\n            dispatch(actions.changedTextListVisible(isVisible));\r\n        },\r\n        changeIsAnnotating: (payload) => {\r\n            dispatch(actions.changeIsAnnotating(payload));\r\n            if (payload === false) {\r\n                const dismissTextAnnotation =\r\n                    actions.changedActiveTextAnnotation(null);\r\n                dispatch(dismissTextAnnotation);\r\n                dispatch(actions.changedActiveTextAnnotation(null));\r\n            }\r\n        },\r\n        onChangeWindowOpen: (data: boolean, textId) => {\r\n            dispatch(actions.toggleSecondWindow(data, textId));\r\n        },\r\n        onChangePanelLink: (data: boolean) => {\r\n            dispatch(actions.changePanelLink(data));\r\n        },\r\n    };\r\n};\r\n\r\nconst EditorContainer = connect(mapStateToProps, matchDispatchToProps)(Editor);\r\n\r\nexport default EditorContainer;\r\n","import React, { useEffect, useRef, useState } from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport * as reducers from \"reducers\";\r\nimport * as actions from \"actions\";\r\nimport MediaComponent from \"components/MediaComponent\";\r\nimport { batchActions } from \"redux-batched-actions\";\r\nimport { Box, Divider } from \"@mui/material\";\r\nimport Loader from \"react-loader\";\r\nimport ErrorBoundary from \"components/ErrorBoundary/ErrorBoundary\";\r\nimport SplitPane from \"react-split-pane\";\r\nimport styles from \"./resizerStyle.css\";\r\nimport classnames from \"classnames\";\r\nimport DraggableMedia from \"../MediaComponent/DraggableMedia\";\r\nimport TextDetailContainer2 from \"components/TextDetail2/TextDetailContainer\";\r\nimport TextDetailContainer from \"components/TextDetail/TextDetailContainer\";\r\n\r\nfunction TextSheet(props) {\r\n  let [landScape, setLandScape] = useState(true);\r\n  let editorRef = useRef(null);\r\n  const handleResize = (e) => {\r\n    let width = editorRef.current.clientWidth;\r\n    let height = editorRef.current.clientHeight;\r\n    if (width > height) {\r\n      setLandScape(true);\r\n    } else {\r\n      setLandScape(false);\r\n    }\r\n  };\r\n  useEffect(() => {\r\n    handleResize();\r\n    window.addEventListener(\"resize\", handleResize);\r\n    return () => window.removeEventListener(\"resize\", handleResize);\r\n  }, []);\r\n\r\n  return (\r\n    <div\r\n      ref={editorRef}\r\n      style={{\r\n        display: \"flex\",\r\n        flexDirection: \"column\",\r\n        width: \"100%\",\r\n        height: \"100%\",\r\n        overflow: \"hidden\",\r\n        position: \"relative\",\r\n      }}\r\n    >\r\n      {/* <SplitPane\r\n                defaultSize={props.Media.isPanelVisible ? \"35vh\" : 0}\r\n                size={props.Media.isPanelVisible ? \"35vh\" : 0}\r\n                split=\"horizontal\"\r\n                resizerClassName={classnames(styles.Resizer, styles.horizontal)}\r\n                resizerStyle={{\r\n                    display: !props.Media.isPanelVisible ? \"none\" : \"block\",\r\n                }}\r\n            >\r\n                {props.Media.isPanelVisible ? <MediaComponent /> : <div />} */}\r\n      <SplitPane\r\n        split={landScape ? \"vertical\" : \"horizontal\"}\r\n        size={props.isSecondWindowOpen ? \"50%\" : \"100%\"}\r\n        resizerClassName={classnames(\r\n          styles.Resizer,\r\n          { [styles.vertical]: landScape },\r\n          { [styles.horizontal]: !landScape }\r\n        )}\r\n        onDragFinished={(width: number) => {\r\n          if (width > 0) window.dispatchEvent(new Event(\"resize\"));\r\n        }}\r\n      >\r\n        <ErrorBoundary>\r\n          <TextDetailContainer />\r\n        </ErrorBoundary>\r\n        <ErrorBoundary>\r\n          {props.isSecondWindowOpen && <TextDetailContainer2 />}\r\n        </ErrorBoundary>\r\n      </SplitPane>\r\n      {props.Media.isPanelVisible && (\r\n        <ErrorBoundary>\r\n          <MediaComponent />\r\n        </ErrorBoundary>\r\n      )}\r\n      {/* </SplitPane> */}\r\n    </div>\r\n  );\r\n}\r\n\r\nconst mapStateToProps = (state: AppState): { user: User } => {\r\n  const isSecondWindowOpen = reducers.isSecondWindowOpen(state);\r\n  const Media = reducers.getMediaData(state);\r\n  return {\r\n    isSecondWindowOpen,\r\n    Media,\r\n  };\r\n};\r\n\r\nconst mergeProps = (stateProps, dispatchProps, ownProps) => {\r\n  const { dispatch } = dispatchProps;\r\n\r\n  return {\r\n    ...ownProps,\r\n    ...stateProps,\r\n  };\r\n};\r\nconst TextSheetContainer = connect(\r\n  mapStateToProps,\r\n  null,\r\n  mergeProps\r\n)(TextSheet);\r\n\r\nexport default TextSheetContainer;\r\n","export { default } from \"./EditorContainer\";\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Resizer\":\"resizerStyle---Resizer\",\"horizontal\":\"resizerStyle---horizontal\",\"vertical\":\"resizerStyle---vertical\",\"disabled\":\"resizerStyle---disabled\"};","import React from \"react\";\r\n\r\nclass ErrorBoundary extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = { hasError: false };\r\n    }\r\n\r\n    static getDerivedStateFromError(error) {\r\n        // Update state so the next render will show the fallback UI.\r\n        return { hasError: true };\r\n    }\r\n\r\n    componentDidCatch(error, errorInfo) {\r\n        // You can also log the error to an error reporting service\r\n        console.log(error, errorInfo);\r\n    }\r\n\r\n    render() {\r\n        if (this.state.hasError) {\r\n            // You can render any custom fallback UI\r\n            return <h1>Something went wrong.</h1>;\r\n        }\r\n\r\n        return this.props.children;\r\n    }\r\n}\r\n\r\nexport default ErrorBoundary;\r\n","import { Collapse } from \"@mui/material\";\r\nimport React from \"react\";\r\nimport Player from \"react-howler-player\";\r\nimport { useTheme } from \"@mui/material/styles\";\r\nfunction Audio(props) {\r\n    const theme = useTheme();\r\n    let url = \"https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3\";\r\n    let playerRef = React.useRef(null);\r\n    const handleSeek = (e) => {\r\n        console.log(e);\r\n    };\r\n    const onPlayerReady = (data) => {\r\n        console.log(data);\r\n    };\r\n\r\n    return (\r\n        <Collapse in={props.open}>\r\n            <Player\r\n                profile=\"top_progress\"\r\n                src={[url]}\r\n                isDark={theme.palette.mode === \"dark\" ? true : false}\r\n                onLoad={onPlayerReady}\r\n                speedPanel={\"bottom\"}\r\n                ref={playerRef}\r\n                onPlay={handleSeek}\r\n            />\r\n        </Collapse>\r\n    );\r\n}\r\n\r\nexport default Audio;\r\n","import React from \"react\";\r\nimport Draggable from \"react-draggable\";\r\nimport CloseIcon from \"@mui/icons-material/Close\";\r\nimport Paper, { PaperProps } from \"@mui/material/Paper\";\r\nimport { ResizableBox } from \"react-resizable\";\r\nimport Video from \"./Video\";\r\nimport Audio from \"./Audio\";\r\nimport Box from \"@mui/material/Box\";\r\nimport { IconButton } from \"@mui/material\";\r\nfunction PaperComponent(props: PaperProps) {\r\n    return (\r\n        <Draggable handle=\"#draggable-dialog-title\" bounds=\"parent\">\r\n            <Paper {...props} />\r\n        </Draggable>\r\n    );\r\n}\r\n\r\nfunction DraggableMedia(props) {\r\n    const [hide, setHide] = React.useState(true);\r\n\r\n    const handleClose = () => {\r\n        props.changeMediaSelection(null);\r\n    };\r\n    const toggleHide = () => {\r\n        setHide((prev) => !prev);\r\n    };\r\n    if (props.selectedMedia.isImageVisible) return null;\r\n\r\n    return (\r\n        <PaperComponent\r\n            sx={{ position: \"absolute\", zIndex: 1, right: 0 }}\r\n\r\n            // onClose={handleClose}\r\n        >\r\n            {/* <ResizableBox height={350} width={400}> */}\r\n            <div className=\"Resizable-media-div\">\r\n                <div\r\n                    style={{\r\n                        cursor: \"move\",\r\n                        paddingInline: 20,\r\n                        paddingTop: 10,\r\n                        display: \"flex\",\r\n                        justifyContent: \"space-between\",\r\n                        alignItems: \"center\",\r\n                    }}\r\n                    id=\"draggable-dialog-title\"\r\n                >\r\n                    <h3>{props.selectedMedia.isVideoVisible && \"VIDEO\"}</h3>\r\n                    <h3>{props.selectedMedia.isAudioVisible && \"AUDIO\"}</h3>\r\n                    <div className=\"buttons-hide-close\">\r\n                        <IconButton onClick={toggleHide} disableRipple>\r\n                            {hide ? \"-\" : \"+\"}\r\n                        </IconButton>\r\n                        <IconButton onClick={handleClose} disableRipple>\r\n                            <CloseIcon />\r\n                        </IconButton>\r\n                    </div>\r\n                </div>\r\n                <>\r\n                    {props.selectedMedia.isVideoVisible && (\r\n                        <Video {...props} open={hide} setOpen={setHide} />\r\n                    )}\r\n                    {props.selectedMedia.isAudioVisible && (\r\n                        <Audio open={hide} setOpen={setHide} />\r\n                    )}\r\n                </>\r\n            </div>\r\n            {/* </ResizableBox> */}\r\n        </PaperComponent>\r\n    );\r\n}\r\n\r\nexport default DraggableMedia;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"ThirdWindow-Height\":\"300px\",\"header-Height\":\"35px\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"ThirdWindowHeight\":\"250px\",\"ThirdWindow\":\"Image---ThirdWindow\",\"ThirdWindowPortrait\":\"Image---ThirdWindowPortrait\",\"header\":\"Image---header\",\"listOfImages\":\"Image---listOfImages\",\"ImageStyle\":\"Image---ImageStyle\",\"imageSection\":\"Image---imageSection\"};","import React, { useState, useRef, useEffect, memo, useCallback } from \"react\";\r\nimport styles from \"./Image.css\";\r\nimport { TransformWrapper, TransformComponent } from \"react-zoom-pan-pinch\";\r\nimport _ from \"lodash\";\r\nimport { LazyLoadImage } from \"react-lazy-load-image-component\";\r\nimport {\r\n    IconButton,\r\n    NativeSelect,\r\n    MenuItem,\r\n    FormControl,\r\n    Box,\r\n    InputLabel,\r\n    AppBar,\r\n} from \"@mui/material\";\r\nimport classnames from \"classnames\";\r\nimport ChevronRightIcon from \"@mui/icons-material/ChevronRight\";\r\nimport ChevronLeftIcon from \"@mui/icons-material/ChevronLeft\";\r\nimport CircularProgress from \"@mui/material/CircularProgress\";\r\nimport CancelIcon from \"@mui/icons-material/Cancel\";\r\nfunction HttpUrl(data = \"\") {\r\n    if (data.includes(\"https\")) return data;\r\n    return \"https://\" + data;\r\n}\r\nasync function fetchImage(url) {\r\n    const res = await fetch(url);\r\n    const imageBlob = await res.blob();\r\n    const imageObjectURL = URL.createObjectURL(imageBlob);\r\n    return imageObjectURL;\r\n}\r\n\r\nfunction Image(props) {\r\n    const selectRef = useRef(null);\r\n    let imageList = props.imageData?.alignment;\r\n    let message = props.imageData?.message;\r\n    let imageRef = React.useRef(\"\");\r\n    let textIdfromAlignment = props.alignmentData.text;\r\n    let imageAlignmentById = props.imageAlignmentById;\r\n    let imageScrollId = props.imageScrollId;\r\n    let isPortraitImage = props.isImagePortrait;\r\n    let [imageSelected, SetSelected] = useState(0);\r\n    let [imageHeight, setImageHeight] = useState(\"50vh\");\r\n    let imageIdList = [];\r\n    let syncIdOnClick = props.syncIdOnClick;\r\n    let [loading, setLoading] = useState(false);\r\n    const [img, setImg] = useState();\r\n\r\n    useEffect(() => {\r\n        setLoading(true);\r\n        if (!_.isEmpty(imageList)) {\r\n            let url = HttpUrl(imageList[imageSelected].target_segment);\r\n            let imageObjectURL = fetchImage(url, imageList);\r\n            imageObjectURL\r\n                .then((data) => {\r\n                    setImg(data);\r\n                    setLoading(false);\r\n                })\r\n                .catch((e) => console.log(e));\r\n\r\n            let image = imageList[imageSelected];\r\n            props.changeSelectedImage(image);\r\n            let imageDocId = image.source_segment.start;\r\n        }\r\n    }, [imageList, imageSelected]);\r\n\r\n    if (!_.isEmpty(imageList)) {\r\n        imageIdList = imageList.map((l) => parseInt(l.source_segment.start));\r\n    }\r\n\r\n    useEffect(() => {\r\n        let IDtoSync = parseInt(imageScrollId.id.start);\r\n        if (\r\n            textIdfromAlignment === props.selectedText.id &&\r\n            imageScrollId.from === 1\r\n        ) {\r\n            if (!_.isEmpty(imageList)) {\r\n                let findSegment = imageList.find(\r\n                    (l) =>\r\n                        l.source_segment.start <= IDtoSync &&\r\n                        l.source_segment.end > IDtoSync\r\n                );\r\n                let index = imageList.findIndex(\r\n                    (l) => l?.source_segment === findSegment.source_segment\r\n                );\r\n                if (parseInt(index) >= 0) {\r\n                    SetSelected(index);\r\n                }\r\n            }\r\n        }\r\n    }, [imageScrollId]);\r\n\r\n    useEffect(() => {\r\n        selectRef.current.value = props.witness;\r\n        setLoading(true);\r\n        fetchImage();\r\n    }, [props.witness]);\r\n\r\n    useEffect(() => {\r\n        if (textIdfromAlignment === props.selectedText.id) {\r\n            let ClickId = syncIdOnClick.toString().replace(\"s_\", \"\");\r\n            if (imageList?.length > 0 && ClickId > 0) {\r\n                let findSegment = imageList.find(\r\n                    (l) =>\r\n                        l.source_segment.start < ClickId &&\r\n                        l.source_segment.end > ClickId\r\n                );\r\n                let index = imageList.findIndex(\r\n                    (l) => l?.source_segment === findSegment?.source_segment\r\n                );\r\n                if (index >= 0) {\r\n                    SetSelected(index);\r\n                }\r\n            }\r\n        }\r\n    }, [syncIdOnClick]);\r\n\r\n    const isPortrait = ({ target: img }) => {\r\n        //this Check if the provided Image is a portrait or a landScape\r\n        let tempHeight = img.naturalHeight;\r\n        setImageHeight(img.naturalHeight);\r\n        let tempWIdth = img.naturalWidth;\r\n        if (tempHeight === 0 || tempWIdth === 0) return null;\r\n        props.changeIsImagePortrait(tempHeight >= tempWIdth);\r\n        setLoading(false);\r\n    };\r\n    const handleChangeImage = (data) => {\r\n        let currentid = imageAlignmentById.find((l) => {\r\n            return l.id === imageSelected;\r\n        });\r\n        console.log(currentid);\r\n        if (data === \"prev\" && imageSelected > 0) {\r\n            SetSelected((prev) => prev - 1);\r\n        }\r\n        if (data === \"next\" && imageSelected < imageIdList.length) {\r\n            SetSelected((prev) => prev + 1);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <div\r\n            className={\r\n                isPortraitImage\r\n                    ? styles.ThirdWindowPortrait\r\n                    : styles.ThirdWindow\r\n            }\r\n            // onResize={handleResize}\r\n        >\r\n            <Box\r\n                className={styles.header}\r\n                sx={{\r\n                    boxShadow: 1,\r\n                    bgcolor: \"primary\",\r\n                }}\r\n            >\r\n                <Box position=\"relative\" zIndex={2}>\r\n                    <FormControl sx={{ m: 1, minWidth: 120 }} size=\"small\">\r\n                        <NativeSelect\r\n                            labelid=\"demo-select-small\"\r\n                            inputRef={selectRef}\r\n                            onChange={(e) =>\r\n                                props.changeImageVersion(e.target.value)\r\n                            }\r\n                            inputProps={{\r\n                                name: \"age\",\r\n                                id: \"uncontrolled-native\",\r\n                            }}\r\n                        >\r\n                            {props.witnesses.map((witness) => {\r\n                                return (\r\n                                    <option\r\n                                        key={witness.id}\r\n                                        value={witness.id}\r\n                                        style={{ textAlign: \"center\" }}\r\n                                    >\r\n                                        {witness.source.name}\r\n                                    </option>\r\n                                );\r\n                            })}\r\n                        </NativeSelect>\r\n                    </FormControl>\r\n                </Box>\r\n                <IconButton\r\n                    aria-label=\"close\"\r\n                    style={{ position: \"absolute\", right: 10 }}\r\n                    onClick={() => props.changeMediaSelection(null)}\r\n                >\r\n                    <CancelIcon />\r\n                </IconButton>\r\n            </Box>\r\n            <Box className={styles.imageSection}>\r\n                {_.isEmpty(imageList) ? (\r\n                    <>\r\n                        {message ? (\r\n                            <h1>{message}</h1>\r\n                        ) : (\r\n                            <Box sx={{ height: \"30vh\" }}>\r\n                                <CircularProgress color=\"secondary\" />\r\n                            </Box>\r\n                        )}\r\n                    </>\r\n                ) : (\r\n                    <>\r\n                        <center height=\"100%\">\r\n                            {!loading ? (\r\n                                <TransformWrapper>\r\n                                    <TransformComponent>\r\n                                        <LazyLoadImage\r\n                                            itemRef={imageRef}\r\n                                            className={styles.ImageStyle}\r\n                                            src={img}\r\n                                            alt=\"imagepecha\"\r\n                                            onLoad={isPortrait}\r\n                                        />\r\n                                    </TransformComponent>\r\n                                </TransformWrapper>\r\n                            ) : (\r\n                                <Box sx={{ height: \"30vh\" }}>\r\n                                    <CircularProgress color=\"secondary\" />\r\n                                </Box>\r\n                            )}\r\n                        </center>\r\n                        <IconButton\r\n                            onClick={() => handleChangeImage(\"prev\")}\r\n                            sx={{\r\n                                position: \"absolute\",\r\n                                left: 20,\r\n                                top: 100,\r\n                            }}\r\n                            color=\"primary\"\r\n                        >\r\n                            <ChevronLeftIcon fill=\"currentColor\" />\r\n                        </IconButton>\r\n                        <IconButton\r\n                            color=\"primary\"\r\n                            onClick={() => handleChangeImage(\"next\")}\r\n                            sx={{\r\n                                position: \"absolute\",\r\n                                right: 20,\r\n                                top: 100,\r\n                            }}\r\n                        >\r\n                            <ChevronRightIcon fill=\"currentColor\" />\r\n                        </IconButton>\r\n                    </>\r\n                )}\r\n            </Box>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default memo(Image);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport * as reducers from \"reducers\";\r\nimport * as actions from \"actions\";\r\nimport MediaOptions from \"./MediaOptions\";\r\nimport DraggableMedia from \"./DraggableMedia\";\r\nconst mapStateToProps = (state) => {\r\n    const scrollToId = reducers.getScrollToId(state);\r\n    const syncIdOnClick = reducers.getSyncIdOnClick(state);\r\n    const imageData = reducers.getImageData(state);\r\n    const videoData = reducers.getVideoData(state);\r\n    let Media = reducers.getMediaData(state);\r\n    const selectedText = reducers.getSelectedText(state);\r\n    const isImagePortrait = reducers.isImagePortrait(state);\r\n    const alignmentData = reducers.getAlignment(state);\r\n    const witness = reducers.getSelectedTextWitnessId(state, selectedText.id);\r\n    const witnesses = reducers.getTextWitnesses(state, selectedText.id);\r\n    const ImageVersion = reducers.getSelectedImageVersion(state);\r\n    const selectedImage = reducers.getSelectedImage(state);\r\n    const imageScrollId = reducers.getImageScrollId(state);\r\n    const imageAlignmentById = reducers.getImageAlignmentById(state);\r\n    //  const selectedSegmentId=reducers.getSelectedSegmentId(state);\r\n\r\n    return {\r\n        scrollToId,\r\n        syncIdOnClick,\r\n        imageData,\r\n        videoData,\r\n        selectedMedia: Media,\r\n        selectedText,\r\n        isImagePortrait,\r\n        // selectedSegmentId,\r\n        alignmentData,\r\n        witness,\r\n        witnesses,\r\n        ImageVersion,\r\n        selectedImage,\r\n        imageScrollId,\r\n        imageAlignmentById,\r\n    };\r\n};\r\n\r\nconst matchDispatchToProps = (dispatch) => {\r\n    const toggleImage = (data) => dispatch(actions.changedShowPageImages(data));\r\n    const changeMediaSelection = (data) =>\r\n        dispatch(actions.mediaSelection(data));\r\n    const changeIsImagePortrait = (payload) =>\r\n        dispatch(actions.setIsImagePortrait(payload));\r\n    const changeImageVersion = (imageVersionId) =>\r\n        dispatch(actions.selectImageVersion(imageVersionId));\r\n    const changeSelectedImage = (payload) =>\r\n        dispatch(actions.selectImage(payload));\r\n    const onSelectedSearchResult = (\r\n        text: api.TextData,\r\n        start: number,\r\n        length: number,\r\n        selectedText: api.TextData | null\r\n    ) => {\r\n        if (!selectedText || selectedText.id !== text.id) {\r\n            dispatch(\r\n                batchActions([\r\n                    actions.selectedSearchResult(text.id, start, length),\r\n                    actions.selectedText(text),\r\n                ])\r\n            );\r\n        } else {\r\n            dispatch(actions.selectedSearchResult(text.id, start, length));\r\n        }\r\n    };\r\n    return {\r\n        toggleImage,\r\n        onSelectedSearchResult,\r\n        changeMediaSelection,\r\n        changeIsImagePortrait,\r\n        changeImageVersion,\r\n        changeSelectedImage,\r\n        changeSelectedRange: (payload) => {\r\n            dispatch(actions.changeSelectedRange(payload));\r\n        },\r\n        changeScrollToId: (payload) =>\r\n            dispatch(actions.changeScrollToId(payload)),\r\n    };\r\n};\r\n\r\nconst MediaContainer = connect(\r\n    mapStateToProps,\r\n    matchDispatchToProps\r\n)(DraggableMedia);\r\n\r\nexport default MediaContainer;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"MediaOption\":\"MediaOptions---MediaOption\",\"header\":\"MediaOptions---header\",\"closeBtn\":\"MediaOptions---closeBtn\"};","import React from \"react\";\r\nimport ImageComponent from \"./Image\";\r\nimport AudioComponent from \"./Audio\";\r\nimport VideoComponent from \"./Video\";\r\nimport styles from \"./MediaOptions.css\";\r\nimport CancelIcon from \"@mui/icons-material/Cancel\";\r\nimport { Box, IconButton } from \"@mui/material\";\r\n\r\nfunction MediaOptions(props) {\r\n    // if (props.selectedMedia.isImageVisible)\r\n    //     return <ImageComponent {...props} />;\r\n\r\n    return (\r\n        <Box\r\n            className={styles.MediaOption}\r\n            sx={{\r\n                boxShadow: 2,\r\n                width: \"100%\",\r\n                height: \"100%\",\r\n            }}\r\n        >\r\n            <Box\r\n                className={styles.header}\r\n                sx={{ bgcolor: \"heading.main\", color: \"text.primary\" }}\r\n            >\r\n                <h3>\r\n                    {props.selectedMedia.isVideoVisible && \"VIDEO\"}\r\n                    {props.selectedMedia.isAudioVisible && \"AUDIO\"}\r\n                    {/* {isPortraitImage?\"portrait\":\"landscape\"} */}\r\n                </h3>\r\n                <IconButton\r\n                    className={styles.closeBtn}\r\n                    onClick={() => props.changeMediaSelection(null)}\r\n                >\r\n                    <CancelIcon />\r\n                </IconButton>\r\n            </Box>\r\n            <Box\r\n                sx={{\r\n                    height: \"100%\",\r\n                    paddingInline: 2,\r\n                    bgcolor: \"navbar.main\",\r\n                    color: \"texts.main\",\r\n                }}\r\n            >\r\n                {/* {props.selectedMedia.isVideoVisible && (\r\n                    <VideoComponent {...props} />\r\n                )}\r\n                {props.selectedMedia.isAudioVisible && (\r\n                    <AudioComponent {...props} />\r\n                )} */}\r\n            </Box>\r\n        </Box>\r\n    );\r\n}\r\n\r\nexport default MediaOptions;\r\n","import React, { useRef, useEffect, useState, useCallback } from \"react\";\r\nimport ReactPlayer from \"react-player\";\r\nimport _ from \"lodash\";\r\nimport { Collapse } from \"@mui/material\";\r\n\r\nfunction toHMS(seconds) {\r\n    var date = new Date(null);\r\n    date.setSeconds(seconds);\r\n    return date.toISOString().substr(11, 8);\r\n}\r\nfunction toSec(hms = \"\") {\r\n    var a = hms.split(\":\"); // split it at the colons\r\n    // minutes are worth 60 seconds. Hours are worth 60 minutes.\r\n    var seconds = +a[0] * 60 * 60 + +a[1] * 60 + +a[2];\r\n    return seconds;\r\n}\r\nfunction calTimeToSeek(maxValue, currentTime) {\r\n    let i = toSec(currentTime) / maxValue;\r\n    return parseFloat(i);\r\n}\r\nfunction getClosestNumber(arr, d) {\r\n    return arr.reduce((a, b) => (b <= d && a < b ? b : a), 0);\r\n}\r\nfunction Video(props) {\r\n    let textIdfromAlignment = props.alignmentData.text;\r\n    let sourceId = props?.videoData?.source?.text;\r\n    const VideoData = props?.videoData?.alignment || [];\r\n    const url = \"https://www.youtube.com/watch?v=2MMM_ggekfE\";\r\n    const [interval, setInterval] = useState({});\r\n    let VideoIdList = [];\r\n\r\n    // const syncIdOnScroll = props.syncIdOnScroll;\r\n    const syncIdOnClick = props.syncIdOnClick;\r\n    const [state, setState] = useState({\r\n        played: 0,\r\n        duration: 0,\r\n        playing: true,\r\n    });\r\n    if (!_.isEmpty(VideoData)) {\r\n        VideoIdList = VideoData.map((l) => parseInt(l.source_segment.start));\r\n    }\r\n\r\n    useEffect(() => {\r\n        if (textIdfromAlignment === props.selectedText.id) {\r\n            //     let intersection = syncIdOnScroll.filter(element => VideoIdList.includes(element));\r\n            //     newList= VideoData.filter(d=>d.source_segment===intersection[0]);\r\n            //     jumpToTime(newList[0]?.target_segment.start)\r\n            let ClickId = syncIdOnClick;\r\n            let closestID = getClosestNumber(VideoIdList, ClickId);\r\n            let data = VideoData.find(\r\n                (l) => l.source_segment.start === closestID.toString()\r\n            );\r\n            if (!_.isEmpty(data)) {\r\n                jumpToTime(data.target_segment.start);\r\n            }\r\n        }\r\n    }, [syncIdOnClick]);\r\n\r\n    const changeTextBackground = useCallback(() => {\r\n        let current = interval;\r\n        if (textIdfromAlignment === props.selectedText.id) {\r\n            for (let i = current.start; i < current.end; i++) {\r\n                let currentIds = document.getElementById(`s_${i}`);\r\n                if (currentIds) {\r\n                    currentIds.style.fontWeight = \"bold\";\r\n                }\r\n            }\r\n        }\r\n    }, [interval.start]);\r\n\r\n    useEffect(() => {\r\n        let timer = setTimeout(() => changeTextBackground(), 800);\r\n        let current = interval;\r\n        if (interval.start) {\r\n            props.changeScrollToId({\r\n                id: current.start || null,\r\n                from: \"video\",\r\n            });\r\n        }\r\n        return () => {\r\n            clearTimeout(timer);\r\n            for (let i = current.start; i < current.end; i++) {\r\n                let currentIds = document.getElementById(`s_${i}`);\r\n                if (currentIds) {\r\n                    currentIds.style.fontWeight = \"normal\";\r\n                }\r\n            }\r\n        };\r\n    }, [interval.start]);\r\n\r\n    const videoRef = useRef();\r\n\r\n    const jumpToTime = (time) => {\r\n        let newData = calTimeToSeek(state.duration, time);\r\n        videoRef.current.seekTo(parseFloat(newData));\r\n    };\r\n\r\n    const handleProgress = (e) => {\r\n        const played = e.playedSeconds;\r\n        const Interval = VideoData.find(\r\n            (time) =>\r\n                toSec(time.target_segment.start) < played &&\r\n                toSec(time.target_segment.end) > played\r\n        );\r\n        if (!_.isEmpty(Interval)) {\r\n            let source_segment = Interval.source_segment;\r\n            changeTextBackground();\r\n            setInterval({ ...source_segment });\r\n        }\r\n    };\r\n    if (VideoData.length === 0) return <div />;\r\n    if (sourceId !== props.selectedText.id) return <div />;\r\n    return (\r\n        <Collapse in={props.open}>\r\n            <ReactPlayer\r\n                url={url}\r\n                style={{ maxWidth: \"100%\" }}\r\n                ref={videoRef}\r\n                controls={true}\r\n                onDuration={(duration) =>\r\n                    setState({ ...state, duration: duration })\r\n                }\r\n                light\r\n                playing\r\n                onPlay={() => setState({ ...state, playing: true })}\r\n                onPause={() => setState({ ...state, playing: false })}\r\n                onProgress={handleProgress}\r\n                onError={() => console.log(\"error in media sec\")}\r\n            />\r\n        </Collapse>\r\n    );\r\n}\r\n\r\nexport default Video;\r\n","export { default } from \"./MediaContainer\";\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"button\":\"AddButton---button\"};","import React from \"react\";\r\nimport styles from \"./AddButton.css\";\r\n\r\ntype Props = {\r\n    title?: string,\r\n    onClick?: () => void\r\n};\r\n\r\nconst AddButton = (props: Props) => {\r\n    return (\r\n        <div className={styles.button} title={props.title} onClick={props.onClick}>\r\n            +\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default AddButton;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"inlineWidth\":\"280px\",\"annotationControls\":\"AnnotationControls---annotationControls\",\"annotationContent\":\"AnnotationControls---annotationContent\",\"subTitle\":\"AnnotationControls---subTitle\",\"title\":\"AnnotationControls---title\",\"sectionHeading\":\"AnnotationControls---sectionHeading\",\"text\":\"AnnotationControls---text\",\"padding\":\"AnnotationControls---padding\",\"arrowTop\":\"AnnotationControls---arrowTop\",\"arrowLeft\":\"AnnotationControls---arrowLeft\",\"arrowRight\":\"AnnotationControls---arrowRight\",\"inline\":\"AnnotationControls---inline\",\"arrow\":\"AnnotationControls---arrow\",\"arrowDs\":\"AnnotationControls---arrowDs\",\"nothingSelected\":\"AnnotationControls---nothingSelected\",\"anonymousMessage\":\"AnnotationControls---anonymousMessage\",\"noNotes\":\"AnnotationControls---noNotes\",\"breakButtons\":\"AnnotationControls---breakButtons\"};","// @flow\r\nimport * as React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport AnnotationDetail from \"./AnnotationDetail\";\r\nimport AnnotationDetailEdit from \"./AnnotationDetailEdit\";\r\nimport styles from \"./AnnotationControls.css\";\r\nimport colours from \"css/colour.css\";\r\nimport User from \"lib/User\";\r\nimport Witness from \"lib/Witness\";\r\nimport Annotation, { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport AnnotationControlsHeading from \"./AnnotationControlsHeading\";\r\nimport NoteEditor from \"./NoteEditor\";\r\nimport QuestionView from \"./QuestionView\";\r\nimport QuestionEditor from \"./QuestionEditor\";\r\nimport QuestionsLoading from \"./QuestionsLoading\";\r\nimport { FormattedMessage } from \"react-intl\";\r\nimport Note from \"./Note\";\r\nimport Button from \"components/UI/Button\";\r\nimport PageBreakIcon from \"images/page_break_icon.svg\";\r\nimport { List } from \"react-virtualized/dist/es/List\";\r\nimport AnnotationControlsHeader from \"./AnnotationControlsHeader\";\r\nimport Question from \"lib/Question\";\r\n\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nexport const CONTROLS_MARGIN_LEFT = 10;\r\nconst FAKE_LOGIN = false;\r\nexport type QuestionData = {\r\n    loading: boolean,\r\n    questions: Question[],\r\n};\r\n\r\nexport type Props = {\r\n    inline: boolean,\r\n    user: User,\r\n    annotationsData: null,\r\n    activeAnnotation: null,\r\n    baseAnnotation: null,\r\n    availableAnnotations: Annotation[] | null,\r\n    temporaryAnnotation: null,\r\n    inline: null,\r\n    firstSelectedSegment: null,\r\n    splitTextRect: ClientRect | null,\r\n    selectedWitness: Witness,\r\n    selectedElementId: string | null,\r\n    selectedElementIds: string[] | null,\r\n    pechaImageClass: string,\r\n    notes: Annotation[],\r\n    temporaryNotes: Annotation[],\r\n    questions: Annotation[],\r\n    questionsData: { [annotationId: AnnotationUniqueId]: QuestionData },\r\n    temporaryQuestions: Annotation[],\r\n    questionQuote: React.Element<typeof React.Component> | null,\r\n    addNote: () => void,\r\n    editNote: (annotation: Annotation) => void,\r\n    saveAnnotation: (annotation: Annotation, content: string) => void,\r\n    cancelEditAnnotation: (annotation: Annotation) => void,\r\n    deleteAnnotation: (annotation: Annotation) => void,\r\n    addPageBreak: () => void,\r\n    addLineBreak: () => void,\r\n    addQuestion: () => void,\r\n    saveQuestion: (\r\n        question: Annotation,\r\n        title: string,\r\n        content: string\r\n    ) => void,\r\n    list: List | null,\r\n    closeAnnotation: () => void,\r\n};\r\n\r\ntype AnchorPoint = \"top\" | \"left\" | \"bottom\" | \"right\";\r\n\r\nconst anchorPoints = {\r\n    top: 1,\r\n    left: 2,\r\n    bottom: 3,\r\n    right: 4,\r\n};\r\n\r\nclass AnnotationControls extends React.Component<Props> {\r\n    controls: HTMLDivElement | null;\r\n    arrow: HTMLDivElement | null;\r\n    arrowDs: HTMLDivElement | null;\r\n    annotation: null;\r\n    constructor(props: Props) {\r\n        super(props);\r\n\r\n        this.controls = null;\r\n        this.arrow = null;\r\n        this.arrowDs = null;\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.updatePosition();\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        // Need to delay calling this because the browser\r\n        // may not have finished rendering when first called.\r\n\r\n        setTimeout(this.updatePosition.bind(this), 0);\r\n    }\r\n\r\n    updatePosition() {\r\n        const measurements = this.getMeasurements();\r\n        if (\r\n            !this.props.inline ||\r\n            !this.controls ||\r\n            !this.arrow ||\r\n            !measurements\r\n        ) {\r\n            return;\r\n        }\r\n        const controls = this.controls;\r\n        const height = controls.offsetHeight;\r\n        const width = controls.offsetWidth;\r\n        const arrow = this.arrow;\r\n        const bottomGap = measurements.bottomGap;\r\n        const offScreen = bottomGap < 0 || bottomGap > height;\r\n\r\n        let top = measurements.top;\r\n        const viewPortWidth = measurements.viewPortWidth || 0;\r\n\r\n        let selectedLeft = measurements.left;\r\n        let selectedRight = selectedLeft + measurements.width;\r\n\r\n        arrow.style.display = \"none\";\r\n        if (this.props.selectedElementIds) {\r\n            let lines = 1;\r\n            let prevSegmentLeft = 0;\r\n            let lastLineLeft = 0;\r\n            let lastLineRight = 0;\r\n            let lastLineBottom = 0;\r\n            for (let i = 0; i < this.props.selectedElementIds.length; i++) {\r\n                const segmentId = this.props.selectedElementIds[i];\r\n                const segment = document.getElementById(segmentId);\r\n                if (segment) {\r\n                    const segmentLeft = segment.offsetLeft;\r\n                    const segmentRight = segmentLeft + segment.offsetWidth;\r\n                    if (segmentLeft < prevSegmentLeft) {\r\n                        lines++;\r\n                        lastLineLeft = segmentLeft;\r\n                        lastLineRight = segmentRight;\r\n                        lastLineBottom =\r\n                            segment.offsetTop + segment.offsetHeight;\r\n                        selectedLeft = segmentLeft;\r\n                        selectedRight = segmentRight;\r\n                    } else if (segmentRight > lastLineRight) {\r\n                        lastLineRight = segmentRight;\r\n                        // selectedRight = segmentRight;\r\n                    }\r\n                    if (segmentLeft < selectedLeft) selectedLeft = segmentLeft;\r\n                    if (segmentRight > selectedRight)\r\n                        selectedRight = segmentRight;\r\n                    prevSegmentLeft = segmentLeft;\r\n                }\r\n            }\r\n        }\r\n        let selectedWidth = selectedRight - selectedLeft;\r\n\r\n        let anchorPoint = anchorPoints.bottom;\r\n        let moveToSide = false;\r\n        let moveRight = 0;\r\n        if (!offScreen && bottomGap < height) {\r\n            moveToSide = true;\r\n        }\r\n\r\n        if (moveToSide) {\r\n            arrow.className = styles.arrowLeft;\r\n            if (selectedLeft - width - arrow.offsetWidth < 0) {\r\n                anchorPoint = anchorPoints.right;\r\n            } else {\r\n                anchorPoint = anchorPoints.left;\r\n            }\r\n        } else {\r\n            let controlOverhang = width / 2 - selectedWidth / 2;\r\n            if (selectedLeft - controlOverhang < 0) {\r\n                moveRight = Math.abs(selectedLeft - controlOverhang);\r\n            }\r\n            if (selectedRight + controlOverhang > viewPortWidth) {\r\n                moveRight = viewPortWidth - (selectedRight + controlOverhang);\r\n            }\r\n        }\r\n\r\n        if (anchorPoint === anchorPoints.bottom) {\r\n            let arrowHeight = 0;\r\n            let arrowLeft = 0;\r\n            if (this.arrow) {\r\n                this.arrow.className = styles.arrowTop;\r\n                arrowLeft = width / 2 - this.arrow.offsetWidth / 2 - moveRight;\r\n                if (arrowLeft < 0) arrowLeft = 0;\r\n                this.arrow.style.left = arrowLeft + \"px\";\r\n                arrowHeight = this.arrow.offsetHeight;\r\n                this.arrow.style.top = 0 - arrowHeight + \"px\";\r\n            }\r\n            controls.style.top = top + measurements.height + arrowHeight + \"px\";\r\n            controls.style.left =\r\n                selectedLeft + selectedWidth / 2 - width / 2 + moveRight + \"px\";\r\n        } else if (moveToSide) {\r\n            arrow.className = styles.arrowRight;\r\n            let arrowHeight = arrow.offsetHeight;\r\n            let controlsTop =\r\n                measurements.top + measurements.height / 2 - arrowHeight / 2;\r\n            if (\r\n                measurements.top +\r\n                    measurements.height +\r\n                    bottomGap -\r\n                    controlsTop <\r\n                height\r\n            ) {\r\n                controlsTop =\r\n                    measurements.top + measurements.height + bottomGap - height;\r\n            }\r\n            if (anchorPoint === anchorPoints.left) {\r\n                // left side of selection\r\n                arrow.style.left = width - 2 + \"px\";\r\n                controls.style.left =\r\n                    selectedLeft - width - arrow.offsetWidth + \"px\";\r\n            } else {\r\n                // right-side of selection\r\n\r\n                arrow.className = styles.arrowLeft;\r\n                arrow.style.left = -arrow.offsetWidth + \"px\";\r\n                controls.style.left =\r\n                    selectedLeft + selectedWidth + arrow.offsetWidth + \"px\";\r\n\r\n                // controls.style.right = 0 + \"px\";\r\n            }\r\n            arrow.style.top =\r\n                measurements.top -\r\n                controlsTop +\r\n                measurements.height / 2 -\r\n                arrowHeight / 2 +\r\n                \"px\";\r\n\r\n            controls.style.top = controlsTop + \"px\";\r\n        } else {\r\n            controls.style.top = top + \"px\";\r\n        }\r\n    }\r\n\r\n    getMeasurements(): {\r\n        top: number,\r\n        textTop: number,\r\n        rowTop: number,\r\n        left: number,\r\n        width: number,\r\n        height: number,\r\n        topGap: number,\r\n        bottomGap: number,\r\n        viewPortWidth: number | null,\r\n    } | null {\r\n        if (!this.props.selectedElementIds) {\r\n            return null;\r\n        }\r\n\r\n        const lastSelectedElementId =\r\n            this.props.selectedElementIds[\r\n                this.props.selectedElementIds.length - 1\r\n            ];\r\n        const lastElement = document.getElementById(lastSelectedElementId);\r\n        const firstSelectedElementId = this.props.selectedElementIds[0];\r\n        const firstElement = document.getElementById(firstSelectedElementId);\r\n\r\n        const splitTextRect = this.props.splitTextRect;\r\n        let extraTop = 0;\r\n        let scrollTop = 0;\r\n\r\n        if (this.props.list) {\r\n            scrollTop = this.props.list.Grid.state.scrollTop;\r\n        }\r\n        if (this.props.pechaImageClass) {\r\n            const pechaImage = document.getElementsByClassName(\r\n                this.props.pechaImageClass\r\n            )[0];\r\n            extraTop = pechaImage.offsetHeight;\r\n        }\r\n        if (!lastElement) {\r\n            console.warn(\r\n                \"no valid element found in getMeasurements, elementId: %s\",\r\n                this.props.selectedElementId\r\n            );\r\n            return {\r\n                top: 0,\r\n                textTop: 0,\r\n                rowTop: 0,\r\n                left: 0,\r\n                width: 1,\r\n                height: 1,\r\n                topGap: 0,\r\n                bottomGap: 0,\r\n                viewPortWidth: 1,\r\n            };\r\n        }\r\n        const top = lastElement.offsetTop + extraTop;\r\n        const textTop = lastElement.offsetTop;\r\n        const left = lastElement.offsetLeft;\r\n        const width = lastElement.offsetWidth;\r\n        const height = lastElement.offsetHeight;\r\n        let rowTop = top;\r\n\r\n        let viewPortWidth = null;\r\n        let topGap = 0;\r\n        let bottomGap = 0;\r\n        if (lastElement && splitTextRect) {\r\n            const elRect = lastElement.getBoundingClientRect();\r\n\r\n            bottomGap =\r\n                splitTextRect.height + splitTextRect.top - elRect.bottom;\r\n            viewPortWidth = splitTextRect.width;\r\n        }\r\n        if (firstElement && splitTextRect) {\r\n            const elRect = firstElement.getBoundingClientRect();\r\n            topGap = splitTextRect.height - elRect.top;\r\n        }\r\n\r\n        return {\r\n            top: top,\r\n            textTop: textTop,\r\n            rowTop: rowTop,\r\n            left: left,\r\n            width: width,\r\n            height: height,\r\n            topGap: topGap,\r\n            bottomGap: bottomGap,\r\n            viewPortWidth: viewPortWidth,\r\n        };\r\n    }\r\n\r\n    render() {\r\n        const props = this.props;\r\n        let annotations = [];\r\n        let temporaryAnnotations = [];\r\n        let anonymousUserMessage = null;\r\n        let nothingSelected = null;\r\n        const isLoggedIn = props.user.isLoggedIn || FAKE_LOGIN;\r\n\r\n        let breakSelected = false;\r\n        if (\r\n            props.activeAnnotation &&\r\n            (props.activeAnnotation.isType(ANNOTATION_TYPES.pageBreak) ||\r\n                props.activeAnnotation.isType(ANNOTATION_TYPES.lineBreak))\r\n        ) {\r\n            breakSelected = true;\r\n        }\r\n        // the selected word/sentence is props.anotationsData\r\n\r\n        if (props.annotationsData) {\r\n            props.annotationsData.map((annotationData) => {\r\n                let isEditing = false;\r\n                let isActive = false;\r\n                if (annotationData.isTemporary) {\r\n                    isEditing = true;\r\n                    isActive = true;\r\n                } else if (\r\n                    !props.temporaryAnnotation &&\r\n                    annotationData.annotation.uniqueId ==\r\n                        props.activeAnnotation.uniqueId\r\n                ) {\r\n                    isActive = true;\r\n                }\r\n\r\n                if (isEditing) {\r\n                    let annotationDetail = (\r\n                        <AnnotationDetailEdit\r\n                            annotationData={annotationData}\r\n                            key={annotationData.annotation.uniqueId}\r\n                            isActive={isActive}\r\n                            saveAnnotationHandler={(content) => {\r\n                                props.saveAnnotation(\r\n                                    annotationData.annotation,\r\n                                    content\r\n                                );\r\n                            }}\r\n                            cancelAnnotationHandler={() => {\r\n                                props.cancelEditAnnotation(\r\n                                    annotationData.annotation\r\n                                );\r\n                            }}\r\n                            isLoggedIn={isLoggedIn}\r\n                            selectAnnotationHandler={() => {}}\r\n                            editAnnotationHandler={() => {}}\r\n                        />\r\n                    );\r\n                    temporaryAnnotations.push(annotationDetail);\r\n                } else {\r\n                    let annotationDetail = (\r\n                        <AnnotationDetail\r\n                            isWorkingSection={false}\r\n                            fontSize={props.fontSize}\r\n                            annotationData={annotationData}\r\n                            key={annotationData.annotation.uniqueId}\r\n                            isActive={isActive}\r\n                            selectAnnotationHandler={() => {\r\n                                if (isLoggedIn && !isEditing) {\r\n                                    props.didSelectAnnotation(\r\n                                        annotationData.annotation\r\n                                    );\r\n                                }\r\n                            }}\r\n                            editAnnotationHandler={() => {\r\n                                if (isLoggedIn && !isEditing) {\r\n                                    this.annotation = annotationData.annotation;\r\n\r\n                                    props.editAnnotation(\r\n                                        annotationData.annotation\r\n                                    );\r\n                                }\r\n                            }}\r\n                            isLoggedIn={isLoggedIn}\r\n                        />\r\n                    );\r\n                    annotations.push(annotationDetail);\r\n                }\r\n            }, this);\r\n            if (!props.user.isLoggedIn === !FAKE_LOGIN) {\r\n                // NOTE: FormattedMessage cannot take a child when using\r\n                // the values option, so need to wrap it in a div\r\n                anonymousUserMessage = (\r\n                    <div\r\n                        className={styles.anonymousMessage}\r\n                        style={{\r\n                            position: \"relative\",\r\n                            width: \"fit-content\",\r\n                            border: \"1px solid gray\",\r\n                            paddingInline: 10,\r\n                        }}\r\n                    >\r\n                        <FormattedMessage\r\n                            id=\"annotations.loginMessage\"\r\n                            values={{\r\n                                loginLink: (\r\n                                    <>\r\n                                        <FormattedMessage id=\"annotations.loginLink\" />\r\n                                    </>\r\n                                ),\r\n                            }}\r\n                        />\r\n                    </div>\r\n                );\r\n            }\r\n        } else {\r\n            nothingSelected = (\r\n                <div className={styles.nothingSelected}>Nothing Selected</div>\r\n            );\r\n        }\r\n\r\n        let pageBreaksButton = null;\r\n        let allowPageBreak = !this.props.selectedWitness.isWorking;\r\n        let lineBreaksButton = null;\r\n        let allowLineBreak = !this.props.selectedWitness.isWorking;\r\n        if (isLoggedIn && !this.props.selectedWitness.isWorking) {\r\n            let pageBreaks = [];\r\n            let lineBreaks = [];\r\n            if (this.props.availableAnnotations) {\r\n                pageBreaks = this.props.availableAnnotations.filter(\r\n                    (annotation: Annotation) =>\r\n                        annotation.type === ANNOTATION_TYPES.pageBreak &&\r\n                        annotation.creatorWitness.id ===\r\n                            this.props.selectedWitness.id\r\n                );\r\n                lineBreaks = this.props.availableAnnotations.filter(\r\n                    (annotation: Annotation) =>\r\n                        annotation.type === ANNOTATION_TYPES.lineBreak &&\r\n                        annotation.creatorWitness.id ===\r\n                            this.props.selectedWitness.id\r\n                );\r\n            }\r\n\r\n            if (pageBreaks.length > 0) {\r\n                pageBreaksButton = (\r\n                    <div className={styles.breakButtons}>\r\n                        <Button\r\n                            title=\"Page Break\"\r\n                            accessoryType=\"DELETE\"\r\n                            icon={<PageBreakIcon width={20} height={20} />}\r\n                            onClick={() => {\r\n                                this.props.deleteAnnotation(pageBreaks[0]);\r\n                            }}\r\n                            isActive={true}\r\n                            backgroundColor={colours.activeButton}\r\n                        />\r\n                    </div>\r\n                );\r\n                allowPageBreak = false;\r\n            }\r\n\r\n            if (lineBreaks.length > 0) {\r\n                lineBreaksButton = (\r\n                    <div className={styles.breakButtons}>\r\n                        <Button\r\n                            title=\"Line Break\"\r\n                            accessoryType=\"DELETE\"\r\n                            icon=\"&#182;\"\r\n                            onClick={() => {\r\n                                this.props.deleteAnnotation(lineBreaks[0]);\r\n                            }}\r\n                            isActive={true}\r\n                            backgroundColor={colours.activeButton}\r\n                        />\r\n                    </div>\r\n                );\r\n                allowLineBreak = false;\r\n            }\r\n\r\n            // Can't have line break and page break in same place.\r\n            if (!allowPageBreak) allowLineBreak = false;\r\n            if (!allowLineBreak) allowPageBreak = false;\r\n        }\r\n\r\n        let tempNotes = null;\r\n        let tempNoteIds = {};\r\n        if (props.temporaryNotes && props.temporaryNotes.length > 0) {\r\n            tempNotes = props.temporaryNotes.map((note: Annotation) => {\r\n                let key = \"NOTE_\" + note.uniqueId;\r\n                // The note is being edited\r\n                if (note.basedOn) {\r\n                    tempNoteIds[note.basedOn.uniqueId] = note.uniqueId;\r\n                }\r\n                return (\r\n                    <NoteEditor\r\n                        note={note}\r\n                        key={key}\r\n                        saveNote={props.saveAnnotation}\r\n                        cancel={() => props.cancelEditAnnotation(note)}\r\n                    />\r\n                );\r\n            });\r\n        }\r\n\r\n        let notes = null;\r\n        if (props.notes && props.notes.length > 0) {\r\n            // Filter out notes that are being edited\r\n            const validNotes = props.notes.filter(\r\n                (note: Annotation) => !tempNoteIds.hasOwnProperty(note.uniqueId)\r\n            );\r\n            notes = validNotes.map((note: Annotation) => {\r\n                let key = \"NOTE_\" + note.uniqueId;\r\n                return (\r\n                    <Note\r\n                        note={note}\r\n                        key={key}\r\n                        delete={this.props.deleteAnnotation}\r\n                        edit={this.props.editNote}\r\n                    />\r\n                );\r\n            });\r\n        }\r\n\r\n        let tempQuestions = null;\r\n        let tempQuestionIds = {};\r\n        if (\r\n            props.temporaryQuestions &&\r\n            props.temporaryQuestions.length > 0 &&\r\n            props.questionQuote\r\n        ) {\r\n            tempQuestions = props.temporaryQuestions.map(\r\n                (question: Annotation) => {\r\n                    tempQuestionIds[question.uniqueId] = question.uniqueId;\r\n                    let key = \"QUESTION_\" + question.uniqueId;\r\n\r\n                    return (\r\n                        <QuestionEditor\r\n                            question={question}\r\n                            questionQuote={props.questionQuote}\r\n                            defaultTitle={props.selectedWitness.text.name}\r\n                            key={key}\r\n                            saveQuestion={props.saveQuestion}\r\n                            cancel={() => props.cancelEditAnnotation(question)}\r\n                        />\r\n                    );\r\n                }\r\n            );\r\n        }\r\n\r\n        let questionLoadingIndicators = null;\r\n        let questionViews: Array<QuestionView> = [];\r\n        let questionsAreLoading = false;\r\n        if (props.questions && props.questions.length > 0) {\r\n            let questions: Question[] = [];\r\n            for (let i = 0; i < props.questions.length; i++) {\r\n                const question = props.questions[i];\r\n                let isValid = !tempQuestionIds.hasOwnProperty(\r\n                    question.uniqueId\r\n                );\r\n                if (isValid) {\r\n                    if (props.questionsData.hasOwnProperty(question.uniqueId)) {\r\n                        if (props.questionsData[question.uniqueId].loading) {\r\n                            questionsAreLoading = true;\r\n                        }\r\n                        questions = questions.concat(\r\n                            props.questionsData[question.uniqueId].questions\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            questionViews = questions.map((question: Question) => {\r\n                let key = \"QUESTION_\" + question.annotationUniqueId;\r\n                return (\r\n                    <QuestionView\r\n                        question={question}\r\n                        key={\"question_\" + question.annotationUniqueId}\r\n                    />\r\n                );\r\n            });\r\n        }\r\n        let questionHeading = null;\r\n        if (questionViews.length > 0) {\r\n            questionHeading = (\r\n                <h3 className={styles.sectionHeading}>Questions</h3>\r\n            );\r\n        }\r\n\r\n        let questionsLoading = null;\r\n        if (questionsAreLoading) {\r\n            questionsLoading = <QuestionsLoading />;\r\n        }\r\n\r\n        let allowQuestion =\r\n            props.questions.length === 0 &&\r\n            props.temporaryQuestions.length === 0;\r\n\r\n        let classes = [styles.annotationControls];\r\n        if (props.inline) {\r\n            classes.push(styles.inline);\r\n        }\r\n\r\n        let showHeader = true;\r\n        if (anonymousUserMessage || breakSelected) showHeader = false;\r\n\r\n        return (\r\n            <div\r\n                className={classnames(...classes)}\r\n                ref={(controls: HTMLDivElement | null) =>\r\n                    (this.controls = controls)\r\n                }\r\n            >\r\n                {showHeader && (\r\n                    <AnnotationControlsHeader\r\n                        addPageBreak={\r\n                            allowPageBreak ? props.addPageBreak : null\r\n                        }\r\n                        addLineBreak={\r\n                            allowLineBreak ? props.addLineBreak : null\r\n                        }\r\n                        addNote={\r\n                            isLoggedIn && !tempNotes\r\n                                ? () => props.addNote()\r\n                                : null\r\n                        }\r\n                        addQuestion={allowQuestion ? props.addQuestion : null}\r\n                        closeAnnotation={props.closeAnnotation}\r\n                        editAnnotationHandler={() => {\r\n                            let editBtn = document.getElementById(\"editBtn\");\r\n                            editBtn?.click();\r\n                        }}\r\n                        userLoggedIn={isLoggedIn}\r\n                    />\r\n                )}\r\n\r\n                <div className={styles.annotationContent}>\r\n                    {anonymousUserMessage}\r\n                    {nothingSelected}\r\n                    {!breakSelected && temporaryAnnotations}\r\n                    {!breakSelected && annotations}\r\n                    {pageBreaksButton}\r\n                    {lineBreaksButton}\r\n                    {tempNotes}\r\n                    {notes}\r\n                    {questionHeading}\r\n                    {tempQuestions}\r\n                    {questionsLoading}\r\n                    {questionViews}\r\n                </div>\r\n                <div\r\n                    className={styles.arrow}\r\n                    ref={(div) => (this.arrow = div)}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default React.memo(AnnotationControls);\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect, useStore } from \"react-redux\";\r\nimport { batchActions } from \"redux-batched-actions\";\r\nimport AnnotationControls from \"./AnnotationControls\";\r\nimport type { Props as ControlsProps } from \"./AnnotationControls\";\r\nimport addTibetanShay from \"lib/addTibetanShay\";\r\nimport * as reducers from \"reducers\";\r\nimport type { AppState } from \"reducers\";\r\nimport * as actions from \"actions\";\r\nimport { BASE_ANNOTATION_ID } from \"lib/AnnotatedText\";\r\nimport Annotation, {\r\n    ANNOTATION_TYPES,\r\n    TemporaryAnnotation,\r\n} from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport AnnotatedText from \"lib/AnnotatedText\";\r\nimport User from \"lib/User\";\r\nimport Witness from \"lib/Witness\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport SplitText from \"lib/SplitText\";\r\nimport _ from \"lodash\";\r\nimport { changedActiveTextAnnotation } from \"actions\";\r\nimport ReactDOMServer from \"react-dom/server\";\r\nimport Question from \"lib/Question\";\r\nimport type { QuestionData } from \"./AnnotationControls\";\r\nimport { getTextFontSize } from \"reducers\";\r\n\r\nconst TEMPORARY_ANNOTATION_ID = -3;\r\nconst BASE_NAME = \"Working\";\r\n\r\ntype AnnotationData = {\r\n    name: string,\r\n    content: string,\r\n    id: AnnotationUniqueId,\r\n    isTemporary: boolean,\r\n    annotation: Annotation,\r\n    userCreated: boolean,\r\n};\r\nconst getAnnotationsData = (\r\n    annotations,\r\n    sources,\r\n    workingSourceName,\r\n    selectedText\r\n): AnnotationData[] => {\r\n    let annotationsData = [];\r\n    let baseSources = sources.filter(\r\n        (source) => source.isWorking || source.isBase\r\n    );\r\n    let baseSourceNames = baseSources.map((source) => source.name);\r\n    if (annotations) {\r\n        let annotationsById = {};\r\n        for (let i = 0; i < annotations.length; i++) {\r\n            let annotation = annotations[i];\r\n            let id = annotation.content + annotation.start;\r\n            if (annotation.isTemporary) {\r\n                annotationsById[TEMPORARY_ANNOTATION_ID] = {\r\n                    name: annotation.getSourceName(),\r\n                    content: annotation.content,\r\n                    id: annotation.uniqueId,\r\n                    isTemporary: true,\r\n                    annotation: annotation,\r\n                };\r\n                baseSourceNames = baseSourceNames.filter(\r\n                    (a) => a !== annotation.getSourceName()\r\n                );\r\n                id = TEMPORARY_ANNOTATION_ID;\r\n            } else if (annotationsById[id]) {\r\n                let existingAnnotation = annotationsById[id];\r\n                existingAnnotation.name +=\r\n                    \" \" + addTibetanShay(annotation.getSourceName());\r\n                baseSourceNames = baseSourceNames.filter(\r\n                    (a) => a !== annotation.getSourceName()\r\n                );\r\n            } else {\r\n                annotationsById[id] = {\r\n                    name: addTibetanShay(annotation.getSourceName()),\r\n                    content: annotation.content,\r\n                    id: annotation.uniqueId,\r\n                    userCreated: annotation.userCreated,\r\n                    annotation: annotation,\r\n                };\r\n                baseSourceNames = baseSourceNames.filter(\r\n                    (a) => a !== annotation.getSourceName()\r\n                );\r\n            }\r\n            if (\r\n                !annotation.userCreated &&\r\n                annotation.creatorWitness.isWorking\r\n            ) {\r\n                annotationsById[id].isWorking = true;\r\n            } else {\r\n                annotationsById[id].isWorking = false;\r\n            }\r\n        }\r\n        // Make sure Working source is first\r\n        baseSourceNames.unshift(workingSourceName);\r\n        let Base = baseSourceNames;\r\n        if (\r\n            selectedText?.name !==\r\n            \"བྱང་ཆུབ་སེམས་དཔའི་སྤྱོད་པ་ལ་འཇུག་པ་བཞུགས་སོ།\"\r\n        ) {\r\n            //Dominant only awailable for chojuk text\r\n            Base = baseSourceNames.filter((l) => l !== \"Dominant\");\r\n        }\r\n\r\n        annotationsData = Object.keys(annotationsById).reduce((arr, key) => {\r\n            const annotationData = annotationsById[key];\r\n\r\n            if (annotationData.isWorking) {\r\n                annotationData.name = Base.reduce(\r\n                    (prev, cur) => (prev += \" \" + addTibetanShay(cur, \";\")),\r\n                    \"\"\r\n                );\r\n            }\r\n            arr.push(annotationData);\r\n            return arr;\r\n        }, []);\r\n    }\r\n\r\n    return annotationsData;\r\n};\r\n\r\nconst getAvailableAnnotations = (\r\n    annotatedText: AnnotatedText,\r\n    activeAnnotation: Annotation,\r\n    temporaryAnnotation: TemporaryAnnotation | null,\r\n    annotationPositions: { [string]: Annotation[] }\r\n): Annotation[] => {\r\n    let availableAnnotations = [];\r\n    if (\r\n        !temporaryAnnotation ||\r\n        activeAnnotation.naturalId !== temporaryAnnotation.naturalId\r\n    ) {\r\n        availableAnnotations.push(activeAnnotation);\r\n    }\r\n    if (temporaryAnnotation) {\r\n        availableAnnotations.push(temporaryAnnotation);\r\n    }\r\n    let [start, length] =\r\n        annotatedText.getPositionOfAnnotation(activeAnnotation);\r\n\r\n    if (!start) {\r\n        return availableAnnotations;\r\n    }\r\n\r\n    let end = start + length;\r\n\r\n    let possibleAnnotations = [];\r\n\r\n    if (activeAnnotation.isInsertion) {\r\n        const insertionAnnotations = annotationPositions[\"i\" + start];\r\n        if (insertionAnnotations) {\r\n            possibleAnnotations =\r\n                possibleAnnotations.concat(insertionAnnotations);\r\n        }\r\n        const activeInsertionAnnotations = annotationPositions[String(start)];\r\n        if (activeInsertionAnnotations) {\r\n            possibleAnnotations = possibleAnnotations.concat(\r\n                activeInsertionAnnotations\r\n            );\r\n        }\r\n    } else {\r\n        // Only include annotations if they encompass the whole annotation\r\n        // i.e. not if activeAnnotation is a user annotation and combines\r\n        // annotated text with normal text.\r\n        let startAnnotations = annotationPositions[String(start)];\r\n        let endAnnotations = annotationPositions[String(end)];\r\n\r\n        if (startAnnotations) {\r\n            possibleAnnotations = startAnnotations;\r\n        }\r\n        if (endAnnotations) {\r\n            possibleAnnotations = possibleAnnotations.concat(endAnnotations);\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < possibleAnnotations.length; i++) {\r\n        const annotation = possibleAnnotations[i];\r\n        if (\r\n            annotation.start === activeAnnotation.start &&\r\n            annotation.length === activeAnnotation.length\r\n        ) {\r\n            // If an annotation is being edited, there will be a temporary annotation\r\n            // with the same natural id. If so, don't show the orignal version.\r\n            //\r\n            // We use natualId, as it normalises the id regardless of the original's\r\n            // save state. e.g. Upon editing a witness variant, a new annotation will be\r\n            // created. If the user is offline, that will not have been saved via the\r\n            // API yet. The user could then edit this new annotation, creating a temporary\r\n            // annotation based upon it. While this is being edited, the user could come\r\n            // back online and the save operation will succeed. This will mean the id of\r\n            // the temporary annotation will be different to the original edit, but naturalId\r\n            // will be the same.\r\n            if (\r\n                !temporaryAnnotation ||\r\n                annotation.naturalId !== temporaryAnnotation.naturalId\r\n            ) {\r\n                availableAnnotations.push(annotation);\r\n            }\r\n        } else if (!annotatedText.activeWitness.isWorking) {\r\n            if (\r\n                annotation.type === ANNOTATION_TYPES.pageBreak ||\r\n                annotation.type === ANNOTATION_TYPES.lineBreak\r\n            ) {\r\n                availableAnnotations.push(annotation);\r\n            }\r\n        }\r\n    }\r\n\r\n    availableAnnotations = _.uniqWith(\r\n        availableAnnotations,\r\n        (a, b) => a.id === b.id\r\n    );\r\n\r\n    return availableAnnotations;\r\n};\r\n\r\nconst getTemporaryAnnotation = (\r\n    state: AppState,\r\n    type: string,\r\n    user: User,\r\n    witness: Witness,\r\n    start: number,\r\n    length: number\r\n): TemporaryAnnotation | null => {\r\n    const annotations = reducers.getTemporaryAnnotations(\r\n        state,\r\n        witness.id,\r\n        start,\r\n        length,\r\n        type\r\n    );\r\n    if (annotations.length > 0) {\r\n        return annotations[0];\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\ntype StateProps = ControlsProps & {\r\n    questionsData: { [annotationId: AnnotationUniqueId]: Question[] },\r\n};\r\n\r\n// These are the props that are expected to be set and available in ownProps\r\ntype ContainerProps = {\r\n    annotationPositions: { [string]: Annotation[] },\r\n    annotatedText: AnnotatedText,\r\n    activeAnnotation: Annotation | null,\r\n    inline?: boolean,\r\n    firstSelectedSegment: TextSegment,\r\n    splitTextRect: ClientRect | null,\r\n    splitText: SplitText | null,\r\n};\r\n\r\nexport const mapStateToProps = (state: AppState, ownProps: ContainerProps) => {\r\n    const user = reducers.getUser(state);\r\n    const selectedText = reducers.getSelectedText(state);\r\n    const activeAnnotation = ownProps.activeAnnotation;\r\n    const inline = ownProps.inline;\r\n    let selectedWitness = reducers.getSelectedTextWitness(state);\r\n    if (!selectedWitness) {\r\n        if (selectedText) {\r\n            selectedWitness = reducers.getWorkingWitness(\r\n                state,\r\n                selectedText.id\r\n            );\r\n        }\r\n    }\r\n\r\n    if (!activeAnnotation || !selectedWitness) {\r\n        return {\r\n            annotationsData: null,\r\n            activeAnnotation: null,\r\n            baseAnnotation: null,\r\n            availableAnnotations: null,\r\n            user: user,\r\n            temporaryAnnotation: null,\r\n            inline: null,\r\n            firstSelectedSegment: null,\r\n            splitTextRect: null,\r\n            selectedWitness: null,\r\n        };\r\n    }\r\n\r\n    const temporaryVariant = getTemporaryAnnotation(\r\n        state,\r\n        ANNOTATION_TYPES.variant,\r\n        user,\r\n        selectedWitness,\r\n        activeAnnotation.start,\r\n        activeAnnotation.length\r\n    );\r\n\r\n    const annotations = getAvailableAnnotations(\r\n        ownProps.annotatedText,\r\n        activeAnnotation,\r\n        temporaryVariant,\r\n        ownProps.annotationPositions\r\n    );\r\n    const variants = annotations.filter(\r\n        (annotation: Annotation) => annotation.type === ANNOTATION_TYPES.variant\r\n    );\r\n    const sources = reducers.getSources(state);\r\n    const workingSourceName = reducers.getTranslation(\r\n        state,\r\n        \"annotation.workingEdition\",\r\n        BASE_NAME\r\n    );\r\n    let variantsData = getAnnotationsData(\r\n        variants,\r\n        sources,\r\n        workingSourceName,\r\n        selectedText\r\n    );\r\n\r\n    let baseAnnotation = null;\r\n    if (activeAnnotation.id == BASE_ANNOTATION_ID) {\r\n        baseAnnotation = activeAnnotation;\r\n    } else {\r\n        const [start, length] =\r\n            ownProps.annotatedText.getPositionOfAnnotation(activeAnnotation);\r\n        if (start === null || length === null) {\r\n            variantsData = null;\r\n        } else {\r\n            baseAnnotation = ownProps.annotatedText.getBaseAnnotation(\r\n                start,\r\n                length\r\n            );\r\n            const baseAnnotationData = getAnnotationsData(\r\n                [baseAnnotation],\r\n                sources,\r\n                workingSourceName\r\n            );\r\n            variantsData = [...baseAnnotationData, ...variantsData];\r\n        }\r\n    }\r\n\r\n    // make sure temporary annotation is first, then user created, then base annotation\r\n    if (variantsData) {\r\n        variantsData.sort((a, b) => {\r\n            if (a.isTemporary) {\r\n                return -1;\r\n            } else if (b.isTemporary) {\r\n                return 1;\r\n            } else if (a.userCreated) {\r\n                return -1;\r\n            } else if (b.userCreated) {\r\n                return 1;\r\n            } else if (a.annotation.id && b.annotation.id) {\r\n                return a.annotation.id - b.annotation.id;\r\n            } else {\r\n                return 1;\r\n            }\r\n        });\r\n    }\r\n\r\n    const notes: Array<Annotation> = annotations.filter(\r\n        (annotation: Annotation) => annotation.type === ANNOTATION_TYPES.note\r\n    );\r\n\r\n    const temporaryNotes = reducers.getTemporaryAnnotations(\r\n        state,\r\n        selectedWitness.id,\r\n        activeAnnotation.start,\r\n        activeAnnotation.length,\r\n        ANNOTATION_TYPES.note\r\n    );\r\n\r\n    const questionAnnotations: Array<Annotation> = annotations.filter(\r\n        (annotation: Annotation): boolean =>\r\n            annotation.type === ANNOTATION_TYPES.question\r\n    );\r\n    let questionsData = {};\r\n    if (questionAnnotations.length > 0) {\r\n        for (var i = 0; i < questionAnnotations.length; i++) {\r\n            const question = questionAnnotations[i];\r\n            questionsData[question.uniqueId] = {};\r\n            const isLoading = reducers.questionIsLoading(state, question);\r\n            questionsData[question.uniqueId][\"loading\"] = isLoading;\r\n            const questions = reducers.getQuestions(state, question.uniqueId);\r\n            questionsData[question.uniqueId][\"questions\"] = questions;\r\n        }\r\n    }\r\n\r\n    const temporaryQuestions = reducers.getTemporaryAnnotations(\r\n        state,\r\n        selectedWitness.id,\r\n        activeAnnotation.start,\r\n        activeAnnotation.length,\r\n        ANNOTATION_TYPES.question\r\n    );\r\n\r\n    let questionQuote = null;\r\n    if (temporaryQuestions.length > 0) {\r\n        const firstQuestion = temporaryQuestions[0];\r\n\r\n        let [start, end] =\r\n            ownProps.annotatedText.getPositionOfAnnotation(firstQuestion);\r\n        if (start) {\r\n            if (!end) {\r\n                end = start + 1;\r\n            }\r\n            const [startText, mainText, endText] =\r\n                ownProps.annotatedText.segmentedText.extractTextAroundPosition(\r\n                    start,\r\n                    end,\r\n                    [\"།\", \" \"]\r\n                );\r\n\r\n            const linkUrl = document.location.href;\r\n            questionQuote = (\r\n                <blockquote>\r\n                    {startText}\r\n                    <a href={linkUrl}>{mainText}</a>\r\n                    {endText}\r\n                </blockquote>\r\n            );\r\n        }\r\n    }\r\n    let fontSize = getTextFontSize(state);\r\n\r\n    return {\r\n        annotationsData: variantsData,\r\n        activeAnnotation: activeAnnotation,\r\n        baseAnnotation: baseAnnotation,\r\n        availableAnnotations: annotations,\r\n        user: user,\r\n        temporaryAnnotation: temporaryVariant,\r\n        inline: inline,\r\n        firstSelectedSegment: ownProps.firstSelectedSegment,\r\n        splitTextRect: ownProps.splitTextRect,\r\n        selectedWitness: selectedWitness,\r\n        notes: notes,\r\n        temporaryNotes: temporaryNotes,\r\n        questions: questionAnnotations,\r\n        temporaryQuestions: temporaryQuestions,\r\n        questionsData: questionsData,\r\n        questionQuote: questionQuote,\r\n        fontSize,\r\n    };\r\n};\r\n\r\nconst mergeProps = (stateProps: StateProps, dispatchProps, ownProps) => {\r\n    const { dispatch } = dispatchProps;\r\n\r\n    if (stateProps.questions.length > 0) {\r\n        for (var i = 0; i < stateProps.questions.length; i++) {\r\n            const question = stateProps.questions[i];\r\n            let loadQuestionData = true;\r\n            if (stateProps.questionsData.hasOwnProperty(question.uniqueId)) {\r\n                if (\r\n                    stateProps.questionsData[question.uniqueId].questions\r\n                        .length > 0 ||\r\n                    stateProps.questionsData[question.uniqueId].loading\r\n                ) {\r\n                    loadQuestionData = false;\r\n                }\r\n            }\r\n            if (loadQuestionData) {\r\n                dispatch(new actions.loadQuestion(question));\r\n            }\r\n        }\r\n    }\r\n\r\n    const addBreak = (\r\n        breakType: string,\r\n        selectBreak: boolean = false\r\n    ): (() => void) => {\r\n        return () => {\r\n            const location = ownProps.activeAnnotation;\r\n\r\n            const breakAnnotation = new Annotation(\r\n                null,\r\n                location.witness,\r\n                location.end + 1,\r\n                0,\r\n                null,\r\n                breakType,\r\n                stateProps.selectedWitness,\r\n                stateProps.user\r\n            );\r\n            let selectedWitnessData = reducers.dataFromWitness(\r\n                stateProps.selectedWitness\r\n            );\r\n\r\n            let actionsBatch = [];\r\n\r\n            actionsBatch.push(actions.createdAnnotation(breakAnnotation));\r\n            actionsBatch.push(\r\n                actions.appliedAnnotation(\r\n                    breakAnnotation.uniqueId,\r\n                    selectedWitnessData\r\n                )\r\n            );\r\n            if (selectBreak) {\r\n                actionsBatch.push(\r\n                    actions.changedActiveTextAnnotation(breakAnnotation)\r\n                );\r\n            } else {\r\n                actionsBatch.push(actions.changedActiveTextAnnotation(null));\r\n            }\r\n\r\n            dispatch(batchActions(actionsBatch));\r\n        };\r\n    };\r\n\r\n    const saveAnnotation = (\r\n        selectedAnnotation: TemporaryAnnotation,\r\n        content: string\r\n    ) => {\r\n        if (!selectedAnnotation.isTemporary) {\r\n            console.warn(\r\n                \"Tried to save a non-temporary annotation: %o\",\r\n                selectedAnnotation\r\n            );\r\n            return;\r\n        }\r\n\r\n        let selectedWitness = stateProps.selectedWitness;\r\n        let selectedWitnessData = reducers.dataFromWitness(selectedWitness);\r\n\r\n        const newAnnotation = new Annotation(\r\n            selectedAnnotation.id,\r\n            selectedAnnotation.witness,\r\n            selectedAnnotation.start,\r\n            selectedAnnotation.length,\r\n            content,\r\n            selectedAnnotation.type,\r\n            selectedAnnotation.creatorWitness,\r\n            stateProps.user,\r\n            selectedAnnotation.uniqueId,\r\n            selectedAnnotation.basedOn\r\n        );\r\n        newAnnotation.isSaved = selectedAnnotation.isSaved;\r\n        let actionsBatch = [];\r\n        let action = null;\r\n        if (newAnnotation.isSaved) {\r\n            action = actions.updatedAnnotation;\r\n        } else {\r\n            action = actions.createdAnnotation;\r\n        }\r\n        actionsBatch.push(action(newAnnotation));\r\n        actionsBatch.push(\r\n            actions.removedTemporaryAnnotation(selectedAnnotation)\r\n        );\r\n        // TODO: figure out what needs changing to handle note annotations\r\n        actionsBatch.push(\r\n            actions.appliedAnnotation(\r\n                newAnnotation.uniqueId,\r\n                selectedWitnessData\r\n            )\r\n        );\r\n        if (newAnnotation.type === ANNOTATION_TYPES.variant) {\r\n            actionsBatch.push(\r\n                actions.changedActiveTextAnnotation(newAnnotation)\r\n            );\r\n        }\r\n        dispatch(batchActions(actionsBatch));\r\n    };\r\n\r\n    return {\r\n        ...stateProps,\r\n        ...ownProps,\r\n        closeAnnotation: () => {\r\n            const activeAnnotation = stateProps.activeAnnotation;\r\n            if (activeAnnotation) {\r\n                const dismissTextAnnotation =\r\n                    actions.changedActiveTextAnnotation(null);\r\n                dispatch(dismissTextAnnotation);\r\n            }\r\n        },\r\n        didSelectAnnotation: (annotation: Annotation) => {\r\n            let selectedAnnotation: Annotation | null = null;\r\n            if (annotation.id == BASE_ANNOTATION_ID) {\r\n                selectedAnnotation = stateProps.baseAnnotation;\r\n            } else {\r\n                selectedAnnotation =\r\n                    _.find(\r\n                        stateProps.availableAnnotations,\r\n                        (value) => value.uniqueId == annotation.uniqueId\r\n                    ) || null;\r\n            }\r\n            let actionsBatch = [];\r\n            let selectedWitness = stateProps.selectedWitness;\r\n            // let selectedWitnessData = reducers.getWitnessData(\r\n            //     state,\r\n            //     selectedWitness.id\r\n            // );\r\n            let selectedWitnessData = reducers.dataFromWitness(selectedWitness);\r\n\r\n            if (annotation.uniqueId != stateProps.activeAnnotation.uniqueId) {\r\n                if (selectedWitness.isWorking) {\r\n                    if (annotation.id != BASE_ANNOTATION_ID) {\r\n                        actionsBatch.push(\r\n                            actions.appliedAnnotation(\r\n                                selectedAnnotation.uniqueId,\r\n                                selectedWitnessData\r\n                            )\r\n                        );\r\n                    }\r\n                    if (stateProps.activeAnnotation.id != BASE_ANNOTATION_ID) {\r\n                        actionsBatch.push(\r\n                            actions.removedAppliedAnnotation(\r\n                                stateProps.activeAnnotation.uniqueId,\r\n                                selectedWitnessData\r\n                            )\r\n                        );\r\n                    }\r\n                } else {\r\n                    if (\r\n                        stateProps.activeAnnotation.creatorWitness.id ===\r\n                        selectedWitness.id\r\n                    ) {\r\n                        // Replacing a default annotation\r\n\r\n                        // Currently selected annotation is a default\r\n                        // annotation. So need to remove that then\r\n                        // apply the newly selected annotation.\r\n\r\n                        actionsBatch.push(\r\n                            actions.removedDefaultAnnotation(\r\n                                stateProps.activeAnnotation.uniqueId,\r\n                                selectedWitnessData\r\n                            )\r\n                        );\r\n\r\n                        if (selectedAnnotation.id !== BASE_ANNOTATION_ID) {\r\n                            actionsBatch.push(\r\n                                actions.appliedAnnotation(\r\n                                    selectedAnnotation.uniqueId,\r\n                                    selectedWitnessData\r\n                                )\r\n                            );\r\n                        }\r\n                    } else {\r\n                        if (\r\n                            selectedAnnotation.creatorWitness.id ===\r\n                            selectedWitness.id\r\n                        ) {\r\n                            actionsBatch.push(\r\n                                actions.appliedDefaultAnnotation(\r\n                                    selectedAnnotation.uniqueId,\r\n                                    selectedWitnessData\r\n                                )\r\n                            );\r\n                        } else if (\r\n                            selectedAnnotation.id !== BASE_ANNOTATION_ID\r\n                        ) {\r\n                            actionsBatch.push(\r\n                                actions.appliedAnnotation(\r\n                                    selectedAnnotation.uniqueId,\r\n                                    selectedWitnessData\r\n                                )\r\n                            );\r\n                        }\r\n\r\n                        if (\r\n                            stateProps.activeAnnotation.id !==\r\n                            BASE_ANNOTATION_ID\r\n                        ) {\r\n                            actionsBatch.push(\r\n                                actions.removedAppliedAnnotation(\r\n                                    stateProps.activeAnnotation.uniqueId,\r\n                                    selectedWitnessData\r\n                                )\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                actionsBatch.push(\r\n                    actions.changedActiveTextAnnotation(selectedAnnotation)\r\n                );\r\n\r\n                dispatch(batchActions(actionsBatch));\r\n            }\r\n        },\r\n        editAnnotation: (selectedAnnotation: Annotation) => {\r\n            const basedOn =\r\n                selectedAnnotation.isWorkingAnnotation ||\r\n                selectedAnnotation.userCreated ||\r\n                selectedAnnotation.id === BASE_ANNOTATION_ID\r\n                    ? null\r\n                    : selectedAnnotation;\r\n            const temporaryAnnotation = new TemporaryAnnotation(\r\n                basedOn,\r\n                selectedAnnotation.witness,\r\n                selectedAnnotation.start,\r\n                selectedAnnotation.length,\r\n                selectedAnnotation.content,\r\n                selectedAnnotation.type,\r\n                stateProps.selectedWitness,\r\n                stateProps.user\r\n            );\r\n            if (selectedAnnotation.userCreated) {\r\n                // user annotations are updated\r\n                temporaryAnnotation.uniqueId = selectedAnnotation.uniqueId;\r\n                temporaryAnnotation.isSaved = selectedAnnotation.isSaved;\r\n            }\r\n\r\n            dispatch(\r\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\r\n            );\r\n        },\r\n        saveAnnotation: saveAnnotation,\r\n        cancelEditAnnotation: (selectedAnnotation: TemporaryAnnotation) => {\r\n            if (!selectedAnnotation.isTemporary) {\r\n                console.warn(\r\n                    \"Tried to call cancelEditAnnotation on a non-temporary annotation: %o\",\r\n                    selectedAnnotation\r\n                );\r\n                return;\r\n            }\r\n\r\n            const cancelAction =\r\n                actions.removedTemporaryAnnotation(selectedAnnotation);\r\n            dispatch(cancelAction);\r\n        },\r\n        deleteAnnotation: (annotation: Annotation) => {\r\n            let selectedWitness = stateProps.selectedWitness;\r\n            let selectedWitnessData = reducers.dataFromWitness(selectedWitness);\r\n            let actionsBatch = [];\r\n            if (annotation.userCreated) {\r\n                const deleteAction = actions.deletedAnnotation(\r\n                    annotation,\r\n                    selectedWitness\r\n                );\r\n                const removeAppliedAction = actions.removedAppliedAnnotation(\r\n                    annotation.uniqueId,\r\n                    selectedWitnessData\r\n                );\r\n                actionsBatch = [deleteAction, removeAppliedAction];\r\n            } else {\r\n                // Assume this is a default annotation that was\r\n                // automatically imported from external data\r\n                const removeDefaultAnnotation =\r\n                    actions.removedDefaultAnnotation(\r\n                        annotation.uniqueId,\r\n                        selectedWitnessData\r\n                    );\r\n                actionsBatch = [removeDefaultAnnotation];\r\n            }\r\n\r\n            if (stateProps.activeAnnotation.uniqueId === annotation.uniqueId) {\r\n                actionsBatch.push(actions.changedActiveTextAnnotation(null));\r\n            }\r\n\r\n            dispatch(batchActions(actionsBatch));\r\n        },\r\n        addNote: () => {\r\n            const activeAnnotation = ownProps.activeAnnotation;\r\n            const temporaryAnnotation = new TemporaryAnnotation(\r\n                null,\r\n                activeAnnotation.witness,\r\n                activeAnnotation.start,\r\n                activeAnnotation.length,\r\n                \"\",\r\n                ANNOTATION_TYPES.note,\r\n                stateProps.selectedWitness,\r\n                stateProps.user\r\n            );\r\n\r\n            dispatch(\r\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\r\n            );\r\n        },\r\n        editNote: (note: Annotation) => {\r\n            const temporaryAnnotation = new TemporaryAnnotation(\r\n                note,\r\n                note.witness,\r\n                note.start,\r\n                note.length,\r\n                note.content,\r\n                ANNOTATION_TYPES.note,\r\n                stateProps.selectedWitness,\r\n                stateProps.user\r\n            );\r\n\r\n            dispatch(\r\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\r\n            );\r\n        },\r\n        addPageBreak: addBreak(ANNOTATION_TYPES.pageBreak),\r\n        addLineBreak: addBreak(ANNOTATION_TYPES.lineBreak),\r\n        addQuestion: () => {\r\n            const activeAnnotation = ownProps.activeAnnotation;\r\n            const temporaryAnnotation = new TemporaryAnnotation(\r\n                null,\r\n                activeAnnotation.witness,\r\n                activeAnnotation.start,\r\n                activeAnnotation.length,\r\n                \"\",\r\n                ANNOTATION_TYPES.question,\r\n                stateProps.selectedWitness,\r\n                stateProps.user\r\n            );\r\n\r\n            dispatch(\r\n                actions.addedTemporaryAnnotation(temporaryAnnotation, true)\r\n            );\r\n        },\r\n        saveQuestion: (\r\n            question: TemporaryAnnotation,\r\n            title: string,\r\n            content: string\r\n        ) => {\r\n            let [start, end] =\r\n                ownProps.annotatedText.getPositionOfAnnotation(question);\r\n\r\n            const questionQuoteText = ReactDOMServer.renderToStaticMarkup(\r\n                stateProps.questionQuote\r\n            );\r\n            let questionText = questionQuoteText + content;\r\n\r\n            saveAnnotation(question, content);\r\n            const createdQuestionAction = actions.createdQuestion(\r\n                question,\r\n                title,\r\n                questionText\r\n            );\r\n            dispatch(createdQuestionAction);\r\n        },\r\n    };\r\n};\r\n\r\nconst AnnotationControlsContainer = connect(\r\n    mapStateToProps,\r\n    null,\r\n    mergeProps\r\n)(AnnotationControls);\r\n\r\nexport default AnnotationControlsContainer;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"header\":\"AnnotationControlsHeader---header\",\"Anotation_closeBtn\":\"AnnotationControlsHeader---Anotation_closeBtn\",\"edit\":\"AnnotationControlsHeader---edit\"};","// @flow\r\nimport React from \"react\";\r\nimport Button from \"components/UI/Button\";\r\nimport styles from \"./AnnotationControlsHeader.css\";\r\nimport PageBreakIcon from \"images/page_break_icon.svg\";\r\nimport NoteIcon from \"images/note.svg\";\r\nimport QuestionIcon from \"images/question_answer.svg\";\r\n\r\nimport PencilAltIcon from \"images/PencilAltIcon.svg\";\r\ntype Props = {\r\n    addPageBreak: null | (() => void),\r\n    addLineBreak: null | (() => void),\r\n    addNote: null | (() => void),\r\n    addQuestion: null | (() => void),\r\n    closeAnnotation: null | (() => void),\r\n    editAnnotationHandler: null | (() => void),\r\n    userLoggedIn: Boolean,\r\n};\r\nconst ICON_SIZE = 15;\r\nclass AnnotationControlsHeader extends React.Component<Props> {\r\n    // keyHandler;\r\n    constructor() {\r\n        super();\r\n    }\r\n    // componentDidMount() {\r\n    //     this.keyHandler = (e) => {\r\n    //         if (e.key === \"e\" || e.key === \"E\") {\r\n    //             this.props.editAnnotationHandler();\r\n    //         }\r\n    //         if (e.key === \"q\" || e.key === \"Q\") {\r\n    //             this.props.addQuestion();\r\n    //         }\r\n    //         if (e.key === \"l\" || e.key === \"L\") {\r\n    //             this.props.addLineBreak();\r\n    //         }\r\n    //         if (e.key === \"n\" || e.key === \"N\") {\r\n    //             this.props.addNote();\r\n    //         }\r\n    //         if (e.key === \"p\" || e.key === \"P\") {\r\n    //             this.props.addPageBreak();\r\n    //         }\r\n    //     };\r\n    //     document.addEventListener(\"keyup\", this.keyHandler, { once: true });\r\n    // }\r\n    // componentWillUnmount() {\r\n    //     document.removeEventListener(\"keyup\", this.keyHandler);\r\n    // }\r\n    render() {\r\n        const allowPageBreak = this.props.addPageBreak != null;\r\n        const allowLineBreak = this.props.addLineBreak != null;\r\n        return (\r\n            <>\r\n                <div className={styles.header}>\r\n                    <Button\r\n                        noBezel={true}\r\n                        icon={\r\n                            <NoteIcon\r\n                                width={ICON_SIZE}\r\n                                height={ICON_SIZE}\r\n                                style={{ fill: \"#fff\" }}\r\n                            />\r\n                        }\r\n                        backgroundColor=\"transparent\"\r\n                        // accessoryType={this.props.addNote ? \"ADD\" : null}\r\n                        onClick={this.props.addNote}\r\n                        disabled={this.props.addNote ? false : true}\r\n                        align=\"center\"\r\n                        tooltipTitle=\"Note\"\r\n                        shortcut=\"n\"\r\n                    />\r\n                    <Button\r\n                        noBezel={true}\r\n                        icon={\r\n                            <QuestionIcon\r\n                                width={ICON_SIZE}\r\n                                height={ICON_SIZE}\r\n                                style={{ fill: \"#fff\" }}\r\n                            />\r\n                        }\r\n                        // accessoryType={this.props.addQuestion ? \"ADD\" : null}\r\n                        onClick={this.props.addQuestion}\r\n                        disabled={this.props.addQuestion ? false : true}\r\n                        align=\"left\"\r\n                        backgroundColor=\"transparent\"\r\n                        tooltipTitle=\"Question\"\r\n                        shortcut=\"q\"\r\n                    />\r\n                    <Button\r\n                        noBezel={true}\r\n                        color=\"#fff\"\r\n                        fontSize={`${ICON_SIZE}px`}\r\n                        icon=\"&#182;\"\r\n                        // accessoryType={allowLineBreak ? \"ADD\" : null}\r\n                        onClick={this.props.addLineBreak}\r\n                        disabled={!allowLineBreak}\r\n                        align=\"left\"\r\n                        backgroundColor=\"transparent\"\r\n                        tooltipTitle=\"LineBreak\"\r\n                        shortcut=\"l\"\r\n                    />\r\n                    <Button\r\n                        noBezel={true}\r\n                        icon={\r\n                            <PageBreakIcon\r\n                                width={ICON_SIZE}\r\n                                height={ICON_SIZE}\r\n                                style={{ fill: \"#fff\" }}\r\n                            />\r\n                        }\r\n                        // accessoryType={allowPageBreak ? \"ADD\" : null}\r\n                        onClick={this.props.addPageBreak}\r\n                        disabled={!allowPageBreak}\r\n                        align=\"left\"\r\n                        backgroundColor=\"transparent\"\r\n                        tooltipTitle=\"PageBreak\"\r\n                        shortcut=\"p\"\r\n                    />\r\n\r\n                    <Button\r\n                        onClick={this.props.editAnnotationHandler}\r\n                        // className={styles.edit}\r\n                        backgroundColor=\"transparent\"\r\n                        noBezel={true}\r\n                        icon={\r\n                            <PencilAltIcon\r\n                                width={ICON_SIZE}\r\n                                height={ICON_SIZE}\r\n                                style={{ fill: \"#fff\" }}\r\n                            />\r\n                        }\r\n                        tooltipTitle=\"Edit\"\r\n                        shortcut=\"e\"\r\n                    />\r\n                </div>\r\n                {/* <div\r\n                    onClick={() => this.props.closeAnnotation()}\r\n                    className={styles.Anotation_closeBtn}\r\n                >\r\n                    x\r\n                </div> */}\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nexport default AnnotationControlsHeader;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"heading\":\"AnnotationControlsHeading---heading\",\"title\":\"AnnotationControlsHeading---title\",\"button\":\"AnnotationControlsHeading---button\"};","import React from \"react\";\r\nimport { FormattedMessage } from \"react-intl\";\r\nimport { injectIntl } from \"react-intl\";\r\nimport styles from \"./AnnotationControlsHeading.css\";\r\nimport AddButton from \"./AddButton\";\r\n\r\ntype Props = {\r\n    titleId: string,\r\n    buttonOnClick?: () => void,\r\n    buttonTitleId?: string,\r\n    intl: { formatMessage: ({ [id: string]: string }) => string }\r\n};\r\n\r\nclass AnnotationControlsHeading extends React.Component<Props> {\r\n    render() {\r\n        let button = null;\r\n        if (this.props.buttonOnClick) {\r\n            const title = this.props.buttonTitleId\r\n                ? this.props.intl.formatMessage({\r\n                      id: this.props.buttonTitleId\r\n                  })\r\n                : \"\";\r\n            button = (\r\n                <AddButton title={title} onClick={this.props.buttonOnClick} />\r\n            );\r\n        }\r\n        return (\r\n            <h3 className={styles.heading}>\r\n                <span className={styles.title}>\r\n                    <FormattedMessage id={this.props.titleId} />\r\n                </span>\r\n                {button && <div className={styles.button}>{button}</div>}\r\n            </h3>\r\n        );\r\n    }\r\n}\r\n\r\nexport default injectIntl(AnnotationControlsHeading);\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"annotationDetail\":\"AnnotationDetail---annotationDetail\",\"active\":\"AnnotationDetail---active\",\"annotationHeader\":\"AnnotationDetail---annotationHeader\",\"activeIcon\":\"AnnotationDetail---activeIcon\",\"editing\":\"AnnotationDetail---editing\",\"actionButtons\":\"AnnotationDetail---actionButtons\",\"edit\":\"AnnotationDetail---edit\",\"editImage\":\"AnnotationDetail---editImage\",\"save\":\"AnnotationDetail---save\",\"cancel\":\"AnnotationDetail---cancel\"};","// @flow\r\nimport React, { useState } from \"react\";\r\nimport classnames from \"classnames\";\r\nimport { FormattedMessage } from \"react-intl\";\r\nimport styles from \"./AnnotationDetail.css\";\r\nimport type { AnnotationData } from \"api\";\r\nimport CheckIcon from \"images/check_circle.svg\";\r\nimport colours from \"css/colour.css\";\r\nimport ApplyTooltip from \"../UI/ApplyTooltip\";\r\nexport type Props = {\r\n    annotationData: AnnotationData,\r\n    isActive: boolean,\r\n    selectAnnotationHandler: () => void,\r\n    isLoggedIn: boolean,\r\n    editAnnotationHandler: () => void,\r\n    fontSize: Number,\r\n    isWorkingSection: boolean,\r\n};\r\nconst MAXIMUM_TEXT_LENGTH = 250;\r\n\r\nconst AnnotationDetail = (props: Props) => {\r\n    const [imageUrl, setImageUrl] = useState(null);\r\n\r\n    function longest_str_in_array(arra) {\r\n        var max_str = arra[0].length;\r\n        var ans = arra[0].length;\r\n        for (var i = 0; i < arra.length; i++) {\r\n            var maxi = arra[i].length;\r\n            if (maxi > max_str) {\r\n                ans = arra[i].length;\r\n                max_str = maxi;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n    function mergeArray(arr) {\r\n        var textCount = arr.length;\r\n        var maxPerLine = 55;\r\n\r\n        for (\r\n            var i = 0;\r\n            i < Math.ceil(arr.join().length / maxPerLine) + 1;\r\n            i++\r\n        ) {\r\n            if (arr[i] && arr[i + 1] && arr[i].length < maxPerLine) {\r\n                arr[i] = arr[i] + \" \" + arr[i + 1];\r\n                arr.splice(i + 1, 1);\r\n                mergeArray(arr);\r\n            } else if (arr[i] && arr[i + 1] && arr[i].length > maxPerLine) {\r\n                // code to cut selected text should be here\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    let desc = (\r\n        <p>\r\n            &lt;\r\n            <FormattedMessage id=\"annotation.delete\" />\r\n            &gt;\r\n        </p>\r\n    );\r\n\r\n    let content = props.annotationData.content;\r\n\r\n    if (content.trim() !== \"\") {\r\n        if (content.length > MAXIMUM_TEXT_LENGTH) {\r\n            content = content.substr(0, MAXIMUM_TEXT_LENGTH) + \"…\";\r\n        }\r\n        // content variable is the selected trimmed context\r\n        desc = <p>{content}</p>;\r\n    }\r\n\r\n    let classes = [styles.annotationDetail];\r\n\r\n    if (props.isActive) {\r\n        classes.push(styles.active);\r\n    }\r\n\r\n    let className = classnames(...classes);\r\n    return (\r\n        <div className={className} onClick={props.selectAnnotationHandler}>\r\n            <div className={styles.annotationHeader}>\r\n                {props.isActive && (\r\n                    <div className={styles.activeIcon}>\r\n                        <CheckIcon\r\n                            style={{ fill: colours.activeButton }}\r\n                            width={15}\r\n                            height={15}\r\n                        />\r\n                    </div>\r\n                )}\r\n                <h3>{props.annotationData.name}</h3>\r\n                {props.isLoggedIn && props.isActive && (\r\n                    <button\r\n                        style={{ display: \"none\" }}\r\n                        className={styles.edit}\r\n                        onClick={props.editAnnotationHandler}\r\n                        id=\"editBtn\"\r\n                    ></button>\r\n                )}\r\n            </div>\r\n\r\n            {!props.isWorkingSection && desc}\r\n\r\n            {/* {props.isWorkingSection  && <ShareButton props={props}/>} */}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default AnnotationDetail;\r\n","// @flow\r\nimport React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport { FormattedMessage } from \"react-intl\";\r\nimport styles from \"./AnnotationDetail.css\";\r\nimport type { Props as AnnotationDetailProps } from \"./AnnotationDetail\";\r\n\r\nexport type Props = AnnotationDetailProps & {\r\n    saveAnnotationHandler: (text: string) => void,\r\n    cancelAnnotationHandler: () => void,\r\n};\r\n\r\nconst AnnotationDetailEdit = (props: Props) => {\r\n    let content = props.annotationData.content;\r\n    let classes = [styles.annotationDetail];\r\n    let textarea = null;\r\n\r\n    if (props.isActive) {\r\n        classes.push(styles.active);\r\n    }\r\n    let auto_grow = (element) => {\r\n        textarea.style.height = \"5px\";\r\n        textarea.style.height = textarea.scrollHeight + \"px\";\r\n    };\r\n    let className = classnames(...classes);\r\n    return (\r\n        <div className={className}>\r\n            <h3>{props.annotationData.name}</h3>\r\n\r\n            <div className={styles.editing}>\r\n                <textarea\r\n                    defaultValue={content}\r\n                    autoFocus={true}\r\n                    onInput={auto_grow}\r\n                    ref={(ta) => (textarea = ta)}\r\n                />\r\n                <div className={styles.actionButtons}>\r\n                    <div\r\n                        className={styles.save}\r\n                        onClick={() => {\r\n                            if (textarea) {\r\n                                props.saveAnnotationHandler(textarea.value);\r\n                            }\r\n                        }}\r\n                    >\r\n                        <FormattedMessage id=\"annotation.save\" />\r\n                    </div>\r\n                    <div\r\n                        className={styles.cancel}\r\n                        onClick={props.cancelAnnotationHandler}\r\n                    >\r\n                        <FormattedMessage id=\"annotation.cancel\" />\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default AnnotationDetailEdit;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"name\":\"AnswerView---name\",\"answer\":\"AnswerView---answer\"};","import React from \"react\";\r\nimport styles from \"./AnswerView.css\";\r\nimport controlStyles from \"./AnnotationControls.css\";\r\nimport buttonStyles from \"./Button.css\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport Answer from \"lib/Answer\";\r\nimport { FormattedMessage, FormattedDate } from \"react-intl\";\r\nimport classnames from \"classnames\";\r\n\r\ntype Props = {\r\n    answer: Answer\r\n};\r\n\r\nexport default class AnswerView extends React.Component<Props> {\r\n    render() {\r\n        return (\r\n            <div className={styles.answer}>\r\n                <p\r\n                    className={controlStyles.text}\r\n                    dangerouslySetInnerHTML={{\r\n                        __html: this.props.answer.content\r\n                    }}\r\n                />\r\n                <p className={controlStyles.subTitle}>\r\n                    <FormattedMessage id=\"question.answeredBy\" />{\" \"}\r\n                    {this.props.answer.name},{\" \"}\r\n                    <FormattedDate value={this.props.answer.created} />\r\n                </p>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"save\":\"Button---save\",\"cancel\":\"Button---cancel\",\"buttonContainer\":\"Button---buttonContainer\"};","// @flow\r\nimport * as React from \"react\";\r\nimport GraphemeSplitter from \"grapheme-splitter\";\r\nimport reactStringReplace from \"react-string-replace\";\r\n\r\ntype Props = {\r\n    string: string,\r\n    highlightClass: string,\r\n    stringClass?: string,\r\n    searchTerm?: string\r\n};\r\n\r\nexport default class HighlightedString extends React.Component<Props> {\r\n    constructor(props: Props) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        const string = this.props.string;\r\n        let nameHtml = string;\r\n        let stringClass = this.props.stringClass || \"\";\r\n        if (this.props.searchTerm) {\r\n            const searchTerm = this.props.searchTerm;\r\n            const splitter = new GraphemeSplitter();\r\n            const graphemes = splitter.splitGraphemes(string);\r\n            const start = string.indexOf(searchTerm);\r\n            const end = start + searchTerm.length;\r\n            let position = 0;\r\n            let foundGraphemes = \"\";\r\n            if (start > -1) {\r\n                for (let i = 0; i < graphemes.length; i++) {\r\n                    let grapheme = graphemes[i];\r\n                    if (position >= start && position < end) {\r\n                        foundGraphemes += grapheme;\r\n                    }\r\n                    position += grapheme.length;\r\n                }\r\n            }\r\n            if (foundGraphemes.length > 0) {\r\n                nameHtml = reactStringReplace(\r\n                    string,\r\n                    foundGraphemes,\r\n                    (match, i) => (\r\n                        <span className={this.props.highlightClass} key={`highlight-${i}`}>\r\n                            {match}\r\n                        </span>\r\n                    )\r\n                );\r\n            }\r\n        }\r\n        return <span className={stringClass}>{nameHtml}</span>;\r\n    }\r\n}\r\n","import React, { useCallback, useEffect } from \"react\";\r\nimport RefreshIcon from \"@mui/icons-material/Refresh\";\r\nimport { IconButton } from \"@mui/material\";\r\nfunction Refresh({ isSecondWindowOpen }) {\r\n    const handleRefresh = useCallback(() => {\r\n        let updatelistBtn = document.getElementById(\"updateList\");\r\n\r\n        if (updatelistBtn) updatelistBtn.click();\r\n    }, [isSecondWindowOpen]);\r\n\r\n    useEffect(() => {\r\n        let timer = setTimeout(() => {\r\n            handleRefresh();\r\n        }, 500);\r\n        return () => clearTimeout(timer);\r\n    }, [isSecondWindowOpen]);\r\n\r\n    return (\r\n        <IconButton\r\n            variant=\"text\"\r\n            size=\"small\"\r\n            disableRipple\r\n            onClick={handleRefresh}\r\n        >\r\n            <RefreshIcon />\r\n        </IconButton>\r\n    );\r\n}\r\n\r\nexport default Refresh;\r\n","import React from \"react\";\r\nimport SearchIcon from \"@mui/icons-material/Search\";\r\nimport { IconButton } from \"@mui/material\";\r\n\r\nfunction Search({ handleWindowSearch }) {\r\n    return (\r\n        <IconButton size=\"small\" variant=\"text\" onClick={handleWindowSearch}>\r\n            <SearchIcon />\r\n        </IconButton>\r\n    );\r\n}\r\n\r\nexport default Search;\r\n","import React, { useRef } from \"react\";\r\nimport {\r\n    AutoSizer,\r\n    CellMeasurer,\r\n    CellMeasurerCache,\r\n    List,\r\n} from \"react-virtualized\";\r\nimport HighlightedString from \"./HighlightedString\";\r\nimport styles from \"./SearchStyle.css\";\r\n\r\nfunction SearchList(props) {\r\n    const { handleListItemClick, searchValue, results, selectedText } = props;\r\n    let listRef = useRef();\r\n    let cache = useRef(\r\n        new CellMeasurerCache({\r\n            fixedWidth: true,\r\n            defaultHeight: 100,\r\n        })\r\n    );\r\n    let rowRenderer = ({ key, index, parent, style }) => {\r\n        let result = results[index];\r\n        return (\r\n            <CellMeasurer\r\n                key={`listkeys2-${key}`}\r\n                cache={cache.current}\r\n                parent={parent}\r\n                columnIndex={0}\r\n                rowIndex={index}\r\n            >\r\n                <div style={style}>\r\n                    {results.length > 0 && (\r\n                        <div\r\n                            className={styles.searchListItem}\r\n                            onClick={() => handleListItemClick(result[0])}\r\n                        >\r\n                            <HighlightedString\r\n                                string={result[1]}\r\n                                highlightClass={styles.highlight}\r\n                                searchTerm={searchValue}\r\n                            />\r\n                        </div>\r\n                    )}\r\n                </div>\r\n            </CellMeasurer>\r\n        );\r\n    };\r\n\r\n    if (!results) return null;\r\n    return (\r\n        <>\r\n            <AutoSizer>\r\n                {({ height, width }) => (\r\n                    <List\r\n                        ref={listRef}\r\n                        height={height}\r\n                        rowCount={results?.length}\r\n                        rowHeight={cache.current.rowHeight}\r\n                        deferredMeasurementCache={cache.current}\r\n                        rowRenderer={rowRenderer}\r\n                        width={width}\r\n                        overscanRowCount={1}\r\n                    ></List>\r\n                )}\r\n            </AutoSizer>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default SearchList;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"highlight\":\"SearchStyle---highlight\",\"searchListItem\":\"SearchStyle---searchListItem\"};","import React, { useState, useEffect } from \"react\";\r\nimport WrenchIcon from \"images/wrench.svg\";\r\nimport Slider from \"../../UI/Slider\";\r\nimport CheckIcon from \"@mui/icons-material/Check\";\r\nimport useLocalStorage from \"components/utility/useLocalStorage\";\r\nimport {\r\n    IconButton,\r\n    MenuList,\r\n    MenuItem,\r\n    Grow,\r\n    Divider,\r\n    Typography,\r\n    Box,\r\n    ClickAwayListener,\r\n} from \"@mui/material\";\r\nimport { FONT_LIST } from \"app_constants\";\r\nfunction Settings(props) {\r\n    let [showOption, setShowOption] = useState(false);\r\n    let [fontSelect, setFontSelect] = useLocalStorage(\r\n        \"WindowOneFont\",\r\n        \"Tibetan\"\r\n    );\r\n    useEffect(() => {\r\n        document.body.style.setProperty(\"--tibetan-fonts\", fontSelect);\r\n    }, []);\r\n    const handleClick = () => {\r\n        setShowOption((prev) => !prev);\r\n    };\r\n    const handlefont = (value) => {\r\n        setFontSelect(value);\r\n        document.body.style.setProperty(\"--tibetan-fonts\", `${value}`);\r\n        let update = document.getElementById(\"updateList\");\r\n\r\n        setTimeout(() => {\r\n            update.click();\r\n        }, 800);\r\n        setShowOption(false);\r\n    };\r\n\r\n    return (\r\n        <ClickAwayListener onClickAway={() => setShowOption(false)}>\r\n            <Box position=\"relative\">\r\n                <IconButton onClick={handleClick} size=\"small\" variant=\"text\">\r\n                    <WrenchIcon height={20} width={20} fill=\"currentColor\" />\r\n                </IconButton>\r\n                <Grow in={showOption}>\r\n                    <MenuList\r\n                        dense\r\n                        sx={{\r\n                            position: \"absolute\",\r\n                            right: 0,\r\n                            zIndex: 2,\r\n                            top: 40,\r\n                            bgcolor: \"heading.main\",\r\n                        }}\r\n                    >\r\n                        <Slider\r\n                            max={20}\r\n                            min={7}\r\n                            initialvalue={props.textFontSize}\r\n                            changeSize={props.onChangedFontSize}\r\n                        />\r\n                        <Divider />\r\n                        <FontSelection\r\n                            selectFont={handlefont}\r\n                            selectedfont={fontSelect}\r\n                        />\r\n                        <MenuItem onClick={() => props.onExport()}>\r\n                            <Typography variant=\"subtitle2\">\r\n                                Export Document\r\n                            </Typography>\r\n                        </MenuItem>\r\n                    </MenuList>\r\n                </Grow>\r\n            </Box>\r\n        </ClickAwayListener>\r\n    );\r\n}\r\n\r\nexport default Settings;\r\n\r\nconst FontSelection = ({ selectFont, selectedfont }) => {\r\n    let fontAvailable = FONT_LIST || [];\r\n\r\n    return (\r\n        <Box textAlign={\"center\"}>\r\n            <span>Font:</span>{\" \"}\r\n            <select\r\n                onChange={(e) => selectFont(e.target.value)}\r\n                value={selectedfont}\r\n            >\r\n                {fontAvailable.map((font, index) => {\r\n                    return (\r\n                        <option key={index + \"-fontselect\"} value={font}>\r\n                            {font}\r\n                        </option>\r\n                    );\r\n                })}\r\n            </select>\r\n        </Box>\r\n    );\r\n};\r\n","import React from \"react\";\r\nimport { IconButton } from \"@mui/material\";\r\nimport MenuIcon from \"@mui/icons-material/Menu\";\r\nimport ClearIcon from \"@mui/icons-material/Clear\";\r\nfunction TableOfContent({ changeShowTableContent, showTableContent }) {\r\n    function handleClick() {\r\n        changeShowTableContent(!showTableContent);\r\n    }\r\n    return (\r\n        <React.Fragment>\r\n            <IconButton onClick={handleClick}>\r\n                {showTableContent ? <ClearIcon /> : <MenuIcon />}\r\n            </IconButton>\r\n        </React.Fragment>\r\n    );\r\n}\r\n\r\nexport default TableOfContent;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"note\":\"Note---note\",\"header\":\"Note---header\",\"info\":\"Note---info\",\"content\":\"Note---content\",\"delete\":\"Note---delete\"};","import React from \"react\";\r\nimport styles from \"./Note.css\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport FormattedDate from \"react-intl\";\r\nimport { Box, IconButton } from \"@mui/material\";\r\nimport DeleteIcon from \"@mui/icons-material/Delete\";\r\ntype Props = {\r\n    note: Annotation,\r\n    delete?: (note: Annotation) => void,\r\n    edit?: (note: Annotation) => void,\r\n};\r\n\r\nexport default class Note extends React.Component<Props> {\r\n    delete() {\r\n        if (this.props.delete) {\r\n            this.props.delete(this.props.note);\r\n        }\r\n    }\r\n\r\n    edit() {\r\n        if (this.props.edit) {\r\n            this.props.edit(this.props.note);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <Box className={styles.note} sx={{ boxShadow: 2 }}>\r\n                <p>Note:</p>\r\n                <div className={styles.header}>\r\n                    <h4 className={styles.info}>\r\n                        {this.props.note.creatorUser.name}\r\n                    </h4>\r\n                    {this.props.delete && (\r\n                        <div\r\n                            className={styles.delete}\r\n                            onClick={this.delete.bind(this)}\r\n                        >\r\n                            <IconButton aria-label=\"delete\" size=\"small\">\r\n                                <DeleteIcon fontSize=\"inherit\" />\r\n                            </IconButton>\r\n                        </div>\r\n                    )}\r\n                </div>\r\n                <div className={styles.content} onClick={this.edit.bind(this)}>\r\n                    {this.props.note.content}\r\n                </div>\r\n            </Box>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"editorContainer\":\"NoteEditor---editorContainer\",\"textEditor\":\"NoteEditor---textEditor\"};","//@flow\r\nimport React from \"react\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport styles from \"./NoteEditor.css\";\r\nimport buttonStyles from \"./Button.css\";\r\nimport { FormattedMessage } from \"react-intl\";\r\n\r\ntype Props = {\r\n    note: Annotation,\r\n    saveNote: (note: Annotation, content: string) => void,\r\n    cancel: () => void\r\n};\r\n\r\ntype State = {\r\n    content: string\r\n};\r\n\r\nexport default class NoteEditor extends React.Component<Props, State> {\r\n    textarea: HTMLTextAreaElement | null;\r\n\r\n    constructor(props: Props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            content: props.note.content\r\n        };\r\n    }\r\n\r\n    save() {\r\n        const content = this.textarea ? this.textarea.value : \"\";\r\n        this.props.saveNote(this.props.note, content);\r\n    }\r\n\r\n    cancel() {\r\n        this.props.cancel();\r\n    }\r\n\r\n    handleChange(e: Event) {\r\n        const content =\r\n            e.target instanceof HTMLTextAreaElement ? e.target.value : \"\";\r\n        this.setState((prevState, props) => {\r\n            return {\r\n                content: content\r\n            };\r\n        });\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className={styles.editorContainer}>\r\n                <textarea\r\n                    className={styles.textEditor}\r\n                    ref={(textarea: HTMLTextAreaElement | null) =>\r\n                        (this.textarea = textarea)\r\n                    }\r\n                    value={this.state.content}\r\n                    onChange={this.handleChange.bind(this)}\r\n                />\r\n                <div className={buttonStyles.buttonContainer}>\r\n                    <div\r\n                        className={buttonStyles.save}\r\n                        onClick={this.save.bind(this)}\r\n                    >\r\n                        <FormattedMessage id=\"annotation.save\" />\r\n                    </div>\r\n                    <div\r\n                        className={buttonStyles.cancel}\r\n                        onClick={this.cancel.bind(this)}\r\n                    >\r\n                        <FormattedMessage id=\"annotation.cancel\" />\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"editorContainer\":\"QuestionEditor---editorContainer\",\"textEditor\":\"QuestionEditor---textEditor\"};","import React from \"react\";\r\nimport styles from \"./QuestionEditor.css\";\r\nimport buttonStyles from \"./Button.css\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport { FormattedMessage } from \"react-intl\";\r\n\r\ntype Props = {\r\n    question: Annotation,\r\n    questionQuote: React.Element<typeof React.Component>,\r\n    defaultTitle: string,\r\n    saveQuestion: (\r\n        question: Annotation,\r\n        title: string,\r\n        content: string\r\n    ) => void,\r\n    cancel: () => void\r\n};\r\n\r\ntype State = {\r\n    content: string\r\n};\r\n\r\nexport default class QuestionEditor extends React.Component<Props> {\r\n    textarea: HTMLTextAreaElement | null;\r\n\r\n    constructor(props: Props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            content: props.question.content\r\n        };\r\n    }\r\n\r\n    save() {\r\n        const content = this.textarea ? this.textarea.value : \"\";\r\n\r\n        this.props.saveQuestion(\r\n            this.props.question,\r\n            this.props.defaultTitle,\r\n            content\r\n        );\r\n    }\r\n\r\n    cancel() {\r\n        this.props.cancel();\r\n    }\r\n\r\n    handleChange(e: Event) {\r\n        const content =\r\n            e.target instanceof HTMLTextAreaElement ? e.target.value : \"\";\r\n        this.setState((prevState, props) => {\r\n            return {\r\n                content: content\r\n            };\r\n        });\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className={styles.editorContainer}>\r\n                <div>{this.props.questionQuote}</div>\r\n                <textarea\r\n                    className={styles.textEditor}\r\n                    ref={(textarea: HTMLTextAreaElement | null) =>\r\n                        (this.textarea = textarea)\r\n                    }\r\n                    value={this.state.content}\r\n                    onChange={this.handleChange.bind(this)}\r\n                />\r\n                <div className={buttonStyles.buttonContainer}>\r\n                    <div\r\n                        className={buttonStyles.save}\r\n                        onClick={this.save.bind(this)}\r\n                    >\r\n                        <FormattedMessage id=\"annotation.save\" />\r\n                    </div>\r\n                    <div\r\n                        className={buttonStyles.cancel}\r\n                        onClick={this.cancel.bind(this)}\r\n                    >\r\n                        <FormattedMessage id=\"annotation.cancel\" />\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"question\":\"QuestionView---question\",\"threadLink\":\"QuestionView---threadLink\"};","import React from \"react\";\r\nimport styles from \"./QuestionView.css\";\r\nimport controlStyles from \"./AnnotationControls.css\";\r\nimport buttonStyles from \"./Button.css\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport Question from \"lib/Question\";\r\nimport AnswerView from \"./AnswerView\";\r\nimport { FormattedMessage, FormattedDate } from \"react-intl\";\r\nimport classnames from \"classnames\";\r\nimport { QUESTION_URL } from \"app_constants\";\r\nimport { Box } from \"@mui/material\";\r\n\r\ntype Props = {\r\n    question: Question,\r\n};\r\n\r\nexport default class QuestionView extends React.Component<Props> {\r\n    render() {\r\n        const topicUrl = QUESTION_URL + this.props.question.topicId;\r\n        let answerViews = [];\r\n        let answers = this.props.question.answers;\r\n        console.log(answers);\r\n        for (let i = 0; i < answers.length; i++) {\r\n            const answer = answers[i];\r\n            answerViews.push(\r\n                <AnswerView answer={answer} key={\"answer_\" + answer.created} />\r\n            );\r\n        }\r\n        const name =\r\n            this.props.question.name.length > 0\r\n                ? this.props.question.name\r\n                : this.props.question.username;\r\n\r\n        return (\r\n            <Box\r\n                className={classnames(styles.question, controlStyles.padding)}\r\n                sx={{ boxShadow: 2 }}\r\n            >\r\n                <span\r\n                    className={classnames(\r\n                        styles.threadLink,\r\n                        controlStyles.text\r\n                    )}\r\n                >\r\n                    <a href={topicUrl} target=\"_blank\">\r\n                        <FormattedMessage id=\"question.viewThread\" />\r\n                    </a>\r\n                </span>\r\n                <p\r\n                    className={controlStyles.text}\r\n                    dangerouslySetInnerHTML={{\r\n                        __html: this.props.question.content,\r\n                    }}\r\n                />\r\n                <p className={controlStyles.subTitle}>\r\n                    {name},{\" \"}\r\n                    <FormattedDate value={this.props.question.created} />\r\n                </p>\r\n                {answerViews}\r\n            </Box>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"loading\":\"QuestionsLoading---loading\"};","import React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport styles from \"./QuestionsLoading.css\";\r\nimport controlStyles from \"./AnnotationControls.css\";\r\nimport buttonStyles from \"./Button.css\";\r\nimport { FormattedMessage } from \"react-intl\";\r\nimport Loader from \"react-loader\";\r\n\r\nexport default class QuestionsLoading extends React.Component<Props> {\r\n    render() {\r\n        return (\r\n            <div className={classnames(styles.loading, controlStyles.text)}>\r\n                <Loader\r\n                    loaded={false}\r\n                    scale={0.25}\r\n                    position=\"relative\"\r\n                    top=\"50%\"\r\n                    left=\"50%\"\r\n                    lines={9}\r\n                    width={8}\r\n                    length={8}\r\n                    radius={14}\r\n                />\r\n                Loading questions...\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"selectVersion\":\"SelectVersion---selectVersion\",\"selectEmpty\":\"SelectVersion---selectEmpty\",\"selectOptions\":\"SelectVersion---selectOptions\",\"styled-select\":\"SelectVersion---styled-select\"};","// @flow\r\nimport React, { useState, useEffect, memo } from \"react\";\r\nimport _ from \"lodash\";\r\nimport classnames from \"classnames\";\r\nimport { FormattedMessage, injectIntl } from \"react-intl\";\r\nimport styles from \"./SelectVersion.css\";\r\nimport Witness from \"lib/Witness\";\r\nimport { NativeSelect } from \"@mui/material\";\r\nexport type Props = {\r\n    witnesses: Witness[],\r\n    activeWitness: Witness | null,\r\n    onSelectedWitness: (witness: Witness) => void,\r\n    user: {},\r\n};\r\n\r\nconst SelectVersion = (props: Props) => {\r\n    let witnesses = [];\r\n    let tabName = \"\";\r\n    let r = \"\";\r\n    let classes = [];\r\n    if (props.witnesses && props.activeWitness) {\r\n        r = props.witnesses.findIndex((l) => l.id === props.activeWitness.id);\r\n        witnesses = props.witnesses.map((witness) => witness);\r\n        witnesses.sort((a, b) => {\r\n            if (a.isWorking) {\r\n                return -1;\r\n            }\r\n            if (b.isWorking) {\r\n                return 1;\r\n            }\r\n            if (a.isBase) {\r\n                return -1;\r\n            }\r\n            if (b.isBase) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n        witnesses = witnesses.sort((a, b) => a.id - b.id);\r\n    }\r\n\r\n    const handleChangeWitness = (e) => {\r\n        if (!_.isEmpty(witnesses)) {\r\n            props.onSelectedWitness(witnesses[e.target.value]);\r\n        }\r\n    };\r\n\r\n    if (witnesses.length === 0) return null;\r\n\r\n    return (\r\n        <NativeSelect\r\n            onChange={handleChangeWitness}\r\n            className={styles.selectVersion}\r\n            value={r}\r\n            label=\"Version\"\r\n            classes={{\r\n                root: styles.selectEmpty,\r\n                select: styles.selectOptions,\r\n            }}\r\n        >\r\n            {witnesses.map((witness, key) => {\r\n                if (witness.id === props.activeWitness.id)\r\n                    classes.push(styles.selected);\r\n                tabName = witness.source.name;\r\n\r\n                if (witness.isWorking) {\r\n                    tabName =\r\n                        props.intl.locale === \"en\"\r\n                            ? props.user?.name === \"User\"\r\n                                ? \"Working\"\r\n                                : \"My Edition\"\r\n                            : \"མཉམ་འབྲེལ་པར་མ།\";\r\n                }\r\n\r\n                return (\r\n                    <option\r\n                        key={`versionSelect-${key}`}\r\n                        value={key}\r\n                        className={styles.selectOptions}\r\n                    >\r\n                        {tabName}\r\n                    </option>\r\n                );\r\n            })}\r\n        </NativeSelect>\r\n    );\r\n};\r\n\r\nexport default memo(injectIntl(SelectVersion));\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"inlineWidth\":\"280px\",\"annotationControls\":\"SplitText---annotationControls\",\"annotationContent\":\"SplitText---annotationContent\",\"subTitle\":\"SplitText---subTitle\",\"title\":\"SplitText---title\",\"sectionHeading\":\"SplitText---sectionHeading\",\"text\":\"SplitText---text\",\"padding\":\"SplitText---padding\",\"arrowTop\":\"SplitText---arrowTop\",\"arrowLeft\":\"SplitText---arrowLeft\",\"arrowRight\":\"SplitText---arrowRight\",\"inline\":\"SplitText---inline\",\"arrow\":\"SplitText---arrow\",\"arrowDs\":\"SplitText---arrowDs\",\"nothingSelected\":\"SplitText---nothingSelected\",\"anonymousMessage\":\"SplitText---anonymousMessage\",\"noNotes\":\"SplitText---noNotes\",\"breakButtons\":\"SplitText---breakButtons\",\"splitText\":\"SplitText---splitText\",\"splitTextRowContent\":\"SplitText---splitTextRowContent\",\"splitTextRow\":\"SplitText---splitTextRow\",\"pechaImage\":\"SplitText---pechaImage\",\"image\":\"SplitText---image\",\"controlsPlaceholder\":\"SplitText---controlsPlaceholder\",\"hide\":\"SplitText---hide\",\"pageNumber\":\"SplitText---pageNumber\",\"image-loading\":\"SplitText---image-loading\"};","// @flow\r\nimport * as React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { AutoSizer } from \"react-virtualized/dist/es/AutoSizer\";\r\nimport { List } from \"react-virtualized/dist/es/List\";\r\nimport lopenlinglogo from \"images/lopenling_logo.png\";\r\nimport {\r\n    CellMeasurer,\r\n    CellMeasurerCache,\r\n} from \"react-virtualized/dist/es/CellMeasurer\";\r\nimport \"react-virtualized/styles.css\";\r\nimport Text, {\r\n    idForSegment,\r\n    idForDeletedSegment,\r\n    idForInsertion,\r\n    idForPageBreak,\r\n    idForLineBreak,\r\n} from \"./Text\";\r\nimport SplitText from \"lib/SplitText\";\r\nimport SegmentedText from \"lib/SegmentedText\";\r\nimport shallowEqual from \"lib/shallowEqual\";\r\nimport { CONTROLS_MARGIN_LEFT } from \"./AnnotationControls\";\r\nimport AnnotationControlsContainer from \"./AnnotationControlsContainer\";\r\nimport styles from \"./SplitText.css\";\r\nimport annotationControlsStyles from \"./AnnotationControls.css\";\r\nimport controlStyles from \"./AnnotationControls.css\";\r\nimport _ from \"lodash\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport Annotation, { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport Witness from \"lib/Witness\";\r\nimport GraphemeSplitter from \"grapheme-splitter\";\r\nimport { TransformWrapper, TransformComponent } from \"react-zoom-pan-pinch\";\r\n\r\nconst MIN_SPACE_RIGHT =\r\n    parseInt(controlStyles.inlineWidth) + CONTROLS_MARGIN_LEFT;\r\n\r\nconst IMAGE_URL_PREFIX = \"//iiif.bdrc.io/\";\r\nconst IMAGE_URL_SUFFIX = \"/full/full/0/default.jpg\";\r\nconst IMAGE_START_PRE_KEY = \"bdrcimg_pre\";\r\nconst IMAGE_START_NUMBER_KEY = \"bdrcimg_number\";\r\nconst IMAGE_START_SUFFIX_KEY = \"bdrcimg_suffix\";\r\n\r\nlet _searchResultsCache: {\r\n    [splitTextUniqueId: string]: {\r\n        [searchTerm: string]: {\r\n            [index: number]: { [position: number]: [number, number] },\r\n        },\r\n    },\r\n} = {};\r\nfunction HttpUrl(data = \"\") {\r\n    if (data.includes(\"https\")) return data;\r\n    return \"https://\" + data;\r\n}\r\nexport type Props = {\r\n    textListVisible: boolean,\r\n    editMenuVisible: Boolean,\r\n    imagesBaseUrl: string,\r\n    splitText: SplitText,\r\n    didSelectSegmentIds: (segmentIds: string[]) => void,\r\n    limitWidth: boolean,\r\n    activeAnnotation: Annotation | null,\r\n    selectedAnnotatedSegments: Array<TextSegment | number>,\r\n    showImages: boolean,\r\n    annotationPositions: { [string]: Annotation[] },\r\n    annotations: Annotation[],\r\n    activeAnnotations: { [AnnotationUniqueId]: Annotation } | null,\r\n    selectedSegmentId: (segmentId: string) => void,\r\n    selectedWitness: Witness | null,\r\n    selectedWitness2: Witness | null,\r\n    selectedSearchResult: {\r\n        textId: number,\r\n        start: number,\r\n        length: number,\r\n    } | null,\r\n    searchValue: string | null,\r\n    fontSize: number,\r\n    isSecondWindowOpen: Boolean,\r\n    changeScrollToId: () => void,\r\n    changeSyncIdOnClick: () => void,\r\n    closeAnnotation: () => void,\r\n    imageData: {},\r\n    syncIdOnClick: Number,\r\n    isPanelLinked: Boolean,\r\n    isPanelVisible: Boolean,\r\n    textAlignment: {},\r\n    textAlignmentById: {},\r\n    selectedWindow: Boolean,\r\n    scrollToId: Number,\r\n    selectedTargetRange: [],\r\n    selectedSourceRange: [],\r\n    searchResults: [],\r\n    showTableContent: Boolean,\r\n    syncIdOnSearch: String,\r\n    imageAlignmentById: [],\r\n    changeImageScrollId: () => void,\r\n    condition: Boolean,\r\n};\r\n\r\nexport default class SplitTextComponent extends React.PureComponent<Props> {\r\n    isSecondWindowOpen: Boolean;\r\n    list: List | null;\r\n    splitText: HTMLDivElement | null;\r\n    cache: CellMeasurerCache;\r\n    rowRenderer: (params: {\r\n        key: string,\r\n        index: number,\r\n        parent: {},\r\n        style: {},\r\n    }) => React.Element<CellMeasurer>;\r\n    resizeHandler: () => void;\r\n    selectionHandler: (e: Event) => void;\r\n    textListVisible: boolean;\r\n    editMenuVisible: Boolean;\r\n    activeSelection: Selection | null;\r\n    selectedNodes: Node[] | null;\r\n    // Whether the mouse button is down\r\n    _mouseDown: boolean;\r\n    _activeWitness: Witness | null;\r\n    _didSetInitialScrollPosition: boolean;\r\n    _filteredSelectedAnnotatedSegments: TextSegment[];\r\n    _modifyingSelection: boolean;\r\n    selectedTextIndex: number | null;\r\n    splitTextRect: ClientRect | null;\r\n    firstSelectedSegment: TextSegment | null;\r\n    selectedElementId: string | null;\r\n    selectedElementIds: string[] | null;\r\n    imageWidth: number | null;\r\n    imageHeight: number | null;\r\n    calculatedImageHeight: number | null;\r\n    changeScrollToId: () => void;\r\n    changeImageScrollId: () => void;\r\n    changeSyncIdOnClick: () => void;\r\n    wheelScrolling: () => void;\r\n    closeAnnotation: () => void;\r\n    textlines: Node[] | null;\r\n    jump: number;\r\n    isPanelLinked: Boolean;\r\n    splitTextRef;\r\n    textAlignmentById;\r\n    scrollEvent: () => void;\r\n    selectedWindow;\r\n    debouncedScroll;\r\n    targetId;\r\n    condition;\r\n    imageAlignmentById;\r\n    changeImageScrollId;\r\n    imageData;\r\n    constructor(props: Props) {\r\n        super(props);\r\n        this.textAlignmentById = [];\r\n        this.childRef = React.createRef(\"0\");\r\n        this.list = null;\r\n        this.splitText = null;\r\n        this.cache = new CellMeasurerCache({\r\n            fixedWidth: true,\r\n        });\r\n        this.imageAlignmentById = this.props.imageAlignmentById;\r\n        this.changeImageScrollId = this.props.changeImageScrollId;\r\n        this.splitTextRef = React.createRef(null);\r\n        this.rowRenderer = this.rowRenderer.bind(this);\r\n        this.textListVisible = props.textListVisible;\r\n        this.editMenuVisible = props.editMenuVisible;\r\n        this.isPanelLinked = props.isPanelLinked;\r\n        this.activeSelection = null;\r\n        this.selectedNodes = null;\r\n        this._mouseDown = false;\r\n        this._activeWitness = null;\r\n        this._didSetInitialScrollPosition = false;\r\n        this._modifyingSelection = false;\r\n        this.imageHeight = null;\r\n        this.imageWidth = null;\r\n        this.calculatedImageHeight = null;\r\n        this.processProps(props);\r\n        this.changeScrollToId = props.changeScrollToId;\r\n        this.changeSyncIdOnClick = props.changeSyncIdOnClick;\r\n        this.closeAnnotation = props.closeAnnotation;\r\n        this.scrollJump = props.scrollJump;\r\n        this.textAlignmentById = [];\r\n        this.scrollEvent = this.scrollEvent.bind(this);\r\n        this.selectedWindow = props.selectedWindow;\r\n        this.changeImageScrollId = props.changeImageScrollId;\r\n        this.imageData = props.imageData;\r\n        this.condition = props.condition;\r\n    }\r\n\r\n    scrollEvent(e) {\r\n        if (this.selectedWindow === 2) return null;\r\n        if (this.selectedWindow === 1) {\r\n            let list = [];\r\n            let imageIdList = [];\r\n            this.textAlignmentById.map((l) => {\r\n                let number = document.getElementById(\"s_\" + l.start);\r\n                if (number) {\r\n                    let position = number.getBoundingClientRect();\r\n                    if (position.top > 102) {\r\n                        list.push({\r\n                            id: l.id,\r\n                            start: l.start,\r\n                            target: l.TStart,\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n            // this.imageAlignmentById.map((l) => {\r\n            //     let number = document.getElementById(\"s_\" + l?.start);\r\n            //     if (number) {\r\n            //         let position = number.getBoundingClientRect();\r\n            //         if (position.top > 102) {\r\n            //             imageIdList.push({\r\n            //                 id: l.id,\r\n            //                 start: l.start,\r\n            //                 end: l.end,\r\n            //             });\r\n            //         }\r\n            //     }\r\n            // });\r\n            if (!_.isEmpty(list) || !_.isEmpty(imageIdList)) {\r\n                if (this.selectedWindow === 1) {\r\n                    this.debouncedScroll(list);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    updateList(\r\n        resetCache: boolean = true,\r\n        resetRows: number | number[] | null = null\r\n    ) {\r\n        if (\r\n            this.props.showImages &&\r\n            !this.calculatedImageHeight &&\r\n            this.imageHeight &&\r\n            this.imageWidth\r\n        ) {\r\n            this.calculatedImageHeight = this.calculateImageHeight();\r\n        }\r\n        if (this.list) {\r\n            const list = this.list;\r\n            if (resetCache) {\r\n                if (resetRows !== null) {\r\n                    if (!Array.isArray(resetRows)) {\r\n                        this.cache.clear(resetRows);\r\n                    } else if (Array.isArray(resetRows)) {\r\n                        for (let i = 0; i < resetRows.length; i++) {\r\n                            let resetRow = resetRows[i];\r\n                            this.cache.clear(resetRow);\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.cache.clearAll();\r\n                    list.measureAllRows();\r\n                    list.recomputeRowHeights(0);\r\n                }\r\n            }\r\n            list.forceUpdateGrid();\r\n        }\r\n    }\r\n\r\n    mouseDown() {\r\n        this._mouseDown = true;\r\n    }\r\n\r\n    mouseUp() {\r\n        this._mouseDown = false;\r\n        if (this.activeSelection) {\r\n            let segmentIds = this.processSelection(this.activeSelection);\r\n            if (!segmentIds) {\r\n                segmentIds = [];\r\n            }\r\n            this.props.didSelectSegmentIds(segmentIds);\r\n            this.activeSelection = null;\r\n        }\r\n    }\r\n    handleSelection(e: Event) {\r\n        if (!this._modifyingSelection) {\r\n            this.activeSelection = document.getSelection();\r\n            if (!this._mouseDown) {\r\n                // sometimes, this gets called after the mouseDown event handler\r\n                this.mouseUp();\r\n            }\r\n        } else {\r\n            e.stopPropagation();\r\n            // Need to set this here. If set at callsite, the event will not\r\n            // have time to propagate.\r\n            this._modifyingSelection = false;\r\n        }\r\n    }\r\n\r\n    processSelection(selection: Selection): string[] | null {\r\n        if (\r\n            selection.rangeCount === 0 ||\r\n            selection.isCollapsed ||\r\n            selection.type === \"Caret\"\r\n        ) {\r\n            this.selectedNodes = null;\r\n            return null;\r\n        }\r\n\r\n        const range = selection.getRangeAt(0);\r\n        const start = range.startContainer;\r\n        const startSpan = this.getNodeSegmentSpan(start);\r\n        if (!(startSpan && startSpan.parentNode)) {\r\n            // If the selection is not a text segment, ignore.\r\n            // Assuming if the first node is a non-segment, they\r\n            // all are.\r\n            return null;\r\n        }\r\n\r\n        let nodes = this.getRangeNodes(range, startSpan.parentNode);\r\n        // Check if the selection starts after the end of a node, and\r\n        // if so remove that node.\r\n        if (nodes.length > 0) {\r\n            let firstNode = nodes[0];\r\n            if (range.startOffset === firstNode.textContent.length) {\r\n                nodes.shift();\r\n            }\r\n        }\r\n\r\n        const end = range.endContainer;\r\n        const endSpan = this.getNodeSegmentSpan(end);\r\n        if (!(endSpan && endSpan.parentNode)) {\r\n            return null;\r\n        }\r\n        if (endSpan && startSpan.parentNode !== endSpan.parentNode) {\r\n            // Selection is spanning Texts.\r\n            // We assume a selection can only run across a maximum\r\n            // of two Texts.\r\n            nodes = nodes.concat(this.getRangeNodes(range, endSpan.parentNode));\r\n        } else {\r\n            // Check if the selection ends before the start of a node, and\r\n            // if so remove that node.\r\n            if (range.endOffset === 0) {\r\n                nodes.pop();\r\n            }\r\n        }\r\n        this.selectedNodes = nodes;\r\n        let nodeIds = [];\r\n        nodes.reduce((accumulator: string[], current: Node) => {\r\n            if (current instanceof Element) {\r\n                accumulator.push(current.id);\r\n            }\r\n            return accumulator;\r\n        }, nodeIds);\r\n        return nodeIds;\r\n    }\r\n\r\n    getNodeSegmentSpan(node: Node): Element | null {\r\n        let currentNode = node;\r\n        let span = null;\r\n        const test = /^(i|s|ds)_/;\r\n        while (!span && currentNode.parentNode) {\r\n            if (currentNode instanceof Element && test.test(currentNode.id)) {\r\n                span = currentNode;\r\n            }\r\n            currentNode = currentNode.parentNode;\r\n        }\r\n\r\n        return span;\r\n    }\r\n\r\n    getRangeNodes(range: Range, parentNode: Node): Node[] {\r\n        let rangeSpans = [];\r\n        for (let i = 0, len = parentNode.childNodes.length; i < len; i++) {\r\n            const node = parentNode.childNodes[i];\r\n            // TODO: add polyfill for i.e.?\r\n            // e.g. https://gist.github.com/jonathansampson/6d09bd6d2e8c22c53868aec42e66b0f9\r\n            if (range.intersectsNode(node)) {\r\n                rangeSpans.push(node);\r\n            }\r\n        }\r\n        return rangeSpans;\r\n    }\r\n\r\n    getControlsMeasurements(props: Props): {\r\n        selectedTextIndex: number,\r\n        firstSelectedSegment: TextSegment,\r\n        selectedElementId: string,\r\n        splitTextRect: ClientRect,\r\n        selectedElementIds: string[],\r\n    } | null {\r\n        if (!this.splitText) {\r\n            return null;\r\n        }\r\n        let splitTextComponent = this.splitText;\r\n        let selectedTextIndex = null;\r\n        let firstSelectedSegment = null;\r\n        let selectedElementId = null;\r\n        let splitTextRect = null;\r\n        let segmentIdFunction: null | ((segment: TextSegment) => string) = null;\r\n        let selectedElementIds = [];\r\n        let startPos = 0;\r\n        if (props.activeAnnotation) {\r\n            let activeAnnotation = props.activeAnnotation;\r\n            [startPos] =\r\n                props.splitText.annotatedText.getPositionOfAnnotation(\r\n                    activeAnnotation\r\n                );\r\n            if (startPos === null) {\r\n                console.warn(\"No startPos in getControlsMeasurements\");\r\n                return null;\r\n            }\r\n            if (activeAnnotation.type === ANNOTATION_TYPES.pageBreak) {\r\n                startPos -= 1;\r\n            }\r\n            if (activeAnnotation.type === ANNOTATION_TYPES.lineBreak) {\r\n                startPos -= 1;\r\n            }\r\n\r\n            // Index of text containing end of annotation\r\n            let positionEnd = startPos + activeAnnotation.length;\r\n            if (activeAnnotation.length > 0) positionEnd -= 1;\r\n            selectedTextIndex =\r\n                props.splitText.getTextIndexOfPosition(positionEnd);\r\n            splitTextRect = splitTextComponent.getBoundingClientRect();\r\n        }\r\n        let selectedAnnotatedSegments = [];\r\n        if (\r\n            props.selectedAnnotatedSegments &&\r\n            props.selectedAnnotatedSegments.length > 0\r\n        ) {\r\n            selectedAnnotatedSegments = props.selectedAnnotatedSegments;\r\n            for (let i = 0; i < selectedAnnotatedSegments.length; i++) {\r\n                let segment = selectedAnnotatedSegments[i];\r\n                if (\r\n                    firstSelectedSegment === null &&\r\n                    segment instanceof TextSegment\r\n                ) {\r\n                    firstSelectedSegment = segment;\r\n                    break;\r\n                }\r\n            }\r\n            if (firstSelectedSegment) {\r\n                if (\r\n                    firstSelectedSegment.length === 0 &&\r\n                    props.activeAnnotation &&\r\n                    props.activeAnnotation.isInsertion\r\n                ) {\r\n                    selectedElementId = idForInsertion(firstSelectedSegment);\r\n                    segmentIdFunction = idForInsertion;\r\n                } else {\r\n                    selectedElementId = idForSegment(firstSelectedSegment);\r\n                    segmentIdFunction = idForSegment;\r\n                }\r\n            }\r\n        } else if (props.activeAnnotation) {\r\n            if (props.activeAnnotation.isDeletion) {\r\n                let segment = new TextSegment(startPos, \"\");\r\n                selectedElementId = idForDeletedSegment(segment);\r\n                segmentIdFunction = idForDeletedSegment;\r\n                firstSelectedSegment = segment;\r\n                selectedAnnotatedSegments = [firstSelectedSegment];\r\n            } else if (props.activeAnnotation.isInsertion) {\r\n                const [start] =\r\n                    props.splitText.annotatedText.getPositionOfAnnotation(\r\n                        props.activeAnnotation\r\n                    );\r\n                if (start) {\r\n                    let segment = new TextSegment(start, \"\");\r\n                    selectedElementId = idForInsertion(segment);\r\n                    segmentIdFunction = idForInsertion;\r\n                    firstSelectedSegment = segment;\r\n                    selectedAnnotatedSegments = [firstSelectedSegment];\r\n                }\r\n            } else if (\r\n                props.activeAnnotation.type === ANNOTATION_TYPES.pageBreak\r\n            ) {\r\n                let segment = new TextSegment(startPos + 1, \"\");\r\n                let prevSegment = new TextSegment(startPos, \"\");\r\n                selectedElementId = idForPageBreak(prevSegment);\r\n                firstSelectedSegment = segment;\r\n                selectedAnnotatedSegments = [segment];\r\n                selectedElementIds = [selectedElementId];\r\n            } else if (\r\n                props.activeAnnotation.type === ANNOTATION_TYPES.lineBreak\r\n            ) {\r\n                let segment = new TextSegment(startPos + 1, \"\");\r\n                let prevSegment = new TextSegment(startPos, \"\");\r\n                selectedElementId = idForLineBreak(prevSegment);\r\n                firstSelectedSegment = segment;\r\n                selectedAnnotatedSegments = [segment];\r\n                selectedElementIds = [selectedElementId];\r\n            }\r\n        }\r\n        if (segmentIdFunction) {\r\n            for (let i = 0; i < selectedAnnotatedSegments.length; i++) {\r\n                let segment = selectedAnnotatedSegments[i];\r\n                if (segment instanceof TextSegment) {\r\n                    const segmentId = segmentIdFunction(segment);\r\n                    selectedElementIds.push(segmentId);\r\n                }\r\n            }\r\n        }\r\n        if (\r\n            selectedTextIndex != null &&\r\n            firstSelectedSegment &&\r\n            selectedElementId &&\r\n            splitTextRect\r\n        ) {\r\n            return {\r\n                selectedTextIndex: selectedTextIndex,\r\n                firstSelectedSegment: firstSelectedSegment,\r\n                selectedElementId: selectedElementId,\r\n                splitTextRect: splitTextRect,\r\n                selectedElementIds: selectedElementIds,\r\n            };\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    shouldResetListCache(oldProps: Props, newProps: Props) {\r\n        let shouldReset = false;\r\n        if (\r\n            oldProps.showImages !== newProps.showImages ||\r\n            this.pageBreaksChanged(oldProps, newProps)\r\n        ) {\r\n            shouldReset = true;\r\n        }\r\n\r\n        return shouldReset;\r\n    }\r\n\r\n    pageBreaksChanged(oldProps: Props, newProps: Props) {\r\n        const oldTextBreaks = oldProps.splitText.getTextsFinalPositions();\r\n        const newTextBreaks = newProps.splitText.getTextsFinalPositions();\r\n\r\n        if (oldTextBreaks.length !== newTextBreaks.length) return true;\r\n\r\n        return JSON.stringify(oldTextBreaks) !== JSON.stringify(newTextBreaks);\r\n    }\r\n\r\n    lineBreaksChanges(oldProps: Props, newProps: Props) {\r\n        let oldActiveAnnotation = oldProps.activeAnnotation;\r\n        let newActiveAnnotation = newProps.activeAnnotation;\r\n        let hasChanged = false;\r\n\r\n        if (\r\n            oldActiveAnnotation &&\r\n            oldActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) &&\r\n            newProps.activeAnnotations &&\r\n            !newProps.activeAnnotations.hasOwnProperty(\r\n                oldActiveAnnotation.uniqueId\r\n            )\r\n        ) {\r\n            hasChanged = true;\r\n        }\r\n\r\n        if (\r\n            newActiveAnnotation &&\r\n            newActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) &&\r\n            oldProps.activeAnnotations &&\r\n            !oldProps.activeAnnotations.hasOwnProperty(\r\n                newActiveAnnotation.uniqueId\r\n            )\r\n        ) {\r\n            hasChanged = true;\r\n        }\r\n\r\n        return hasChanged;\r\n    }\r\n\r\n    selectedListRow(props: Props): number | null {\r\n        let row = null;\r\n        if (props.activeAnnotation) {\r\n            row = props.splitText.getTextIndexOfPosition(\r\n                props.activeAnnotation.start\r\n            );\r\n        }\r\n        return row;\r\n    }\r\n\r\n    processProps(props: Props) {\r\n        let changedWitness = false;\r\n        if (\r\n            !this.props.selectedWitness ||\r\n            (props.selectedWitness &&\r\n                props.selectedWitness.id !== this.props.selectedWitness.id)\r\n        ) {\r\n            changedWitness = true;\r\n            this._didSetInitialScrollPosition = false;\r\n        }\r\n\r\n        if (\r\n            props.selectedSearchResult &&\r\n            (!this.props.selectedSearchResult ||\r\n                props.selectedSearchResult.start !==\r\n                    this.props.selectedSearchResult.start ||\r\n                props.selectedSearchResult.textId !==\r\n                    this.props.selectedSearchResult.textId)\r\n        ) {\r\n            console.log(\"resetting scroll position from search result\");\r\n            this._didSetInitialScrollPosition = false;\r\n        }\r\n\r\n        // TODO: check if new selectedSearchResult and if so\r\n        // set this._didSetInitialScrollPosition = false\r\n\r\n        // make sure there's no numbers in selectedAnnotatedSegments\r\n        // as we want to pass it to Text which only expects TextSegments\r\n        this._filteredSelectedAnnotatedSegments =\r\n            props.selectedAnnotatedSegments.reduce(\r\n                (acc, current: TextSegment | number) => {\r\n                    if (current instanceof TextSegment) acc.push(current);\r\n                    return acc;\r\n                },\r\n                []\r\n            );\r\n\r\n        const controlsMeasurements = this.getControlsMeasurements(props);\r\n        if (controlsMeasurements) {\r\n            this.selectedTextIndex = controlsMeasurements.selectedTextIndex;\r\n            this.firstSelectedSegment =\r\n                controlsMeasurements.firstSelectedSegment;\r\n            this.splitTextRect = controlsMeasurements.splitTextRect;\r\n            this.selectedElementId = controlsMeasurements.selectedElementId;\r\n            this.selectedElementIds = controlsMeasurements.selectedElementIds;\r\n        }\r\n\r\n        if (\r\n            props.textListVisible !== this.textListVisible ||\r\n            props.editMenuVisible !== this.editMenuVisible\r\n        ) {\r\n            setTimeout(() => {\r\n                this.textListVisible = props.textListVisible;\r\n                this.editMenuVisible = props.editMenuVisible;\r\n                this.updateList(true);\r\n            }, 500);\r\n        } else {\r\n            if (changedWitness) {\r\n                this.updateList(true);\r\n            } else if (this.pageBreaksChanged(this.props, props)) {\r\n                let selectedRows = null;\r\n                let currentSelectedRow = this.selectedListRow(this.props);\r\n                let newSelectedRow = this.selectedListRow(props);\r\n                if (currentSelectedRow && newSelectedRow) {\r\n                    let firstChangedRow =\r\n                        currentSelectedRow > newSelectedRow\r\n                            ? newSelectedRow\r\n                            : currentSelectedRow;\r\n\r\n                    let splitRowTexts = this.props.splitText.texts;\r\n                    selectedRows = [];\r\n                    for (\r\n                        let i = firstChangedRow, len = splitRowTexts.length;\r\n                        i < len;\r\n                        i++\r\n                    ) {\r\n                        selectedRows.push(i);\r\n                    }\r\n                }\r\n                this.updateList(true, selectedRows);\r\n            } else if (this.lineBreaksChanges(this.props, props)) {\r\n                let selectedRow = this.selectedListRow(props);\r\n                if (!selectedRow)\r\n                    selectedRow = this.selectedListRow(this.props);\r\n                let splitRowTexts = this.props.splitText.texts;\r\n                let selectedRows = [];\r\n                if (selectedRow !== null) {\r\n                    for (\r\n                        let i = selectedRow, len = splitRowTexts.length;\r\n                        i < len;\r\n                        i++\r\n                    ) {\r\n                        selectedRows.push(i);\r\n                    }\r\n                    this.updateList(true, selectedRows);\r\n                }\r\n            } else if (this.props.fontSize !== props.fontSize) {\r\n                this.updateList(true);\r\n            } else if (\r\n                this.props.activeAnnotation &&\r\n                props.activeAnnotation &&\r\n                this.annotationsInSameLocation(\r\n                    this.props.activeAnnotation,\r\n                    props.activeAnnotation\r\n                )\r\n            ) {\r\n                this.updateList(true, this.selectedListRow(props));\r\n            } else {\r\n                this.updateList(this.shouldResetListCache(this.props, props));\r\n            }\r\n        }\r\n    }\r\n\r\n    annotationsInSameLocation(anno1: Annotation, anno2: Annotation): boolean {\r\n        if (anno1.start === anno2.start && anno1.length === anno2.length) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    UNSAFE_componentWillReceiveProps(props: Props) {\r\n        this.processProps(props);\r\n    }\r\n\r\n    scrollToIndex(selectedTextIndex) {\r\n        let list = this.list;\r\n\r\n        setTimeout(() => {\r\n            list.scrollToRow(selectedTextIndex);\r\n            setTimeout(() => {\r\n                list.scrollToPosition(list.props.scrollTop - 300);\r\n            }, 0);\r\n        }, 100);\r\n    }\r\n    componentDidMount() {\r\n        this.resizeHandler = _.throttle(() => {\r\n            this.calculatedImageHeight = null;\r\n            this.updateList();\r\n        }, 600).bind(this);\r\n        this.debouncedScroll = _.debounce((list) => {\r\n            if (list.length) {\r\n                this.changeScrollToId({ id: list[0]?.start, from: 1 });\r\n                console.log(list[0]);\r\n            }\r\n            // if (imagelist.length) {\r\n            //     this.changeImageScrollId({\r\n            //         id: {\r\n            //             start: imagelist[0]?.start,\r\n            //             end: imagelist[0]?.end,\r\n            //         },\r\n            //         from: 1,\r\n            //     });\r\n            // }\r\n        }, 1000);\r\n\r\n        window.addEventListener(\"resize\", this.resizeHandler);\r\n\r\n        this.selectionHandler = _.debounce((e) => {\r\n            this.handleSelection(e);\r\n        }, 200).bind(this);\r\n\r\n        document.addEventListener(\"selectionchange\", this.selectionHandler);\r\n        document.addEventListener(\"mousedown\", this.mouseDown.bind(this), true);\r\n        document.addEventListener(\"mouseup\", this.mouseUp.bind(this), true);\r\n        this.processProps(this.props);\r\n        this.timer = setTimeout(() => {\r\n            this.resizeHandler();\r\n        }, 2000);\r\n        this.splitText.style.scrollBehavior = \"smooth\";\r\n\r\n        this.componentDidUpdate();\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        this.imageData = this.props.imageData;\r\n        if (this.imageData !== prevProps?.imageData) {\r\n            this.calculatedImageHeight = null;\r\n\r\n            this.updateList(true);\r\n        }\r\n        let Alignment = this.props.textAlignment;\r\n        this.imageAlignmentById = this.props.imageAlignmentById;\r\n        this.SearchSyncId = this.props.syncIdOnSearch || null;\r\n        this.condition = this.props.condition;\r\n\r\n        let scrollToId = this.props.scrollToId;\r\n        let list = this.list;\r\n\r\n        let con =\r\n            prevProps?.searchResults !== this.props?.searchResults ||\r\n            prevProps?.syncIdOnSearch !== this.props?.syncIdOnSearch;\r\n\r\n        // scroll to word searched using search input\r\n        if (con && this.props.searchResults) {\r\n            if (this.SearchSyncId) {\r\n                let selectedTextIndex =\r\n                    this.props.splitText.getTextIndexOfPosition(\r\n                        this.SearchSyncId\r\n                    );\r\n                this.srcollToIndex(selectedTextIndex);\r\n            }\r\n        }\r\n\r\n        this.textAlignmentById = this.props.textAlignmentById;\r\n        this.selectedWindow = this.props.selectedWindow;\r\n        this.targetId = this.props.syncIdOnClick;\r\n\r\n        if (this.selectedNodes && this.selectedNodes.length > 0) {\r\n            const selectedNodes = this.selectedNodes;\r\n            const selectedSegments = this.props.selectedAnnotatedSegments;\r\n            setTimeout(() => {\r\n                let selRange = document.createRange();\r\n                let startNode = selectedNodes[0];\r\n                let endNode = selectedNodes[selectedNodes.length - 1];\r\n                let lastSegment = selectedSegments[selectedSegments.length - 1];\r\n                if (lastSegment instanceof TextSegment) {\r\n                    let lastElement = document.getElementById(\r\n                        idForSegment(lastSegment)\r\n                    );\r\n                    if (lastElement) endNode = lastElement;\r\n                }\r\n\r\n                if (\r\n                    startNode instanceof Element &&\r\n                    endNode instanceof Element\r\n                ) {\r\n                    startNode = document.getElementById(startNode.id);\r\n                    endNode = document.getElementById(endNode.id);\r\n                    if (startNode && endNode) {\r\n                        selRange.setStart(startNode, 0);\r\n                        selRange.setEnd(endNode, endNode.childNodes.length);\r\n                        let sel = document.getSelection();\r\n                        if (sel) {\r\n                            this._modifyingSelection = true;\r\n                            sel.removeAllRanges();\r\n                            sel.addRange(selRange);\r\n                            this.selectedNodes = null;\r\n                        }\r\n                    }\r\n                }\r\n            }, 0);\r\n        }\r\n\r\n        if (!this._didSetInitialScrollPosition && this.list) {\r\n            const list = this.list;\r\n            if (\r\n                this.props.activeAnnotation ||\r\n                this.props.selectedSearchResult\r\n            ) {\r\n                let selectedTextIndex = this.getSelectedTextIndex();\r\n                setTimeout(() => {\r\n                    list.scrollToRow(selectedTextIndex);\r\n                    // scrollToRow often positions the annotation at the\r\n                    // bottom of the screen, so scroll up a bit\r\n                    setTimeout(() => {\r\n                        list.scrollToPosition(list.props.scrollTop - 300);\r\n                    }, 0);\r\n                }, 100);\r\n            }\r\n            this._didSetInitialScrollPosition = true;\r\n        }\r\n        //Video and audio alignment scrolling\r\n        if (scrollToId.from == \"video\" && scrollToId.id) {\r\n            let start = scrollToId.id;\r\n            let selectedTextIndex =\r\n                this.props.splitText.getTextIndexOfPosition(start);\r\n            setTimeout(() => {\r\n                list.scrollToRow(selectedTextIndex);\r\n                setTimeout(() => {\r\n                    list.scrollToPosition(list.props.scrollTop - 300);\r\n                }, 0);\r\n            }, 100);\r\n        }\r\n\r\n        // scroll dom with respect to window 2 scrolling\r\n        if (\r\n            this.selectedWindow === 2 &&\r\n            scrollToId.from == 2 &&\r\n            this.condition &&\r\n            scrollToId.id !== null\r\n        ) {\r\n            this.textAlignmentById = this.props.textAlignmentById || [];\r\n            if (Alignment) {\r\n                let req = this.textAlignmentById.find(\r\n                    (l) => l.TStart === scrollToId.id\r\n                );\r\n\r\n                let start = req?.start;\r\n                if (start !== null) {\r\n                    console.log(start);\r\n                    let selectedTextIndex =\r\n                        this.props.splitText.getTextIndexOfPosition(start);\r\n                    this.scrollToIndex(selectedTextIndex);\r\n                }\r\n            }\r\n        }\r\n\r\n        // scroll dom with respect to window 2 click\r\n        //for scrolling to the highlighted alignment if its outside visible DOM\r\n\r\n        if (\r\n            this.targetId &&\r\n            scrollToId.from === \"ua\" &&\r\n            this.selectedWindow === 2 &&\r\n            scrollToId.id === \"ua\"\r\n        ) {\r\n            let clickIdObj = Alignment.alignment.find(\r\n                (l) =>\r\n                    this.targetId >= l.target_segment.start &&\r\n                    this.targetId < l.target_segment.end\r\n            );\r\n            let syncClickTargetId = clickIdObj?.source_segment?.start;\r\n            let selectedTextIndex =\r\n                this.props.splitText.getTextIndexOfPosition(syncClickTargetId);\r\n\r\n            this.scrollToIndex(selectedTextIndex);\r\n        }\r\n    }\r\n    componentWillUnmount() {\r\n        document.removeEventListener(\"mousedown\", this);\r\n        document.removeEventListener(\"mouseup\", this);\r\n        window.removeEventListener(\"resize\", this.resizeHandler);\r\n\r\n        document.removeEventListener(\"selectionchange\", this.selectionHandler);\r\n        clearTimeout(this.timer);\r\n    }\r\n\r\n    calculateImageHeight() {\r\n        let height = null;\r\n        if (this.imageHeight && this.imageWidth) {\r\n            const ratio = this.imageWidth / this.imageHeight;\r\n            const pechaImageClass = styles.pechaImage;\r\n            const pechaImageContainers =\r\n                document.getElementsByClassName(pechaImageClass);\r\n            if (pechaImageContainers.length > 0) {\r\n                let container = pechaImageContainers[0];\r\n                height = container.offsetWidth / ratio;\r\n            }\r\n        }\r\n        return height;\r\n    }\r\n\r\n    getSelectedTextIndex(): number {\r\n        let selectedTextIndex = 0;\r\n        let startPos = null;\r\n        if (this.props.activeAnnotation) {\r\n            [startPos] =\r\n                this.props.splitText.annotatedText.getPositionOfAnnotation(\r\n                    this.props.activeAnnotation\r\n                );\r\n        } else if (this.props.selectedSearchResult) {\r\n            let segment =\r\n                this.props.splitText.annotatedText.segmentAtOriginalPosition(\r\n                    this.props.selectedSearchResult.start\r\n                );\r\n            if (segment instanceof TextSegment) {\r\n                startPos = segment.start;\r\n            } else if (typeof segment === \"number\") {\r\n                startPos = segment;\r\n            }\r\n        }\r\n        if (startPos) {\r\n            selectedTextIndex =\r\n                this.props.splitText.getTextIndexOfPosition(startPos);\r\n        }\r\n        return selectedTextIndex;\r\n    }\r\n\r\n    getBaseAnnotation(annotation: Annotation): Annotation {\r\n        let [start] =\r\n            this.props.splitText.annotatedText.getPositionOfAnnotation(\r\n                annotation\r\n            );\r\n        if (start === null) start = 0;\r\n        return this.props.splitText.annotatedText.getBaseAnnotation(\r\n            start,\r\n            annotation.content.length\r\n        );\r\n    }\r\n\r\n    render() {\r\n        const props = this.props;\r\n        const rowRenderer = this.rowRenderer;\r\n        const cache = this.cache;\r\n        const key = props.selectedWitness ? props.selectedWitness.id : 0;\r\n\r\n        return (\r\n            <div\r\n                className={styles.splitText}\r\n                ref={(div) => (this.splitText = div)}\r\n                key={key}\r\n            >\r\n                <button\r\n                    id=\"updateList\"\r\n                    style={{ display: \"none\" }}\r\n                    onClick={this.resizeHandler}\r\n                ></button>\r\n                <AutoSizer disableWidth>\r\n                    {({ height }) => (\r\n                        <List\r\n                            width={1}\r\n                            ref={(list) => (this.list = list)}\r\n                            height={height}\r\n                            rowCount={props.splitText.texts.length}\r\n                            rowHeight={cache.rowHeight}\r\n                            rowRenderer={rowRenderer}\r\n                            overscanRowCount={0}\r\n                            deferredMeasurementCache={cache}\r\n                            onScroll={this.scrollEvent}\r\n                            scrollToAlignment=\"start\"\r\n                            containerStyle={{\r\n                                width: \"100%\",\r\n                                maxWidth: \"100%\",\r\n                            }}\r\n                            style={{\r\n                                width: \"100%\",\r\n                            }}\r\n                        ></List>\r\n                    )}\r\n                </AutoSizer>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    getImageUrl(pageIndex: number): string {\r\n        if (\r\n            !this.props.selectedWitness ||\r\n            !this.props.selectedWitness.properties\r\n        )\r\n            return \"\";\r\n        let witnessProperties = this.props.selectedWitness.properties;\r\n        let prefix = witnessProperties[IMAGE_START_PRE_KEY];\r\n        let start = witnessProperties[IMAGE_START_NUMBER_KEY];\r\n        let suffix = witnessProperties[IMAGE_START_SUFFIX_KEY];\r\n        let id = Number(start) + pageIndex;\r\n        console.log(id);\r\n        let url =\r\n            IMAGE_URL_PREFIX + prefix + id + \".\" + suffix + IMAGE_URL_SUFFIX;\r\n        console.log(url);\r\n        return url;\r\n    }\r\n\r\n    getStringPositions(\r\n        text: SegmentedText,\r\n        string: string,\r\n        index: number\r\n    ): { [position: number]: [number, number] } {\r\n        const uniqueId = this.props.splitText.annotatedText.getUniqueId();\r\n\r\n        if (!_searchResultsCache.hasOwnProperty(uniqueId)) {\r\n            _searchResultsCache = {\r\n                [uniqueId]: {},\r\n            };\r\n        }\r\n\r\n        if (!_searchResultsCache[uniqueId].hasOwnProperty(string)) {\r\n            _searchResultsCache[uniqueId] = {\r\n                [string]: {},\r\n            };\r\n        }\r\n\r\n        if (_searchResultsCache[uniqueId][string].hasOwnProperty(index)) {\r\n            return _searchResultsCache[uniqueId][string][index];\r\n        }\r\n\r\n        const splitter = new GraphemeSplitter();\r\n        const content = text.getText();\r\n        const firstSegment = text.segments[0];\r\n        const startingPosition = firstSegment?.start;\r\n        let positions = [];\r\n        let position = content.indexOf(string);\r\n        while (position !== -1) {\r\n            positions.push(position);\r\n            position = content.indexOf(string, position + 1);\r\n        }\r\n\r\n        // Position needs to be position in complete text\r\n        let verifiedPositions: { [position: number]: [number, number] } = {};\r\n        if (positions.length > 0) {\r\n            const graphemes = splitter.splitGraphemes(content);\r\n            let position = 0;\r\n            let activePosition = null;\r\n            for (let i = 0; i < graphemes.length; i++) {\r\n                const grapheme = graphemes[i];\r\n                const graphemeEnd = position + (grapheme.length - 1);\r\n                if (activePosition !== null) {\r\n                    let expectedEnd = activePosition + (string.length - 1);\r\n                    if (graphemeEnd >= expectedEnd) {\r\n                        verifiedPositions[activePosition + startingPosition] = [\r\n                            activePosition + startingPosition,\r\n                            graphemeEnd + startingPosition,\r\n                        ];\r\n                        activePosition = null;\r\n                    }\r\n                } else if (positions.indexOf(position) !== -1) {\r\n                    if (string.length === grapheme.length) {\r\n                        verifiedPositions[position + startingPosition] = [\r\n                            position + startingPosition,\r\n                            graphemeEnd + startingPosition,\r\n                        ];\r\n                    } else if (string.length > grapheme.length) {\r\n                        activePosition = position;\r\n                    }\r\n                } else {\r\n                    activePosition = null;\r\n                }\r\n\r\n                position += grapheme.length;\r\n            }\r\n        }\r\n\r\n        _searchResultsCache[uniqueId][string][index] = verifiedPositions;\r\n\r\n        return verifiedPositions;\r\n    }\r\n\r\n    rowRenderer({\r\n        key,\r\n        index,\r\n        parent,\r\n        style,\r\n    }: {\r\n        key: string,\r\n        index: number,\r\n        parent: {},\r\n        style: {},\r\n    }): React.Element<CellMeasurer> {\r\n        const props = this.props;\r\n        const cache = this.cache;\r\n        const component = this;\r\n        const pechaImageClass = props.showImages ? styles.pechaImage : null;\r\n\r\n        let imageUrl = \"\";\r\n        // if (this.imageData?.alignment && props.selectedWitness) {\r\n        //     imageUrl = HttpUrl(\r\n        //         this.imageData?.alignment[index]?.target_segment\r\n        //     );\r\n        // }\r\n        if (\r\n            props.selectedWitness &&\r\n            props.selectedWitness.properties &&\r\n            props.selectedWitness.properties.hasOwnProperty(IMAGE_START_PRE_KEY)\r\n        ) {\r\n            console.log(\"running\");\r\n            imageUrl = this.getImageUrl(index);\r\n        }\r\n\r\n        let searchStringPositions = {};\r\n        let searchValue = this.props.searchValue;\r\n        if (searchValue && searchValue.length > 0 && props.splitText) {\r\n            searchStringPositions = this.getStringPositions(\r\n                props.splitText.texts[index],\r\n                searchValue,\r\n                index\r\n            );\r\n        }\r\n\r\n        let pechaStyles = {};\r\n\r\n        if (props.showImages && pechaImageClass && this.calculatedImageHeight) {\r\n            pechaStyles[\"height\"] = this.calculatedImageHeight + \"px\";\r\n        }\r\n        let newStyle = {\r\n            ...style,\r\n            height: style.height + 10,\r\n            cursor: !this.props.isAnnotating ? \"pointer\" : \"text\",\r\n        };\r\n        return (\r\n            <CellMeasurer\r\n                columnIndex={0}\r\n                key={key}\r\n                parent={parent}\r\n                rowIndex={index}\r\n                cache={cache}\r\n            >\r\n                <div\r\n                    key={key}\r\n                    style={newStyle}\r\n                    className={styles.splitTextRow}\r\n                    ref={this.splitTextRef}\r\n                    id={`index_${index}`}\r\n                >\r\n                    <div className={styles.splitTextRowContent}>\r\n                        {props.showImages && (\r\n                            <div\r\n                                className={pechaImageClass}\r\n                                style={pechaStyles}\r\n                            >\r\n                                <img\r\n                                    alt=\"Text related Image\"\r\n                                    className={styles.image}\r\n                                    src={imageUrl}\r\n                                    width=\"100%\"\r\n                                    height=\"100%\"\r\n                                    loading=\"lazy\"\r\n                                    decoding=\"async\"\r\n                                    onLoad={(e) => {\r\n                                        if (\r\n                                            e.target &&\r\n                                            component.imageWidth === null\r\n                                        ) {\r\n                                            component.imageWidth =\r\n                                                e.target.naturalWidth;\r\n                                            component.imageHeight =\r\n                                                e.target.naturalHeight;\r\n                                            component.calculatedImageHeight =\r\n                                                null;\r\n                                            window.setTimeout(\r\n                                                component.updateList.bind(\r\n                                                    component\r\n                                                ),\r\n                                                0\r\n                                            );\r\n                                        }\r\n                                    }}\r\n                                />\r\n                            </div>\r\n                        )}\r\n\r\n                        <Text\r\n                            ref={this.childRef}\r\n                            segmentedText={props.splitText.texts[index]}\r\n                            annotations={props.annotations}\r\n                            activeAnnotations={props.activeAnnotations}\r\n                            activeAnnotation={props.activeAnnotation}\r\n                            row={index}\r\n                            selectedSegmentId={props.selectedSegmentId}\r\n                            annotationPositions={props.annotationPositions}\r\n                            selectedAnnotatedSegments={\r\n                                this._filteredSelectedAnnotatedSegments\r\n                            }\r\n                            getBaseAnnotation={this.getBaseAnnotation.bind(\r\n                                this\r\n                            )}\r\n                            activeWitness={this.props.selectedWitness}\r\n                            searchValue={searchValue}\r\n                            selectedSearchResult={\r\n                                this.props.selectedSearchResult\r\n                            }\r\n                            searchStringPositions={searchStringPositions}\r\n                            fontSize={props.fontSize}\r\n                            changeSyncIdOnClick={this.props.changeSyncIdOnClick}\r\n                            changeScrollToId={this.props.changeScrollToId}\r\n                            textAlignmentById={this.props.textAlignmentById}\r\n                            selectedSourceRange={this.props.selectedSourceRange}\r\n                            selectedTargetRange={this.props.selectedTargetRange}\r\n                            changeSelectedRange={this.props.changeSelectedRange}\r\n                            condition={this.condition}\r\n                        />\r\n                    </div>\r\n                    {this.props.isAnnotating &&\r\n                        this.selectedTextIndex === index &&\r\n                        this.props.activeAnnotation && (\r\n                            <AnnotationControlsContainer\r\n                                annotationPositions={props.annotationPositions}\r\n                                annotatedText={props.splitText.annotatedText}\r\n                                activeAnnotation={props.activeAnnotation}\r\n                                inline={true}\r\n                                firstSelectedSegment={this.firstSelectedSegment}\r\n                                splitTextRect={this.splitTextRect}\r\n                                selectedElementId={this.selectedElementId}\r\n                                pechaImageClass={pechaImageClass}\r\n                                splitText={props.splitText}\r\n                                selectedElementIds={this.selectedElementIds}\r\n                                list={this.list}\r\n                            />\r\n                        )}\r\n                </div>\r\n            </CellMeasurer>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"TableContent\":\"TableOfContent---TableContent\"};","import React from \"react\";\r\nimport { Box, ClickAwayListener, Typography } from \"@mui/material\";\r\nimport Loader from \"react-loader\";\r\nimport styles from \"./TableOfContent.css\";\r\nimport { styled, alpha } from \"@mui/material/styles\";\r\nimport SearchIcon from \"@mui/icons-material/Search\";\r\nimport InputBase from \"@mui/material/InputBase\";\r\nimport Toolbar from \"@mui/material/Toolbar\";\r\nconst Search = styled(\"div\")(({ theme }) => ({\r\n    position: \"relative\",\r\n    borderRadius: theme.shape.borderRadius,\r\n    backgroundColor: alpha(theme.palette.common.white, 0.15),\r\n    \"&:hover\": {\r\n        backgroundColor: alpha(theme.palette.common.white, 0.25),\r\n    },\r\n    marginLeft: 0,\r\n    width: \"100%\",\r\n    [theme.breakpoints.up(\"sm\")]: {\r\n        marginLeft: theme.spacing(1),\r\n        width: \"auto\",\r\n    },\r\n}));\r\n\r\nconst SearchIconWrapper = styled(\"div\")(({ theme }) => ({\r\n    padding: theme.spacing(0, 2),\r\n    height: \"100%\",\r\n    position: \"absolute\",\r\n    pointerEvents: \"none\",\r\n    display: \"flex\",\r\n    alignItems: \"center\",\r\n    justifyContent: \"center\",\r\n}));\r\n\r\nconst StyledInputBase = styled(InputBase)(({ theme }) => ({\r\n    color: \"inherit\",\r\n    \"& .MuiInputBase-input\": {\r\n        padding: theme.spacing(1, 1, 1, 0),\r\n        // vertical padding + font size from searchIcon\r\n        paddingLeft: `calc(1em + ${theme.spacing(4)})`,\r\n        transition: theme.transitions.create(\"width\"),\r\n        width: \"100%\",\r\n        [theme.breakpoints.up(\"sm\")]: {\r\n            width: \"0\",\r\n            cursor: \"pointer\",\r\n            \"&:focus\": {\r\n                width: \"20ch\",\r\n            },\r\n        },\r\n    },\r\n}));\r\n\r\nfunction TableOfContent() {\r\n    let data = [\r\n        { Id: 1, Title: \"chapter 1\", segment_id: 0 },\r\n        { Id: 2, Title: \"chapter 2\", segment_id: 400 },\r\n    ];\r\n    let loaded = data.length > 0 ? true : false;\r\n\r\n    return (\r\n        <Box\r\n            className={styles.TableContent}\r\n            sx={{\r\n                bgcolor: \"heading.main\",\r\n                color: \"text.primary\",\r\n                width: \"100%\",\r\n                height: \"100%\",\r\n                paddingInline: 2,\r\n            }}\r\n        >\r\n            <Toolbar\r\n                sx={{\r\n                    justifyContent: \"space-between\",\r\n                    paddingLeft: \"0 !important\",\r\n                    margin: 0,\r\n                }}\r\n            >\r\n                <Typography textTransform={\"uppercase\"} component=\"h6\">\r\n                    Table Of Content\r\n                </Typography>\r\n                <Search>\r\n                    <SearchIconWrapper>\r\n                        <SearchIcon />\r\n                    </SearchIconWrapper>\r\n                    <StyledInputBase\r\n                        placeholder=\"Search…\"\r\n                        inputProps={{ \"aria-label\": \"search\" }}\r\n                    />\r\n                </Search>\r\n            </Toolbar>\r\n            {/* <Loader loaded={loaded} /> */}\r\n            <Box>\r\n                {data.map((list, index) => {\r\n                    return (\r\n                        <Box\r\n                            key={\"TableContent-\" + index}\r\n                            sx={{\r\n                                cursor: \"pointer\",\r\n                                width: \"fit-content\",\r\n                                \"&:hover\": {\r\n                                    fontWeight: \"bold\",\r\n                                },\r\n                            }}\r\n                        >\r\n                            {list.Title}\r\n                        </Box>\r\n                    );\r\n                })}\r\n            </Box>\r\n        </Box>\r\n    );\r\n}\r\n\r\nexport default React.memo(TableOfContent);\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"paddingSide\":\"20px\",\"maxWidth\":\"600px\",\"text\":\"Text---text\",\"syncIdClass\":\"Text---syncIdClass\",\"textFirstRow\":\"Text---textFirstRow\",\"textLine\":\"Text---textLine\",\"textline\":\"Text---textline\",\"limitWidth\":\"Text---limitWidth\",\"textContainer\":\"Text---textContainer\",\"annotation\":\"Text---annotation\",\"selectedAnnotation\":\"Text---selectedAnnotation\",\"removedByAnnotation\":\"Text---removedByAnnotation\",\"insertion\":\"Text---insertion\",\"highlight\":\"Text---highlight\",\"activeHighlight\":\"Text---activeHighlight\",\"lineBreak\":\"Text---lineBreak\",\"pageBreak\":\"Text---pageBreak\",\"selectedRangelight\":\"Text---selectedRangelight\",\"selectedRangeDark\":\"Text---selectedRangeDark\",\"selectedImage\":\"Text---selectedImage\"};","// @flow\r\nimport React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport styles from \"./Text.css\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport {\r\n    INSERTION_KEY,\r\n    DELETION_KEY,\r\n    PAGE_BREAK_KEY,\r\n    LINE_BREAK_KEY,\r\n} from \"lib/AnnotatedText\";\r\nimport _ from \"lodash\";\r\nimport SegmentedText from \"lib/SegmentedText\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport Witness from \"lib/Witness\";\r\nimport { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport GraphemeSplitter from \"grapheme-splitter\";\r\nimport { find } from \"lodash\";\r\nimport { withTheme } from \"@mui/styles\";\r\n\r\nexport function idForSegment(segment: TextSegment): string {\r\n    return \"s_\" + segment.start;\r\n}\r\n\r\nexport function idForDeletedSegment(segment: TextSegment): string {\r\n    return \"ds_\" + segment.start;\r\n}\r\n\r\nexport function idForInsertion(segment: TextSegment): string {\r\n    return \"i_\" + segment.start;\r\n}\r\n\r\nexport function idForPageBreak(segment: TextSegment): string {\r\n    return \"p_\" + (segment.end + 1);\r\n}\r\n\r\nexport function idForLineBreak(segment: TextSegment): string {\r\n    return \"l_\" + (segment.end + 1);\r\n}\r\n\r\nexport type Props = {\r\n    segmentedText: SegmentedText,\r\n    annotationPositions: { [string]: Annotation[] },\r\n    selectedSegmentId: (id: string) => void,\r\n    activeAnnotations: { [AnnotationUniqueId]: Annotation } | null,\r\n    getBaseAnnotation: (annotation: Annotation) => Annotation,\r\n    selectedAnnotatedSegments: TextSegment[],\r\n    row: number,\r\n    activeAnnotation: Annotation | null,\r\n    searchValue: string | null,\r\n    selectedSearchResult: {\r\n        textId: number,\r\n        start: number,\r\n        length: number,\r\n    } | null,\r\n    searchStringPositions: { [position: number]: [number, number] },\r\n    fontSize?: number,\r\n    activeWitness: Witness,\r\n    changeSyncIdOnClick: () => void,\r\n    changeScrollToId: () => void,\r\n    textAlignmentById: {},\r\n    selectedSourceRange: [],\r\n    selectedTargetRange: [],\r\n};\r\n\r\nexport type State = {\r\n    segmentedText: SegmentedText,\r\n};\r\n\r\nimport ReactDOMServer from \"react-dom/server\";\r\nimport PageBreakIcon from \"images/page_break_icon.svg\";\r\nconst PARA_SYMBOL = String.fromCharCode(182);\r\nconst pageBreakIconString = ReactDOMServer.renderToStaticMarkup(\r\n    <PageBreakIcon />\r\n);\r\nclass Text extends React.Component<Props, State> {\r\n    _renderedSegments: TextSegment[] | null;\r\n    _renderedHtml: { __html: string } | null;\r\n    textAlignmentById;\r\n    rangeSelect;\r\n    theme;\r\n    constructor(props: Props) {\r\n        super(props);\r\n        this.textAlignmentById = [];\r\n        this.state = {\r\n            segmentedText: props.segmentedText,\r\n        };\r\n        this.textAlignmentById = this.props.textAlignmentById;\r\n        this._renderedSegments = null;\r\n        this._renderedHtml = null;\r\n        this.rangeSelect = [];\r\n        this.theme = props.theme;\r\n    }\r\n    UNSAFE_componentWillReceiveProps(nextProps: Props) {\r\n        this.setState((prevState: State, props: Props) => {\r\n            return {\r\n                ...prevState,\r\n                segmentedText: nextProps.segmentedText,\r\n            };\r\n        });\r\n    }\r\n\r\n    annotationsForSegment(segment: TextSegment): Annotation[] {\r\n        let annotations: Annotation[] = [];\r\n        const foundAnnotations =\r\n            this.props.annotationPositions[String(segment.start)];\r\n        if (foundAnnotations) {\r\n            annotations = foundAnnotations;\r\n        }\r\n        const insertions =\r\n            this.props.annotationPositions[INSERTION_KEY + segment.start] || [];\r\n        const deletions =\r\n            this.props.annotationPositions[DELETION_KEY + segment.start] || [];\r\n        const pageBreaks =\r\n            this.props.annotationPositions[\r\n                PAGE_BREAK_KEY + (segment.end + 1)\r\n            ] || [];\r\n        const lineBreaks =\r\n            this.props.annotationPositions[\r\n                LINE_BREAK_KEY + (segment.end + 1)\r\n            ] || [];\r\n\r\n        return annotations.concat(\r\n            insertions,\r\n            deletions,\r\n            pageBreaks,\r\n            lineBreaks\r\n        );\r\n    }\r\n\r\n    segmentsContainSegment(segments: TextSegment[], segment: TextSegment) {\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let listSegment = segments[i];\r\n            if (\r\n                listSegment.start === segment.start &&\r\n                listSegment.text === segment.text\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    selectedElement(element: Element) {\r\n        if (element.tagName === \"DIV\") {\r\n            this.props.selectedSegmentId(\"\");\r\n            return;\r\n        }\r\n        let sourceRangeSelection = [];\r\n        let targetRangeSelection = [];\r\n        const selection = document.getSelection();\r\n        var clickId = parseInt(element.id.replace(\"s_\", \"\"));\r\n        this.props.changeSyncIdOnClick(clickId);\r\n        if (element?.id.includes(\"s_\") && this.props.condition) {\r\n            this.props.changeScrollToId({ id: null, from: null });\r\n\r\n            let id = parseInt(element.id.replace(\"s_\", \"\"));\r\n            let rangeUnique = find(\r\n                this.textAlignmentById,\r\n                (l) => id >= l.start && id < l.end\r\n            );\r\n            if (rangeUnique) {\r\n                for (let i = rangeUnique.start; i < rangeUnique.end; i++) {\r\n                    sourceRangeSelection.push(i);\r\n                }\r\n                for (let i = rangeUnique.TStart; i < rangeUnique.TEnd; i++) {\r\n                    targetRangeSelection.push(i);\r\n                }\r\n                this.props.changeSelectedRange({\r\n                    source: sourceRangeSelection,\r\n                    target: targetRangeSelection,\r\n                });\r\n            }\r\n        }\r\n\r\n        if (selection && selection.type === \"Range\") {\r\n            return;\r\n        }\r\n        this.props.selectedSegmentId(element.id);\r\n\r\n        if (!element.id) {\r\n            this.props.changeSelectedRange({ source: [], target: [] });\r\n        }\r\n    }\r\n\r\n    generateHtml(renderProps: Props, renderState: State): { __html: string } {\r\n        let segments = renderState.segmentedText.segments;\r\n\r\n        let textLineClass = styles.textLine;\r\n        let segmentHTML = '<p class=\"' + textLineClass + '\">';\r\n        if (segments.length === 0) return { __html: segmentHTML };\r\n\r\n        const insertionClass = styles.insertion;\r\n        const endPosition = segments[segments.length - 1].end + 1;\r\n        if (renderProps.annotationPositions[INSERTION_KEY + endPosition]) {\r\n            const endSegment = new TextSegment(endPosition, \"\");\r\n            segments.push(endSegment);\r\n        }\r\n        if (renderProps.annotationPositions[PAGE_BREAK_KEY + endPosition]) {\r\n            const endSegment = new TextSegment(endPosition, \"\");\r\n            segments.push(endSegment);\r\n        }\r\n        if (renderProps.annotationPositions[LINE_BREAK_KEY + endPosition]) {\r\n            const endSegment = new TextSegment(endPosition, \"\");\r\n            segments.push(endSegment);\r\n        }\r\n\r\n        let activeAnnotations = renderProps.activeAnnotations || {};\r\n\r\n        let highlightClass = styles.highlight;\r\n        let activeHighlightClass = styles.activeHighlight;\r\n        let activeSearchResultEnd = null;\r\n        let processedInactiveInsertions = {};\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let segment = segments[i];\r\n            let classAttribute = \"\";\r\n            let classes = [];\r\n            let annotations = this.annotationsForSegment(segment);\r\n            let deletionText = null;\r\n            let selectedCurrentDeletion = false;\r\n            let selectedCurrentPageBreak = false;\r\n            let selectedCurrentLineBreak = false;\r\n            let lineBreakAnnotation = false;\r\n            let pageBreakAnnotation = null;\r\n\r\n            if (annotations) {\r\n                let activeInsertions = [];\r\n                let inactiveInsertions = [];\r\n                let remainingAnnotations = [];\r\n                let activeDeletions = [];\r\n\r\n                for (let j = 0, len = annotations.length; j < len; j++) {\r\n                    let annotation = annotations[j];\r\n                    if (annotation.isInsertion) {\r\n                        if (annotation.uniqueId in activeAnnotations) {\r\n                            activeInsertions.push(annotation);\r\n                        } else {\r\n                            // Only first inactive insertion at a position will\r\n                            // be shown, so only process first one.\r\n                            // TODO: need to check if there is an active insertion\r\n                            // at the same place. If so, ignore inactive insertion\r\n                            // as they should be shown in the popover.\r\n                            const annotationKey = annotation.start;\r\n                            if (\r\n                                !processedInactiveInsertions.hasOwnProperty(\r\n                                    annotationKey\r\n                                )\r\n                            ) {\r\n                                inactiveInsertions.push(annotation);\r\n                                processedInactiveInsertions[annotationKey] =\r\n                                    annotation;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (annotation.isDeletion) {\r\n                            if (annotation.uniqueId in activeAnnotations) {\r\n                                activeDeletions.push(annotation);\r\n                            }\r\n                        } else if (\r\n                            annotation.type === ANNOTATION_TYPES.pageBreak &&\r\n                            !renderProps.activeWitness.isWorking\r\n                        ) {\r\n                            pageBreakAnnotation = annotation;\r\n                        } else if (\r\n                            annotation.type === ANNOTATION_TYPES.lineBreak &&\r\n                            !renderProps.activeWitness.isWorking\r\n                        ) {\r\n                            lineBreakAnnotation = annotation;\r\n                        } else {\r\n                            remainingAnnotations.push(annotation);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (\r\n                    activeInsertions.length === 0 &&\r\n                    inactiveInsertions.length > 0\r\n                ) {\r\n                    const insertion = inactiveInsertions[0];\r\n                    const insertionId = idForInsertion(segment);\r\n                    let insertionClasses = insertionClass;\r\n                    if (\r\n                        renderProps.activeAnnotation &&\r\n                        renderProps.activeAnnotation.isInsertion &&\r\n                        renderProps.activeAnnotation.start === insertion.start\r\n                    ) {\r\n                        insertionClasses += \" \" + styles.selectedAnnotation;\r\n                    }\r\n\r\n                    segmentHTML +=\r\n                        \"<span id=\" +\r\n                        insertionId +\r\n                        \" key=\" +\r\n                        insertionId +\r\n                        ' class=\"' +\r\n                        insertionClasses +\r\n                        '\">' +\r\n                        insertion.content +\r\n                        \"</span>\";\r\n                }\r\n\r\n                if (activeDeletions.length > 0) {\r\n                    const activeDeletion = activeDeletions[0];\r\n                    const baseAnnotation =\r\n                        renderProps.getBaseAnnotation(activeDeletion);\r\n                    deletionText = baseAnnotation.content;\r\n                    if (\r\n                        renderProps.activeAnnotation &&\r\n                        renderProps.activeAnnotation.isDeletion &&\r\n                        renderProps.activeAnnotation.start ===\r\n                            activeDeletion.start &&\r\n                        renderProps.activeAnnotation.length ===\r\n                            activeDeletion.length &&\r\n                        segment.length === 0\r\n                    ) {\r\n                        selectedCurrentDeletion = true;\r\n                    }\r\n                }\r\n\r\n                if (pageBreakAnnotation) {\r\n                    if (\r\n                        renderProps.activeAnnotation &&\r\n                        renderProps.activeAnnotation.uniqueId ===\r\n                            pageBreakAnnotation.uniqueId\r\n                    ) {\r\n                        selectedCurrentPageBreak = true;\r\n                    }\r\n                }\r\n\r\n                if (lineBreakAnnotation) {\r\n                    if (\r\n                        renderProps.activeAnnotation &&\r\n                        renderProps.activeAnnotation.uniqueId ===\r\n                            lineBreakAnnotation.uniqueId\r\n                    ) {\r\n                        selectedCurrentLineBreak = true;\r\n                    }\r\n                }\r\n\r\n                if (\r\n                    remainingAnnotations.length > 0 ||\r\n                    activeInsertions.length > 0\r\n                ) {\r\n                    classes.push(styles.annotation);\r\n                }\r\n            }\r\n\r\n            // It's an insertion at the end of the text, which should have just been added to the html.\r\n            // So break as we don't want anymore segment html adding.\r\n            if (segment.start === endPosition) {\r\n                break;\r\n            }\r\n\r\n            let id = null;\r\n            if (segment.length === 0) {\r\n                id = idForDeletedSegment(segment);\r\n                classes.push(styles.removedByAnnotation);\r\n                if (deletionText) {\r\n                    segment = new TextSegment(segment.start, deletionText);\r\n                }\r\n            } else {\r\n                id = idForSegment(segment);\r\n            }\r\n\r\n            if (\r\n                this.segmentsContainSegment(\r\n                    renderProps.selectedAnnotatedSegments,\r\n                    segment\r\n                ) ||\r\n                selectedCurrentDeletion\r\n            ) {\r\n                classes.push(styles.selectedAnnotation);\r\n            }\r\n\r\n            if (\r\n                renderProps.selectedSourceRange.includes(segment.start) &&\r\n                renderProps.condition\r\n            ) {\r\n                let newClass =\r\n                    renderProps.theme.palette.mode === \"light\"\r\n                        ? styles.selectedRangelight\r\n                        : styles.selectedRangeDark;\r\n                classes.push(newClass);\r\n            }\r\n\r\n            if (classes.length > 0) {\r\n                let className = classnames(...classes);\r\n                classAttribute = 'class=\"' + className + '\"';\r\n            }\r\n\r\n            let segmentContent = segment.text;\r\n\r\n            // Add search result highlight if required.\r\n            if (renderProps.searchStringPositions) {\r\n                let segmentStart = segment.start;\r\n                let position = segmentStart;\r\n                segmentContent = \"\";\r\n\r\n                let highlight = highlightClass;\r\n                if (\r\n                    renderProps.selectedSearchResult &&\r\n                    renderProps.selectedSearchResult.start <= position &&\r\n                    renderProps.selectedSearchResult.start +\r\n                        renderProps.selectedSearchResult.length >\r\n                        position\r\n                ) {\r\n                    highlight = activeHighlightClass;\r\n                }\r\n\r\n                for (let j = 0; j < segment.text.length; j++) {\r\n                    let char = segment.text.charAt(j);\r\n                    position = segmentStart + j;\r\n                    if (activeSearchResultEnd) {\r\n                        let [start, end] = activeSearchResultEnd;\r\n                        if (j === 0) {\r\n                            segmentContent +=\r\n                                '<span class=\"' + highlight + '\">';\r\n                        }\r\n                        if (position === end) {\r\n                            segmentContent += char + \"</span>\";\r\n                            activeSearchResultEnd = null;\r\n                        } else if (j === segment.text.length - 1) {\r\n                            segmentContent += char + \"</span>\";\r\n                        } else {\r\n                            segmentContent += char;\r\n                        }\r\n                    } else if (position in renderProps.searchStringPositions) {\r\n                        let [start, end] =\r\n                            renderProps.searchStringPositions[position];\r\n                        segmentContent +=\r\n                            '<span class=\"' + highlight + '\">' + char;\r\n                        if (j === segment.text.length - 1 || position === end) {\r\n                            segmentContent += \"</span>\";\r\n                        }\r\n                        if (position < end) {\r\n                            activeSearchResultEnd = [start, end];\r\n                        }\r\n                    } else {\r\n                        segmentContent += char;\r\n                    }\r\n                }\r\n            }\r\n\r\n            segmentHTML +=\r\n                \"<span id=\" +\r\n                id +\r\n                \" key=\" +\r\n                id +\r\n                \" \" +\r\n                classAttribute +\r\n                \">\" +\r\n                segmentContent +\r\n                \"</span>\";\r\n\r\n            if (pageBreakAnnotation) {\r\n                let pageBreakClasses = [styles.pageBreak];\r\n                if (selectedCurrentPageBreak) {\r\n                    pageBreakClasses.push(styles.selectedAnnotation);\r\n                }\r\n                const pageBreakClassAttribute =\r\n                    ' class=\"' + pageBreakClasses.join(\" \") + '\" ';\r\n                segmentHTML +=\r\n                    \"<span id=\" +\r\n                    idForPageBreak(segment) +\r\n                    \" key=\" +\r\n                    idForPageBreak(segment) +\r\n                    pageBreakClassAttribute +\r\n                    \">\" +\r\n                    pageBreakIconString +\r\n                    \"</span>\";\r\n            }\r\n            if (lineBreakAnnotation) {\r\n                let lineBreakClasses = [styles.lineBreak];\r\n                if (selectedCurrentLineBreak) {\r\n                    lineBreakClasses.push(styles.selectedAnnotation);\r\n                }\r\n                const lineBreakClassAttribute =\r\n                    ' class=\"' + lineBreakClasses.join(\" \") + '\" ';\r\n                segmentHTML +=\r\n                    \"<span id=\" +\r\n                    idForLineBreak(segment) +\r\n                    \" key=\" +\r\n                    idForLineBreak(segment) +\r\n                    lineBreakClassAttribute +\r\n                    \">\" +\r\n                    PARA_SYMBOL +\r\n                    \"</span>\";\r\n\r\n                segmentHTML += '</p><p class=\"' + textLineClass + '\">';\r\n            }\r\n        }\r\n\r\n        this._renderedSegments = segments;\r\n\r\n        segmentHTML += \"</p>\";\r\n        const html = {\r\n            __html: segmentHTML,\r\n        };\r\n        return html;\r\n    }\r\n    shouldComponentUpdate(nextProps: Props, nextState: State) {\r\n        const renderedHtml = this.generateHtml(nextProps, nextState);\r\n\r\n        if (this.props.fontSize !== nextProps.fontSize) {\r\n            return true;\r\n        } else if (\r\n            this._renderedHtml &&\r\n            renderedHtml.__html === this._renderedHtml.__html\r\n        ) {\r\n            return false;\r\n        } else {\r\n            this._renderedHtml = renderedHtml;\r\n            return true;\r\n        }\r\n        // return false;\r\n    }\r\n    componentDidUpdate() {\r\n        this.textAlignmentById = this.props.textAlignmentById;\r\n    }\r\n\r\n    render() {\r\n        let classes = [styles.text];\r\n        if (this.props.row === 0) {\r\n            classes.push(styles.textFirstRow);\r\n        }\r\n        // Generate HTML manually as it is much faster when\r\n        // creating large numbers of elements, such as these spans.\r\n        const html = this._renderedHtml\r\n            ? this._renderedHtml\r\n            : this.generateHtml(this.props, this.state);\r\n        if (!this._renderedHtml) {\r\n            this._renderedHtml = html;\r\n        }\r\n        return (\r\n            <div className={styles.textContainer}>\r\n                <div\r\n                    className={classnames(...classes)}\r\n                    id=\"text1\"\r\n                    dangerouslySetInnerHTML={html}\r\n                    style={{\r\n                        fontSize: this.props.fontSize,\r\n                        fontFamily: \"var(--tibetan-fonts)\",\r\n                    }}\r\n                    onClick={(e) => {\r\n                        this.selectedElement(e.target);\r\n                    }}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default withTheme(Text);\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"textDetail\":\"TextDetail---textDetail\",\"textContainer\":\"TextDetail---textContainer\",\"tableContent\":\"TextDetail---tableContent\"};","// @flow\r\nimport React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport imageStyle from \"components/MediaComponent/Image.css\";\r\n\r\nimport Loader from \"react-loader\";\r\nimport AnnotationControlsContainer from \"./AnnotationControlsContainer\";\r\nimport SplitText from \"lib/SplitText\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport Witness from \"lib/Witness\";\r\nimport AnnotatedText from \"lib/AnnotatedText\";\r\nimport lengthSplitter from \"lib/text_splitters/lengthSplitter\";\r\nimport positionSplitter from \"lib/text_splitters/positionSplitter\";\r\nimport headerStyles from \"components/Header/Header.css\";\r\nimport styles from \"./TextDetail.css\";\r\nimport utilStyles from \"css/util.css\";\r\nimport type { TextData } from \"api\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport TextDetailHeadingContainer from \"./TextDetailHeadingContainer\";\r\nimport { Box, ClickAwayListener, Divider, Slide } from \"@mui/material\";\r\nimport _ from \"lodash\";\r\nimport TableOfContent from \"./TableOfContent/TableOfContent\";\r\n\r\nimport SplitTextComponent from \"components/TextDetail/SplitText\";\r\n\r\nexport type Props = {\r\n    condition: Boolean,\r\n    paginated: boolean,\r\n    pageImagesVisible: boolean,\r\n    text: TextData | null,\r\n    loading: boolean,\r\n    pageBreaks: number[],\r\n    annotatedText: AnnotatedText,\r\n    annotations: Annotation[],\r\n    activeAnnotations: Annotation[],\r\n    activeAnnotation: Annotation | null,\r\n    didSelectSegmentIds: (segmentIds: string[]) => void,\r\n    selectedSegmentId: (segmentId: string) => void,\r\n    annotationPositions: { [string]: Annotation[] },\r\n    selectedAnnotatedSegments: Array<TextSegment | number>,\r\n    textListVisible: boolean,\r\n    imagesBaseUrl: string,\r\n    selectedWitness: Witness | null,\r\n    selectedSearchResult: {\r\n        textId: number,\r\n        start: number,\r\n        length: number,\r\n    } | null,\r\n    searchValue: string | null,\r\n    fontSize: number,\r\n    isSecondWindowOpen: Boolean,\r\n    imageData: {},\r\n    isPanelLinked: boolean,\r\n    isPanelVisible: Boolean,\r\n    changeSyncIdOnClick: () => void,\r\n    changeScrollToId: () => void,\r\n    changeSelectedImage: () => void,\r\n    closeAnnotation: () => void,\r\n    textAlignmentById: {},\r\n    selectedWindow: Number,\r\n    changeSelectedWindow: () => void,\r\n    changeSelectedRange: [],\r\n    scrollToId: {},\r\n    selectedSourceRange: [],\r\n    selectedTargetRange: [],\r\n    searchResults: [],\r\n    changeShowTableContent: () => void,\r\n    showTableContent: Boolean,\r\n    syncIdOnSearch: String,\r\n    imageAlignmentById: [],\r\n    changeImageScrollId: () => void,\r\n    imageScrollId: {},\r\n};\r\n\r\nlet textDetailId = 0;\r\n\r\nclass TextDetail extends React.Component<Props> {\r\n    key: number;\r\n    ref;\r\n    selectedWindow;\r\n    constructor() {\r\n        super();\r\n        this.key = textDetailId++;\r\n        this.ref = React.createRef();\r\n        this.selectedWindow = null;\r\n    }\r\n\r\n    mouseEnter() {\r\n        if (this.selectedWindow === 2) this.props.changeSelectedWindow(1);\r\n    }\r\n    componentDidMount() {\r\n        this.ref.current.addEventListener(\r\n            \"mouseenter\",\r\n            this.mouseEnter.bind(this)\r\n        );\r\n    }\r\n    componentDidUpdate() {\r\n        this.selectedWindow = this.props.selectedWindow;\r\n    }\r\n\r\n    render() {\r\n        let text = {\r\n            name: \"\",\r\n        };\r\n        if (this.props.text) {\r\n            text = this.props.text;\r\n        }\r\n        let inlineControls = false;\r\n        let textComponent = null;\r\n        let splitText = null;\r\n        if (\r\n            !this.props.annotatedText ||\r\n            !this.props.text ||\r\n            this.props.loading\r\n        ) {\r\n            textComponent = <div key={this.key} />;\r\n        } else {\r\n            let limitWidth = false;\r\n            let splitter;\r\n            if (this.props.paginated) {\r\n                splitter = positionSplitter(this.props.pageBreaks);\r\n            } else {\r\n                splitter = lengthSplitter(1000, /^།[\\s]+(?!།[\\s]+)/, 2, 5);\r\n            }\r\n\r\n            splitText = new SplitText(this.props.annotatedText, splitter);\r\n\r\n            inlineControls = true;\r\n            textComponent = (\r\n                <SplitTextComponent\r\n                    splitText={splitText}\r\n                    annotations={this.props.annotations}\r\n                    activeAnnotations={this.props.activeAnnotations}\r\n                    activeAnnotation={this.props.activeAnnotation}\r\n                    limitWidth={limitWidth}\r\n                    didSelectSegmentIds={this.props.didSelectSegmentIds}\r\n                    selectedSegmentId={this.props.selectedSegmentId}\r\n                    annotationPositions={this.props.annotationPositions}\r\n                    selectedAnnotatedSegments={\r\n                        this.props.selectedAnnotatedSegments\r\n                    }\r\n                    syncIdOnClick={this.props.syncIdOnClick}\r\n                    textListVisible={this.props.textListVisible}\r\n                    showImages={this.props.pageImagesVisible}\r\n                    // showImages={this.props.selectedMedia.isImageVisible}\r\n                    imagesBaseUrl={this.props.imagesBaseUrl}\r\n                    selectedWitness={this.props.selectedWitness}\r\n                    selectedWitness2={this.props.selectedWitness2}\r\n                    key={this.key}\r\n                    selectedSearchResult={this.props.selectedSearchResult}\r\n                    searchValue={this.props.searchValue}\r\n                    fontSize={this.props.fontSize}\r\n                    isSecondWindowOpen={this.props.isSecondWindowOpen}\r\n                    changeScrollToId={this.props.changeScrollToId}\r\n                    changeSyncIdOnClick={this.props.changeSyncIdOnClick}\r\n                    imageData={this.props.imageData}\r\n                    isPanelLinked={this.props.isPanelLinked}\r\n                    selectedImage={this.props.selectedImage}\r\n                    changeSelectedImage={this.props.changeSelectedImage}\r\n                    isAnnotating={this.props.isAnnotating}\r\n                    closeAnnotation={this.props.closeAnnotation}\r\n                    textAlignment={this.props.textAlignment}\r\n                    textAlignmentById={this.props.textAlignmentById}\r\n                    isPanelVisible={this.props.isPanelVisible}\r\n                    scrollToId={this.props.scrollToId}\r\n                    selectedWindow={this.selectedWindow}\r\n                    selectedSourceRange={this.props.selectedSourceRange}\r\n                    selectedTargetRange={this.props.selectedTargetRange}\r\n                    changeSelectedRange={this.props.changeSelectedRange}\r\n                    searchResults={this.props.searchResults}\r\n                    showTableContent={this.props.showTableContent}\r\n                    selectedText={this.props.text}\r\n                    syncIdOnSearch={this.props.syncIdOnSearch}\r\n                    imageAlignmentById={this.props.imageAlignmentById}\r\n                    changeImageScrollId={this.props.changeImageScrollId}\r\n                    imageScrollId={this.props.imageScrollId}\r\n                    condition={this.props.condition}\r\n                />\r\n            );\r\n        }\r\n        let textComponents = [textComponent];\r\n        return (\r\n            <Box\r\n                sx={{\r\n                    height: \"100%\",\r\n                    flex: 1,\r\n                    bgcolor: \"navbar.main\",\r\n                    color: \"texts.main\",\r\n                }}\r\n                className={classnames(\r\n                    styles.textDetail,\r\n                    utilStyles.flex,\r\n                    utilStyles.flexColumn\r\n                )}\r\n                key={this.key}\r\n                ref={this.ref}\r\n            >\r\n                <TextDetailHeadingContainer />\r\n                <Divider />\r\n                <Loader loaded={!this.props.loading} zIndex={5} />\r\n                <Box\r\n                    style={{\r\n                        display: \"flex\",\r\n                        height: \"100%\",\r\n                        width: \"100%\",\r\n                        position: \"relative\",\r\n                    }}\r\n                >\r\n                    <Box\r\n                        style={{ flex: 1 }}\r\n                        className={classnames(\r\n                            styles.textContainer,\r\n                            utilStyles.flex\r\n                        )}\r\n                    >\r\n                        {!this.props.loading ? textComponents : <div />}\r\n                    </Box>\r\n\r\n                    <Slide\r\n                        direction=\"left\"\r\n                        in={this.props.showTableContent}\r\n                        container={this.ref.current}\r\n                        unmountOnExit\r\n                        mountOnEnter\r\n                    >\r\n                        <Box\r\n                            sx={{\r\n                                position: \"absolute\",\r\n                                height: \"100%\",\r\n                                minWidth: \"50%\",\r\n                                right: 0,\r\n                            }}\r\n                        >\r\n                            <TableOfContent />\r\n                        </Box>\r\n                    </Slide>\r\n                </Box>\r\n            </Box>\r\n        );\r\n    }\r\n}\r\n\r\nexport default TextDetail;\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport Annotation, { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport Source, { WORKING_VERSION_SOURCE_NAME } from \"lib/Source\";\r\nimport Witness from \"lib/Witness\";\r\nimport Text from \"lib/Text\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport type { AppState } from \"reducers\";\r\nimport type { AnnotationData, TextData } from \"api\";\r\nimport {\r\n    WORKING_VERSION_ANNOTATION_ID,\r\n    INSERTION_KEY,\r\n    DELETION_KEY,\r\n    PAGE_BREAK_KEY,\r\n    LINE_BREAK_KEY,\r\n} from \"lib/AnnotatedText\";\r\nimport TextDetail from \"components/TextDetail\";\r\nimport {\r\n    changedActiveAnnotation,\r\n    changedActiveTextAnnotation,\r\n    changedWitnessScrollPosition,\r\n} from \"actions\";\r\nimport {\r\n    showPageImages,\r\n    getAnnotationsForWitnessId,\r\n    getActiveAnnotationsForWitnessId,\r\n    getActiveAnnotation,\r\n    getActiveTextAnnotation,\r\n    getBaseWitness,\r\n    getWorkingWitness,\r\n    getSelectedText,\r\n    annotationFromData,\r\n    getAnnotationData,\r\n    getUser,\r\n    getTextListVisible,\r\n    getSelectedTextWitnessId,\r\n    getTextWitnesses,\r\n    getWitness,\r\n    hasLoadedWitnessAnnotations,\r\n    getRemovedDefaultAnnotationsForWitnessId,\r\n    hasLoadedWitnessAppliedAnnotations,\r\n    getScrollPosition,\r\n    getSelectedSearchResult,\r\n    getSearchValue,\r\n    getTextFontSize,\r\n    isSecondWindowOpen,\r\n    getImageData,\r\n    getSelectedImage,\r\n    isImagePortrait,\r\n    isPanelVisible,\r\n    getSelectedSourceRange,\r\n    getSelectedTargetRange,\r\n    getSearchResults,\r\n    getShowTableContent,\r\n    getImageAlignmentById,\r\n    getImageScrollId,\r\n} from \"reducers\";\r\nimport * as reducers from \"reducers\";\r\nimport _ from \"lodash\";\r\n\r\nimport AnnotatedText from \"lib/AnnotatedText\";\r\nimport segmentTibetanText from \"lib/segmentTibetanText\";\r\nimport SegmentedText from \"lib/SegmentedText\";\r\nimport * as actions from \"actions\";\r\nimport * as constants from \"app_constants\";\r\nimport * as TextStore from \"state_helpers/TextStore\";\r\n\r\nconst DISMISS_CONTROLS_ON_CLICK = false;\r\nfunction getInsertionKey(annotation) {\r\n    return [annotation.start, annotation.length].join(\"-\");\r\n}\r\n\r\nlet _posAnnotatedText;\r\nlet _posAnnotations;\r\nlet _positions;\r\nlet _posVersion;\r\nconst getAnnotationPositions = (\r\n    annotatedText: AnnotatedText,\r\n    annotations: Annotation[]\r\n): { [string]: Annotation[] } => {\r\n    if (\r\n        annotatedText === _posAnnotatedText &&\r\n        annotations === _posAnnotations &&\r\n        annotatedText.version === _posVersion\r\n    ) {\r\n        return _positions;\r\n    }\r\n\r\n    let positions = {};\r\n    let activeInsertions = {};\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n        let annotation = annotations[i];\r\n        let [startPos, length] =\r\n            annotatedText.getPositionOfAnnotation(annotation);\r\n        if (startPos == null) {\r\n            continue;\r\n        }\r\n        if (length === 0) {\r\n            if (annotation.isInsertion) {\r\n                // group with any active insertions at the same position\r\n                const activeKey = getInsertionKey(annotation);\r\n                const activeInsertionPositions = activeInsertions[activeKey];\r\n                if (activeInsertionPositions) {\r\n                    activeInsertionPositions.map((pos) =>\r\n                        positions[pos].push(annotation)\r\n                    );\r\n                    continue;\r\n                }\r\n                startPos = INSERTION_KEY + startPos;\r\n            }\r\n            if (annotation.isDeletion && annotation.length > 0) {\r\n                // active deletion\r\n                startPos = DELETION_KEY + startPos;\r\n            }\r\n            if (annotation.type === ANNOTATION_TYPES.pageBreak) {\r\n                startPos = PAGE_BREAK_KEY + startPos;\r\n            }\r\n            if (annotation.type === ANNOTATION_TYPES.lineBreak) {\r\n                startPos = LINE_BREAK_KEY + startPos;\r\n            }\r\n            if (positions[startPos] === undefined) {\r\n                positions[startPos] = [];\r\n            }\r\n            if (positions[startPos].indexOf(annotation) === -1) {\r\n                positions[startPos].push(annotation);\r\n            }\r\n        } else {\r\n            let annotationPositions = [];\r\n            for (let j = startPos; j < startPos + length; j++) {\r\n                if (positions[j] === undefined) {\r\n                    positions[j] = [];\r\n                }\r\n                if (positions[j].indexOf(annotation) === -1) {\r\n                    positions[j].push(annotation);\r\n                }\r\n                annotationPositions.push(j);\r\n            }\r\n            // Store the positions this annotation is displayed at.\r\n            // This can then be used later to group with inactive insertions\r\n            if (annotation.isInsertion) {\r\n                const key = getInsertionKey(annotation);\r\n                activeInsertions[key] = annotationPositions;\r\n            }\r\n        }\r\n    }\r\n\r\n    _posAnnotatedText = annotatedText;\r\n    _posAnnotations = annotations;\r\n    _positions = positions;\r\n    _posVersion = annotatedText.version;\r\n    return positions;\r\n};\r\n\r\nlet _selectedWitness = null;\r\n\r\nconst mapStateToProps = (state) => {\r\n    const user = getUser(state);\r\n    const loading =\r\n        state.data.loadingWitnesses || state.data.loadingAnnotations;\r\n    const textListVisible = getTextListVisible(state);\r\n    const isPanelLinked = reducers.isPanelLinked(state);\r\n    const textAlignmentById = reducers.getTextAlignmentById(state);\r\n\r\n    if (loading) {\r\n        return {\r\n            text: null,\r\n            witnesses: null,\r\n            baseWitness: null,\r\n            annotations: null,\r\n            loading: loading,\r\n            paginated: null,\r\n            pageImagesVisible: true,\r\n            annotatedText: null,\r\n            selectedAnnotatedSegments: null,\r\n            annotationPositions: null,\r\n            activeAnnotations: null,\r\n            activeAnnotation: null,\r\n            user: user,\r\n            textListVisible,\r\n            fontSize: constants.DEFAULT_TEXT_FONT_SIZE,\r\n            isPanelLinked,\r\n            textAlignmentById,\r\n            imageAlignmentById: getImageAlignmentById(state),\r\n        };\r\n    }\r\n\r\n    const selectedText = getSelectedText(state);\r\n    let witnesses = {};\r\n    let workingWitness;\r\n    let baseWitness;\r\n    if (selectedText) {\r\n        workingWitness = getWorkingWitness(state, selectedText.id);\r\n        baseWitness = getBaseWitness(state, selectedText.id);\r\n    }\r\n    let selectedSearchResult = getSelectedSearchResult(state);\r\n    let annotationPositions = {};\r\n    let annotations = [];\r\n    let annotatedText = null;\r\n    let activeAnnotation = getActiveTextAnnotation(state);\r\n    let selectedAnnotatedSegments = [];\r\n    let appliedAnnotations = {};\r\n    let pageBreaks = [];\r\n    let imagesBaseUrl = \"\";\r\n    let selectedWitness;\r\n    let searchValue = getSearchValue(state);\r\n    // Whether to show the text's page images\r\n    let paginated = false;\r\n    let pageImagesVisible = false;\r\n    let fontSize = getTextFontSize(state);\r\n    if (\r\n        workingWitness &&\r\n        selectedText &&\r\n        state.data.witnessAnnotationsById.hasOwnProperty(workingWitness.id)\r\n    ) {\r\n        witnesses = getTextWitnesses(state, selectedText.id);\r\n        let selectedWitnessId = getSelectedTextWitnessId(\r\n            state,\r\n            selectedText.id\r\n        );\r\n        if (selectedWitnessId) {\r\n            selectedWitness = getWitness(state, selectedWitnessId);\r\n        }\r\n        if (!selectedWitness) {\r\n            selectedWitness = workingWitness;\r\n            selectedWitnessId = workingWitness.id;\r\n        }\r\n\r\n        if (selectedWitness.id !== workingWitness.id) {\r\n            paginated = true;\r\n            pageImagesVisible = showPageImages(state);\r\n        }\r\n\r\n        annotatedText = TextStore.getWitnessText(state, selectedWitness.id);\r\n\r\n        [appliedAnnotations, annotations] = TextStore.getWitnessAnnotations(\r\n            state,\r\n            selectedWitness,\r\n            workingWitness\r\n        );\r\n\r\n        if (annotatedText) {\r\n            annotationPositions = getAnnotationPositions(\r\n                annotatedText,\r\n                (Object.values(annotations): any)\r\n            );\r\n        }\r\n\r\n        // Get the segments that are part of the current active annotation.\r\n        // These are used by Text to highlight the currently selected segment.\r\n        if (activeAnnotation && annotatedText) {\r\n            // If we've just switched witnesses, make sure we select the\r\n            // correct part of the text by getting a new annotation.\r\n            if (\r\n                !_selectedWitness ||\r\n                _selectedWitness.id !== selectedWitness.id\r\n            ) {\r\n                activeAnnotation = annotatedText.getAnnotation(\r\n                    activeAnnotation.start,\r\n                    activeAnnotation.length\r\n                );\r\n            }\r\n            if (activeAnnotation) {\r\n                selectedAnnotatedSegments =\r\n                    annotatedText.segmentsForAnnotation(activeAnnotation);\r\n            }\r\n        }\r\n        if (selectedWitness && baseWitness && annotatedText) {\r\n            let witnessPageBreaks =\r\n                annotatedText.getAnnotationsOfType(\r\n                    ANNOTATION_TYPES.pageBreak\r\n                ) || {};\r\n            let basePageBreaks = null;\r\n            if (selectedWitness.id !== baseWitness.id) {\r\n                basePageBreaks = getAnnotationsForWitnessId(\r\n                    state,\r\n                    workingWitness.id,\r\n                    ANNOTATION_TYPES.pageBreak,\r\n                    baseWitness.id\r\n                );\r\n            }\r\n\r\n            pageBreaks = getPageBreaks(witnessPageBreaks, basePageBreaks);\r\n            for (let i = 0, len = pageBreaks.length; i < len; i++) {\r\n                let position = pageBreaks[i];\r\n                let segment = annotatedText.segmentAtOriginalPosition(position);\r\n                if (segment instanceof TextSegment) {\r\n                    pageBreaks[i] = segment.start;\r\n                } else if (segment instanceof Number) {\r\n                    pageBreaks[i] = segment;\r\n                }\r\n            }\r\n\r\n            if (paginated) {\r\n                imagesBaseUrl =\r\n                    \"/static/images/texts/\" +\r\n                    selectedText.name +\r\n                    \"/\" +\r\n                    selectedWitness.source.name +\r\n                    \"/\";\r\n            }\r\n        }\r\n    }\r\n    _selectedWitness = selectedWitness;\r\n    const scrollToId = reducers.getScrollToId(state);\r\n    const textAlignment = reducers.getTextAlignment(state);\r\n    const syncIdOnClick = reducers.getSyncIdOnClick(state);\r\n    const selectedWindow = reducers.getSelectedWindow(state);\r\n    const selectedWitness2 = reducers.getSelectedTextWitness2(state);\r\n    let Media = reducers.getMediaData(state);\r\n    const imageData = getImageData(state);\r\n    let isSecondWindowOpen = reducers.isSecondWindowOpen(state);\r\n    const condition = reducers.getConditionForAlignment(state);\r\n    return {\r\n        text: selectedText,\r\n        witnesses: witnesses,\r\n        workingWitness: workingWitness,\r\n        baseWitness: baseWitness,\r\n        annotations: annotations,\r\n        loading: loading,\r\n        paginated: paginated,\r\n        pageImagesVisible: pageImagesVisible,\r\n        annotatedText: annotatedText,\r\n        selectedAnnotatedSegments: selectedAnnotatedSegments,\r\n        annotationPositions: annotationPositions,\r\n        activeAnnotations: { ...appliedAnnotations },\r\n        activeAnnotation: activeAnnotation,\r\n        pageBreaks: pageBreaks,\r\n        imagesBaseUrl: imagesBaseUrl,\r\n        user: user,\r\n        textListVisible,\r\n        selectedWitness,\r\n        selectedSearchResult,\r\n        searchValue,\r\n        fontSize,\r\n        isSecondWindowOpen,\r\n        imageData,\r\n        selectedImage: getSelectedImage(state),\r\n        isImagePortrait: isImagePortrait(state),\r\n        isPanelVisible: isPanelVisible(state),\r\n        isAnnotating: reducers.isAnnotating(state),\r\n        textAlignment,\r\n        textAlignmentById,\r\n        scrollToId,\r\n        syncIdOnClick,\r\n        selectedWindow,\r\n        selectedSourceRange: getSelectedSourceRange(state),\r\n        selectedTargetRange: getSelectedTargetRange(state),\r\n        searchResults: getSearchResults(state, searchValue),\r\n        showTableContent: getShowTableContent(state),\r\n        syncIdOnSearch: reducers.getSyncIdOnSearch(state),\r\n        imageAlignmentById: getImageAlignmentById(state),\r\n        imageScrollId: getImageScrollId(state),\r\n        selectedMedia: Media,\r\n        condition,\r\n    };\r\n};\r\n\r\nconst mergeProps = (stateProps, dispatchProps, ownProps) => {\r\n    const { dispatch } = dispatchProps;\r\n    const { annotatedText, annotationPositions } = stateProps;\r\n\r\n    const didSelectSegmentPosition = (segmentPosition, start, length) => {\r\n        let segmentAnnotations = annotationPositions[segmentPosition];\r\n        let segmentVariants = [];\r\n        let segmentPageBreaks = [];\r\n        let segmentLineBreaks = [];\r\n        if (segmentAnnotations) {\r\n            segmentVariants = segmentAnnotations.filter(\r\n                (annotation: Annotation) =>\r\n                    annotation.type === ANNOTATION_TYPES.variant\r\n            );\r\n            segmentPageBreaks = segmentAnnotations.filter(\r\n                (annotation: Annotation) =>\r\n                    annotation.type === ANNOTATION_TYPES.pageBreak\r\n            );\r\n            segmentLineBreaks = segmentAnnotations.filter(\r\n                (annotation: Annotation) =>\r\n                    annotation.type === ANNOTATION_TYPES.lineBreak\r\n            );\r\n        }\r\n        let activeAnnotations = _.intersectionWith(\r\n            segmentVariants.concat(segmentPageBreaks, segmentLineBreaks),\r\n            annotatedText.annotations,\r\n            (a, b) => a.toString() == b.toString()\r\n        );\r\n        let activeAnnotation = null;\r\n        if (activeAnnotations.length > 0) {\r\n            // get any active annotations\r\n            activeAnnotation = activeAnnotations[0];\r\n        } else if (segmentVariants && segmentVariants.length > 0) {\r\n            // get base text annotation for longest annotation highlighted in text\r\n            let longestAvailable = getLongestAnnotation(segmentVariants);\r\n            let [start, textLength] =\r\n                annotatedText.getPositionOfAnnotation(longestAvailable);\r\n            if (longestAvailable && longestAvailable.isInsertion) {\r\n                textLength = 0;\r\n            }\r\n            activeAnnotation = annotatedText.getBaseAnnotation(\r\n                start,\r\n                textLength\r\n            );\r\n        } else {\r\n            // get base annotation of just the segment\r\n            activeAnnotation = annotatedText.getBaseAnnotation(start, length);\r\n        }\r\n\r\n        dispatch(changedActiveTextAnnotation(activeAnnotation));\r\n    };\r\n\r\n    const isInsertion = (id) => {\r\n        return id.indexOf(\"i_\") !== -1;\r\n    };\r\n\r\n    const isDeletion = (id) => {\r\n        return id.indexOf(\"ds_\") !== -1;\r\n    };\r\n\r\n    const isPageBreak = (id) => {\r\n        return id.indexOf(\"p_\") !== -1;\r\n    };\r\n\r\n    const isLineBreak = (id) => {\r\n        return id.indexOf(\"l_\") !== -1;\r\n    };\r\n\r\n    const idFromSegmentId = (id) => {\r\n        let start = 0;\r\n        if (isInsertion(id)) {\r\n            start = id.substr(2);\r\n        } else if (isDeletion(id)) {\r\n            start = id.substr(3);\r\n        } else {\r\n            start = id.substr(2);\r\n        }\r\n\r\n        return start;\r\n    };\r\n\r\n    return {\r\n        ...stateProps,\r\n        ...ownProps,\r\n        didSelectSegmentIds: (segmentIds) => {\r\n            if (segmentIds.length === 0) {\r\n                return;\r\n            }\r\n            let segmentAnnotations = [];\r\n            let segments = [];\r\n            for (let segmentId of segmentIds) {\r\n                if (isDeletion(segmentId) || isInsertion(segmentId)) {\r\n                    continue;\r\n                }\r\n\r\n                let segmentPosition = idFromSegmentId(segmentId);\r\n                let textSegment =\r\n                    annotatedText.segmentedText.segmentAtPosition(\r\n                        segmentPosition\r\n                    );\r\n                segments.push(textSegment);\r\n                const annotations = annotationPositions[textSegment.start];\r\n                if (annotations) {\r\n                    segmentAnnotations = segmentAnnotations.concat(annotations);\r\n                }\r\n            }\r\n            segmentAnnotations = _.uniqWith(\r\n                segmentAnnotations,\r\n                (a, b) => a.toString() == b.toString()\r\n            );\r\n\r\n            let activeAnnotations = _.intersectionWith(\r\n                segmentAnnotations,\r\n                annotatedText.annotations,\r\n                (a, b) => a.toString() == b.toString()\r\n            );\r\n\r\n            const range = getSegmentsRange(\r\n                segments,\r\n                activeAnnotations,\r\n                segmentAnnotations,\r\n                stateProps.annotatedText\r\n            );\r\n            if (!range) {\r\n                console.warn(\r\n                    \"No range for selected segment ids: %o\",\r\n                    segmentIds\r\n                );\r\n                return;\r\n            }\r\n            const baseAnnotation = annotatedText.getBaseAnnotation(\r\n                range.start,\r\n                range.length\r\n            );\r\n            let activeAnnotation = null;\r\n            if (range.annotation) {\r\n                activeAnnotation = range.annotation;\r\n            } else if (activeAnnotations.length > 0) {\r\n                const content = annotatedText.segmentedText\r\n                    .segmentsInRange(range.start, range.length)\r\n                    .reduce((content, segment) => content + segment.text, \"\");\r\n                // TODO: test this when editing non-working edition.\r\n                // Check if getTextWorkingWitness works as required\r\n                if (!stateProps.selectedWitness) {\r\n                    console.log(\r\n                        \"no stateProps.selectedWitness: %o\",\r\n                        stateProps.selectedWitness\r\n                    );\r\n                }\r\n                activeAnnotation = new Annotation(\r\n                    WORKING_VERSION_ANNOTATION_ID,\r\n                    getTextWorkingWitness(stateProps.text),\r\n                    baseAnnotation.start,\r\n                    baseAnnotation.length,\r\n                    content,\r\n                    ANNOTATION_TYPES.variant,\r\n                    stateProps.selectedWitness,\r\n                    stateProps.user\r\n                );\r\n            } else {\r\n                activeAnnotation = baseAnnotation;\r\n            }\r\n            dispatch(changedActiveTextAnnotation(activeAnnotation));\r\n        },\r\n        selectedSegmentId: (segmentId) => {\r\n            let start = idFromSegmentId(segmentId);\r\n            let positionKey = start;\r\n            if (isInsertion(segmentId)) {\r\n                positionKey = INSERTION_KEY + start;\r\n            } else if (isDeletion(segmentId)) {\r\n                positionKey = DELETION_KEY + start;\r\n            } else if (isPageBreak(segmentId)) {\r\n                positionKey = PAGE_BREAK_KEY + start;\r\n            } else if (isLineBreak(segmentId)) {\r\n                positionKey = LINE_BREAK_KEY + start;\r\n            }\r\n\r\n            let segmentAnnotations = annotationPositions[positionKey];\r\n            if (\r\n                (DISMISS_CONTROLS_ON_CLICK && stateProps.activeAnnotation) ||\r\n                segmentId === \"\"\r\n            ) {\r\n                const activeAnnotation = stateProps.activeAnnotation;\r\n\r\n                if (activeAnnotation) {\r\n                    const dismissTextAnnotation =\r\n                        actions.changedActiveTextAnnotation(null);\r\n                    dispatch(dismissTextAnnotation);\r\n                }\r\n            } else {\r\n                if (\r\n                    isInsertion(segmentId) ||\r\n                    isDeletion(segmentId) ||\r\n                    isPageBreak(segmentId) ||\r\n                    isLineBreak(segmentId)\r\n                ) {\r\n                    const length = 0;\r\n                    didSelectSegmentPosition(positionKey, start, length);\r\n                } else {\r\n                    let segmentPosition = Number(idFromSegmentId(segmentId));\r\n                    let textSegment =\r\n                        annotatedText.segmentedText.segmentAtPosition(\r\n                            segmentPosition\r\n                        );\r\n                    if (textSegment) {\r\n                        didSelectSegmentPosition(\r\n                            textSegment.start,\r\n                            textSegment.start,\r\n                            textSegment.length\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        changeScrollToId: (payload) =>\r\n            dispatch(actions.changeScrollToId(payload)),\r\n        changeSyncIdOnClick: (payload) =>\r\n            dispatch(actions.changeSyncIdOnClick(payload)),\r\n        changeSelectedImage: (payload) => {\r\n            dispatch(actions.selectImage(payload));\r\n        },\r\n        changeSelectedWindow: (payload) => {\r\n            dispatch(actions.changeSelectedWindow(payload));\r\n        },\r\n        changeSelectedRange: (payload) => {\r\n            dispatch(actions.changeSelectedRange(payload));\r\n        },\r\n        changeShowTableContent: (payload) => {\r\n            dispatch(actions.showTableContent(payload));\r\n        },\r\n        closeAnnotation: () => {\r\n            const dismissTextAnnotation =\r\n                actions.changedActiveTextAnnotation(null);\r\n            dispatch(dismissTextAnnotation);\r\n        },\r\n        changeImageScrollId: (data) => {\r\n            dispatch(actions.changeImageScrollId(data));\r\n        },\r\n    };\r\n};\r\n\r\nconst getPageBreaks = (\r\n    witnessPageBreaks: { [AnnotationUniqueId]: Annotation },\r\n    basePageBreaks: { [AnnotationUniqueId]: AnnotationData } | null\r\n): number[] => {\r\n    let witnessStarts = [];\r\n    _.forIn(witnessPageBreaks, (o) => witnessStarts.push(o.start));\r\n    witnessStarts = witnessStarts.sort((a, b) => a - b);\r\n\r\n    if (!basePageBreaks) {\r\n        return witnessStarts;\r\n    }\r\n\r\n    let baseStarts = [];\r\n    _.forIn(basePageBreaks, (o) => baseStarts.push(o.start));\r\n    baseStarts = baseStarts.sort((a, b) => a - b);\r\n\r\n    if (witnessStarts.length === 0) {\r\n        return baseStarts;\r\n    }\r\n\r\n    // Only add page breaks if witness has < 90% of base witness breaks.\r\n    // Editions often have differing numbers of words per page so can't\r\n    // be 100%.\r\n    const threshold = 0.9;\r\n    if (witnessStarts.length / baseStarts.length < threshold) {\r\n        let lastWitnessPageStart = witnessStarts[witnessStarts.length - 1];\r\n        for (let i = 0, len = baseStarts.length; i < len; i++) {\r\n            let start = baseStarts[i];\r\n            if (start > lastWitnessPageStart) witnessStarts.push(start);\r\n        }\r\n    }\r\n    console.log(witnessStarts);\r\n    return witnessStarts;\r\n};\r\n\r\nconst getTextWorkingWitness = (textData: TextData): Witness => {\r\n    const source = new Source(\r\n        WORKING_VERSION_ANNOTATION_ID,\r\n        WORKING_VERSION_SOURCE_NAME\r\n    );\r\n    const text = new Text(textData.id, textData.name);\r\n    const witness = new Witness(\r\n        WORKING_VERSION_ANNOTATION_ID,\r\n        text,\r\n        source,\r\n        \"\",\r\n        false\r\n    );\r\n\r\n    return witness;\r\n};\r\n\r\nconst getSegmentsRange = (\r\n    segments: TextSegment[],\r\n    activeAnnotations: Annotation[],\r\n    annotations: Annotation[],\r\n    annotatedText: AnnotatedText\r\n): { start: number, length: number, annotation: Annotation | null } | null => {\r\n    if (segments.length === 0) {\r\n        return null;\r\n    }\r\n    let first = segments[0];\r\n    let last = segments[segments.length - 1];\r\n\r\n    let start = first.start;\r\n    let end = last.end;\r\n\r\n    let startAnnotation = null;\r\n    let endAnnotation = null;\r\n    for (let i = 0; i < annotations.length; i++) {\r\n        const annotation = annotations[i];\r\n        let annotationStart,\r\n            annotationLength,\r\n            annotationEnd = null;\r\n        [annotationStart, annotationLength] =\r\n            annotatedText.getPositionOfAnnotation(annotation);\r\n\r\n        if (activeAnnotations.indexOf(annotation) !== -1) {\r\n            if (annotationStart && annotationStart < start) {\r\n                start = annotationStart;\r\n                startAnnotation = annotation;\r\n            }\r\n\r\n            annotationEnd = annotationStart + annotationLength - 1;\r\n\r\n            if (annotationEnd && annotationEnd > end) {\r\n                end = annotationEnd;\r\n                endAnnotation = annotationEnd;\r\n            }\r\n        } else {\r\n            // For inactive annotions - we want to select the whole\r\n            // length of text the annotation refers to.\r\n            annotationEnd = annotationStart + annotationLength - 1;\r\n            if (annotationEnd > end) {\r\n                end = annotationEnd;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set if the whole range is encompassed by a single annotation\r\n    let rangeAnnotation = null;\r\n    if (startAnnotation && endAnnotation && startAnnotation === endAnnotation) {\r\n        rangeAnnotation = startAnnotation;\r\n    }\r\n\r\n    return {\r\n        start: start,\r\n        length: end - start + 1,\r\n        annotation: rangeAnnotation,\r\n    };\r\n};\r\n\r\nconst getLongestAnnotation = (annotations: Annotation[]): Annotation | null => {\r\n    let longest = null;\r\n    for (let i = 0; i < annotations.length; i++) {\r\n        let annotation = annotations[i];\r\n        if (!longest) {\r\n            longest = annotation;\r\n        } else {\r\n            if (annotation.length > longest.length) {\r\n                longest = annotation;\r\n            }\r\n        }\r\n    }\r\n    return longest;\r\n};\r\n\r\nconst TextDetailContainer = connect(\r\n    mapStateToProps,\r\n    null,\r\n    mergeProps\r\n)(TextDetail);\r\n\r\nexport default React.memo(TextDetailContainer);\r\n","import React, {\r\n    useState,\r\n    useRef,\r\n    useCallback,\r\n    useEffect,\r\n    useMemo,\r\n} from \"react\";\r\nimport styles from \"./textDetailHeading.css\";\r\nimport SelectVersion from \"./SelectVersion\";\r\nimport _ from \"lodash\";\r\nimport TextList from \"./TextListContainer\";\r\nimport CloseIcon from \"@mui/icons-material/Close\";\r\nimport {\r\n    Stack,\r\n    Box,\r\n    TextField,\r\n    Button,\r\n    Collapse,\r\n    Divider,\r\n    ButtonGroup,\r\n    IconButton,\r\n} from \"@mui/material\";\r\nimport Refresh from \"./HeaderMenu/Refresh\";\r\nimport Search from \"./HeaderMenu/Search\";\r\nimport Settings from \"./HeaderMenu/Settings\";\r\nimport TableOfContent from \"./HeaderMenu/TableOfContent\";\r\nimport SearchList from \"./HeaderMenu/SearchList\";\r\n\r\ntype HeaderProps = {\r\n    selectedText: {},\r\n    witnesses: Witness[],\r\n    selectedWitness: Witness,\r\n    onSelectedWitness: () => void,\r\n    user: User,\r\n    activeLocale: string,\r\n    accountOverlayVisible: boolean,\r\n    navigationButtonClicked: () => void,\r\n    menuButtonClicked: () => void,\r\n    textFontSize: Number,\r\n    onChangedFontSize: () => void,\r\n    onChangeWindowOpen: () => void,\r\n    isSecondWindowOpen: boolean,\r\n    changeIsAnnotating: () => void,\r\n    isAnnotating: Boolean,\r\n    searchChanged: () => void,\r\n    searchValue: String,\r\n    changeShowTableContent: () => void,\r\n    searchResults: [],\r\n};\r\n\r\nfunction TextDetailHeading(props: HeaderProps) {\r\n    const [findvalue, setfindvalue] = useState(\"\");\r\n    let [showFind, setShowFind] = useState(false);\r\n    let [visible, setVisible] = useState(false);\r\n    const headingRef = useRef();\r\n    const inputRef = useRef();\r\n    const handleListItemClick = (id) => {\r\n        props.changeSelectSyncId(id);\r\n    };\r\n    const debouncedSearch = React.useRef(\r\n        _.debounce((s) => {\r\n            props.searchChanged(s);\r\n        }, 1000)\r\n    ).current;\r\n    const handleSearch = useCallback(\r\n        (e) => {\r\n            e.preventDefault();\r\n            debouncedSearch(findvalue);\r\n            setVisible(true);\r\n        },\r\n        [findvalue]\r\n    );\r\n    const handleWindowSearch = useCallback(() => {\r\n        if (showFind === false) debouncedSearch(null);\r\n        setShowFind(!showFind);\r\n    }, [showFind]);\r\n\r\n    useEffect(() => {\r\n        if (showFind === true) {\r\n            inputRef.current.focus();\r\n        }\r\n        if (showFind === false) debouncedSearch(null);\r\n    }, [showFind]);\r\n\r\n    const closeSearchItemBox = useCallback(() => {\r\n        setVisible(false);\r\n        debouncedSearch(null);\r\n        setfindvalue(\"\");\r\n    }, []);\r\n\r\n    let condition = useMemo(\r\n        () =>\r\n            _.isObject(props.searchResults) &&\r\n            props.searchResults.hasOwnProperty(props.selectedText.id),\r\n        [props.searchResults, props.selectedText]\r\n    );\r\n    let results = condition\r\n        ? props.searchResults[props.selectedText.id].results\r\n        : [];\r\n    return (\r\n        <Stack\r\n            ref={headingRef}\r\n            direction=\"column\"\r\n            spacing={1}\r\n            sx={{\r\n                paddingInline: { md: 1, xs: 0 },\r\n                paddingBlock: { md: 1, xs: 0 },\r\n                bgcolor: \"heading.main\",\r\n                color: \"text.primary\",\r\n            }}\r\n        >\r\n            <Stack direction=\"row\" spacing={1} justifyContent=\"space-between\">\r\n                <Box\r\n                    sx={{\r\n                        display: \"flex\",\r\n                        gap: { md: 2, sx: 0 },\r\n                        flexDirection: { md: \"row\", xs: \"column\" },\r\n                    }}\r\n                >\r\n                    <TextList />\r\n                    <SelectVersion\r\n                        witnesses={props.witnesses}\r\n                        activeWitness={props.selectedWitness}\r\n                        onSelectedWitness={props.onSelectedWitness}\r\n                        user={props.user}\r\n                    />\r\n                </Box>\r\n\r\n                <ButtonGroup\r\n                    size=\"small\"\r\n                    sx={{\r\n                        position: \"relative\",\r\n                        display: \"flex\",\r\n                        height: \"fit-content\",\r\n                        alignItems: \"center\",\r\n                        justifyContent: \"center\",\r\n                        width: \"fit-content\",\r\n                        border: (theme) => `1px solid ${theme.palette.divider}`,\r\n                        borderRadius: 1,\r\n                        bgcolor: \"background.paper\",\r\n                        color: \"text.secondary\",\r\n                        \"& svg\": {\r\n                            m: 1,\r\n                        },\r\n                        \"& hr\": {\r\n                            mx: 0.5,\r\n                        },\r\n                    }}\r\n                    className={styles.button_group_menu}\r\n                >\r\n                    <Refresh isSecondWindowOpen={props.isSecondWindowOpen} />\r\n                    <Divider orientation=\"vertical\" variant=\"middle\" flexItem />\r\n                    <Search handleWindowSearch={handleWindowSearch} />\r\n                    <Settings\r\n                        textFontSize={props.textFontSize}\r\n                        onChangedFontSize={props.onChangedFontSize}\r\n                        onExport={props.onExport}\r\n                        isPanelLinked={props.isPanelLinked}\r\n                    />\r\n                    <TableOfContent\r\n                        changeShowTableContent={props.changeShowTableContent}\r\n                        showTableContent={props.showTableContent}\r\n                    />\r\n                </ButtonGroup>\r\n            </Stack>\r\n\r\n            <Collapse in={showFind}>\r\n                <form onSubmit={handleSearch}>\r\n                    <Stack direction=\"row\" spacing={2} position=\"relative\">\r\n                        <TextField\r\n                            hiddenLabel\r\n                            id=\"filled-hidden-label-small\"\r\n                            inputProps={{\r\n                                style: {\r\n                                    height: 25,\r\n                                    padding: \"0 14px\",\r\n                                },\r\n                            }}\r\n                            style={{ height: 25, flex: 1 }}\r\n                            fullWidth\r\n                            inputRef={inputRef}\r\n                            value={findvalue}\r\n                            onChange={(e) => setfindvalue(e.target.value)}\r\n                        />\r\n\r\n                        <Button\r\n                            variant=\"outlined\"\r\n                            size=\"small\"\r\n                            onClick={handleSearch}\r\n                            style={{ height: 25 }}\r\n                        >\r\n                            Search\r\n                        </Button>\r\n\r\n                        {props.searchResults && visible && (\r\n                            <Box\r\n                                sx={{\r\n                                    position: \"absolute\",\r\n                                    top: 35,\r\n                                    right: 0,\r\n                                    zIndex: 1,\r\n                                    bgcolor: \"heading.main\",\r\n                                    height: 350,\r\n                                    width: 350,\r\n                                    boxShadow: 3,\r\n                                    overflowX: \"hidden\",\r\n                                    boxShadow: 3,\r\n                                }}\r\n                            >\r\n                                {results.length === 0 && (\r\n                                    <p>no such word present</p>\r\n                                )}\r\n                                {condition && results.length > 0 && (\r\n                                    <SearchList\r\n                                        handleListItemClick={\r\n                                            handleListItemClick\r\n                                        }\r\n                                        searchValue={props.searchValue}\r\n                                        results={results}\r\n                                        selectedText={props.selectedText}\r\n                                    />\r\n                                )}\r\n                                <IconButton\r\n                                    aria-label=\"closeButton\"\r\n                                    onClick={closeSearchItemBox}\r\n                                    size=\"small\"\r\n                                    sx={{\r\n                                        right: 15,\r\n                                        top: 0,\r\n                                        position: \"absolute\",\r\n                                    }}\r\n                                >\r\n                                    <CloseIcon fontSize=\"inherit\" />\r\n                                </IconButton>\r\n                            </Box>\r\n                        )}\r\n                    </Stack>\r\n                </form>\r\n            </Collapse>\r\n        </Stack>\r\n    );\r\n}\r\n\r\nexport default React.memo(TextDetailHeading);\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport TextDetailHeading from \"./TextDetailHeading\";\r\nimport * as actions from \"actions\";\r\nimport * as reducers from \"reducers\";\r\nimport type { AppState } from \"reducers\";\r\n\r\nconst mapStateToProps = (state: AppState): {} => {\r\n    const selectedText = reducers.getSelectedText(state);\r\n    const selectedText2 = reducers.getSelectedText2(state);\r\n    let witnesses = [];\r\n    let exportingWitness = false;\r\n    let selectedWitness;\r\n    let selectedWitness2;\r\n\r\n    if (selectedText) {\r\n        witnesses = reducers.getTextWitnesses(state, selectedText.id);\r\n        const selectedWitnessId = reducers.getSelectedTextWitnessId(\r\n            state,\r\n            selectedText.id\r\n        );\r\n        if (selectedWitnessId) {\r\n            selectedWitness = reducers.getWitness(state, selectedWitnessId);\r\n            exportingWitness = reducers.getExportingWitness(\r\n                state,\r\n                selectedWitnessId\r\n            );\r\n        } else {\r\n            selectedWitness = reducers.getWorkingWitness(\r\n                state,\r\n                selectedText.id\r\n            );\r\n        }\r\n    }\r\n\r\n    if (selectedText2) {\r\n        // witnesses = reducers.getTextWitnesses(state, selectedText2.id);\r\n        const selectedWitnessId2 = reducers.getSelectedTextWitnessId2(\r\n            state,\r\n            selectedText2.id\r\n        );\r\n        if (selectedWitnessId2) {\r\n            selectedWitness2 = reducers.getWitness2(state, selectedWitnessId2);\r\n        } else {\r\n            selectedWitness2 = reducers.getWorkingWitness2(\r\n                state,\r\n                selectedText2.id\r\n            );\r\n        }\r\n    }\r\n\r\n    let textFontSize = reducers.getTextFontSize(state);\r\n    let searchValue = reducers.getSearchValue(state);\r\n    return {\r\n        witnesses,\r\n        selectedText,\r\n        selectedText2,\r\n        selectedWitness,\r\n        selectedWitness2,\r\n        textFontSize,\r\n        exportingWitness,\r\n        searchValue,\r\n        showTableContent: reducers.getShowTableContent(state),\r\n        searchResults: reducers.getSearchResults(state, searchValue),\r\n    };\r\n};\r\n\r\nconst mergeProps = (stateProps, dispatchProps, ownProps) => {\r\n    const navigationButtonClicked = () => {\r\n        dispatchProps.dispatch(\r\n            actions.changedTextListVisible(!stateProps.textListIsVisible)\r\n        );\r\n    };\r\n\r\n    const { dispatch } = dispatchProps;\r\n    const { selectedText } = stateProps;\r\n\r\n    return {\r\n        ...ownProps,\r\n        ...stateProps,\r\n        navigationButtonClicked,\r\n        onSelectedWitness: (witness: Witness) => {\r\n            dispatch(\r\n                actions.selectedTextWitness(selectedText?.id, witness?.id)\r\n            );\r\n        },\r\n        onChangedFontSize: (fontSize: number) => {\r\n            dispatch(actions.changedTextFontSize(fontSize));\r\n        },\r\n        onChangeWindowOpen: (data: boolean, textId) => {\r\n            dispatch(actions.toggleSecondWindow(data, textId));\r\n        },\r\n        onExport: () => {\r\n            dispatch(\r\n                actions.exportWitness(stateProps.selectedWitness.id, \"docx\")\r\n            );\r\n        },\r\n        navigationButtonClicked: () => {\r\n            dispatch(\r\n                actions.changedTextListVisible(!stateProps.textListIsVisible)\r\n            );\r\n        },\r\n\r\n        changeIsAnnotating: (payload) => {\r\n            dispatch(actions.changeIsAnnotating(payload));\r\n            if (payload === false) {\r\n                const dismissTextAnnotation =\r\n                    actions.changedActiveTextAnnotation(null);\r\n                dispatch(dismissTextAnnotation);\r\n                dispatch(actions.changedActiveTextAnnotation(null));\r\n            }\r\n        },\r\n        searchChanged: (searchTerm: string) => {\r\n            dispatch(actions.changedSearchValue(searchTerm));\r\n        },\r\n        changeShowTableContent: (payload) => {\r\n            dispatch(actions.showTableContent(payload));\r\n        },\r\n        changeSelectSyncId: (payload) => {\r\n            dispatch(actions.changeSyncIdOnSearch(payload));\r\n        },\r\n    };\r\n};\r\n\r\nconst TextDetailHeadingContainer = connect(\r\n    mapStateToProps,\r\n    null,\r\n    mergeProps\r\n)(TextDetailHeading);\r\n\r\nexport default TextDetailHeadingContainer;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"textlist\":\"TextList---textlist\",\"open\":\"TextList---open\"};","import React, {\r\n    useState,\r\n    useRef,\r\n    useCallback,\r\n    useMemo,\r\n    useEffect,\r\n} from \"react\";\r\nimport {\r\n    List,\r\n    AutoSizer,\r\n    CellMeasurer,\r\n    CellMeasurerCache,\r\n} from \"react-virtualized\";\r\nimport classname from \"classnames\";\r\nimport styles from \"./TextList.css\";\r\nimport {\r\n    TextField,\r\n    ClickAwayListener,\r\n    Box,\r\n    Typography,\r\n    Button,\r\n    Grow,\r\n} from \"@mui/material\";\r\nimport addShay from \"lib/addTibetanShay\";\r\nimport { filter } from \"lodash\";\r\nfunction TextList(props) {\r\n    const temptext = useRef(props.texts);\r\n    const [textslist, setTextList] = useState(temptext.current);\r\n    const [filterValue, setFilterValue] = useState(null);\r\n    const onSelectedText = props.onSelectedText;\r\n    const selectedText = props.selectedText;\r\n    const [isOpen, setIsOpen] = useState(false);\r\n    let selected = selectedText?.name;\r\n    const cache = useRef(\r\n        new CellMeasurerCache({\r\n            fixedHeight: true,\r\n            defaultHeight: 40,\r\n        })\r\n    );\r\n\r\n    let classes = [styles.textlist];\r\n    useEffect(() => {\r\n        let temp = [];\r\n        if (filterValue === \"\") {\r\n            setTextList([...temptext.current]);\r\n        }\r\n        if (filterValue !== null && filterValue !== \"\") {\r\n            temp = temptext.current.filter((val) => {\r\n                return val.name.includes(filterValue);\r\n            });\r\n            setTextList([...temp]);\r\n        }\r\n    }, [filterValue]);\r\n    const handleClick = () => {\r\n        setIsOpen((prev) => !prev);\r\n        if (isOpen === false) classes.push(styles.open);\r\n    };\r\n    const handleChange = (e) => {\r\n        let value = e.target.value;\r\n        setFilterValue(value);\r\n    };\r\n\r\n    const rowRenderer = React.useCallback(\r\n        ({ key, index, style, parent }) => {\r\n            let data = textslist[index];\r\n            return (\r\n                <CellMeasurer\r\n                    key={`optionvalues-${key}`}\r\n                    cache={cache.current}\r\n                    parent={parent}\r\n                    columnIndex={0}\r\n                    rowIndex={index}\r\n                >\r\n                    <div\r\n                        style={style}\r\n                        onClick={() => {\r\n                            setIsOpen(false);\r\n                            onSelectedText(data);\r\n                        }}\r\n                    >\r\n                        <Box\r\n                            sx={{\r\n                                overflow: \"hidden\",\r\n                                textOverflow: \"ellipsis\",\r\n                                width: \"13rem\",\r\n                                paddingLeft: 2,\r\n                                fontSize: {\r\n                                    lg: 12,\r\n                                    md: 11,\r\n                                    sm: 10,\r\n                                    xs: 10,\r\n                                },\r\n                                color: \"text.primary\",\r\n                            }}\r\n                            component=\"div\"\r\n                        >\r\n                            <Typography noWrap={true}>\r\n                                {addShay(data.name)}\r\n                            </Typography>\r\n                        </Box>\r\n                    </div>\r\n                </CellMeasurer>\r\n            );\r\n        },\r\n        [textslist]\r\n    );\r\n    return (\r\n        <ClickAwayListener onClickAway={() => setIsOpen(false)}>\r\n            <div style={{ position: \"relative\", marginLeft: 10 }}>\r\n                <Button\r\n                    onClick={handleClick}\r\n                    component=\"div\"\r\n                    variant=\"outlined\"\r\n                    sx={{\r\n                        overflow: \"hidden\",\r\n                        textOverflow: \"ellipsis\",\r\n                        width: \"10rem\",\r\n                        height: \"100%\",\r\n                        color: \"text.primary\",\r\n                    }}\r\n                >\r\n                    <Typography noWrap={true}>{selected}</Typography>\r\n                </Button>\r\n\r\n                <Grow in={isOpen}>\r\n                    <Box\r\n                        className={classname(classes)}\r\n                        sx={{\r\n                            position: \"absolute\",\r\n                            bgcolor: \"heading.main\",\r\n                            zIndex: 1,\r\n                        }}\r\n                    >\r\n                        <TextField\r\n                            onChange={handleChange}\r\n                            id=\"standard-basic\"\r\n                            label=\"filter\"\r\n                            variant=\"standard\"\r\n                            style={{ width: \"100%\" }}\r\n                        />\r\n                        <AutoSizer>\r\n                            {({ width, height }) => (\r\n                                <List\r\n                                    width={width}\r\n                                    height={height}\r\n                                    rowHeight={40}\r\n                                    deferredMeasurementCache={cache.current}\r\n                                    rowCount={textslist.length}\r\n                                    rowRenderer={rowRenderer}\r\n                                />\r\n                            )}\r\n                        </AutoSizer>\r\n                    </Box>\r\n                </Grow>\r\n            </div>\r\n        </ClickAwayListener>\r\n    );\r\n}\r\n\r\nexport default React.memo(TextList);\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport TextList from \"./TextList\";\r\nimport * as actions from \"actions\";\r\nimport { getSelectedText } from \"reducers\";\r\nimport type { AppState } from \"reducers\";\r\nimport * as api from \"api\";\r\nimport * as reducers from \"reducers\";\r\nimport { batchActions } from \"redux-batched-actions\";\r\nimport { reduce } from \"lodash\";\r\n\r\nconst mapStateToProps = (state: AppState) => {\r\n    // TODO: display search results or spinner depending on when anything\r\n    // returned\r\n    let texts = reducers.getTexts(state);\r\n    let selectedText = reducers.getSelectedText(state);\r\n    return {\r\n        texts,\r\n        selectedText,\r\n    };\r\n};\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        onSelectedText: (text: api.TextData) => {\r\n            dispatch(actions.selectedText(text));\r\n        },\r\n    };\r\n};\r\n\r\nconst TextListContainer = connect(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(TextList);\r\n\r\nexport default React.memo(TextListContainer);\r\n","export { default } from \"./TextDetail\";\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"button_group_menu\":\"textDetailHeading---button_group_menu\"};","// @flow\r\nimport * as React from \"react\";\r\nimport GraphemeSplitter from \"grapheme-splitter\";\r\nimport reactStringReplace from \"react-string-replace\";\r\n\r\ntype Props = {\r\n    string: string,\r\n    highlightClass: string,\r\n    stringClass?: string,\r\n    searchTerm?: string\r\n};\r\n\r\nexport default class HighlightedString extends React.Component<Props> {\r\n    constructor(props: Props) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        const string = this.props.string;\r\n        let nameHtml = string;\r\n        let stringClass = this.props.stringClass || \"\";\r\n        if (this.props.searchTerm) {\r\n            const searchTerm = this.props.searchTerm;\r\n            const splitter = new GraphemeSplitter();\r\n            const graphemes = splitter.splitGraphemes(string);\r\n            const start = string.indexOf(searchTerm);\r\n            const end = start + searchTerm.length;\r\n            let position = 0;\r\n            let foundGraphemes = \"\";\r\n            if (start > -1) {\r\n                for (let i = 0; i < graphemes.length; i++) {\r\n                    let grapheme = graphemes[i];\r\n                    if (position >= start && position < end) {\r\n                        foundGraphemes += grapheme;\r\n                    }\r\n                    position += grapheme.length;\r\n                }\r\n            }\r\n            if (foundGraphemes.length > 0) {\r\n                nameHtml = reactStringReplace(\r\n                    string,\r\n                    foundGraphemes,\r\n                    (match, i) => (\r\n                        <span className={this.props.highlightClass} key={`highlight-${i}`}>\r\n                            {match}\r\n                        </span>\r\n                    )\r\n                );\r\n            }\r\n        }\r\n        return <span className={stringClass}>{nameHtml}</span>;\r\n    }\r\n}\r\n","import React, { useCallback, useEffect } from \"react\";\r\nimport RefreshIcon from \"@mui/icons-material/Refresh\";\r\nimport { IconButton } from \"@mui/material\";\r\nfunction Refresh({ isSecondWindowOpen }) {\r\n    const handleRefresh = useCallback(() => {\r\n        let updatelistBtn2 = document.getElementById(\"updateList2\");\r\n\r\n        if (updatelistBtn2) updatelistBtn2.click();\r\n    }, [isSecondWindowOpen]);\r\n\r\n    useEffect(() => {\r\n        let timer = setTimeout(() => {\r\n            handleRefresh();\r\n        }, 500);\r\n        return () => clearTimeout(timer);\r\n    }, [isSecondWindowOpen]);\r\n\r\n    return (\r\n        <IconButton variant=\"text\" size=\"small\" onClick={handleRefresh}>\r\n            <RefreshIcon />\r\n        </IconButton>\r\n    );\r\n}\r\n\r\nexport default Refresh;\r\n","import React from \"react\";\r\nimport SearchIcon from \"@mui/icons-material/Search\";\r\nimport { IconButton } from \"@mui/material\";\r\n\r\nfunction Search({ handleWindowSearch }) {\r\n    return (\r\n        <IconButton size=\"small\" variant=\"text\" onClick={handleWindowSearch}>\r\n            <SearchIcon />\r\n        </IconButton>\r\n    );\r\n}\r\n\r\nexport default Search;\r\n","import React, { useRef } from \"react\";\r\nimport {\r\n    AutoSizer,\r\n    CellMeasurer,\r\n    CellMeasurerCache,\r\n    List,\r\n} from \"react-virtualized\";\r\nimport HighlightedString from \"./HighlightedString\";\r\nimport styles from \"./SearchStyle.css\";\r\n\r\nfunction SearchList(props) {\r\n    const { handleListItemClick, searchValue, results, selectedText } = props;\r\n    let listRef = useRef();\r\n    let cache = useRef(\r\n        new CellMeasurerCache({\r\n            fixedWidth: true,\r\n            defaultHeight: 100,\r\n        })\r\n    );\r\n    let rowRenderer = ({ key, index, parent, style }) => {\r\n        let result = results[index];\r\n        return (\r\n            <CellMeasurer\r\n                key={`listkeys2-${key}`}\r\n                cache={cache.current}\r\n                parent={parent}\r\n                columnIndex={0}\r\n                rowIndex={index}\r\n            >\r\n                <div style={style}>\r\n                    {results.length > 0 && (\r\n                        <div\r\n                            className={styles.searchListItem}\r\n                            onClick={() => handleListItemClick(result[0])}\r\n                        >\r\n                            <HighlightedString\r\n                                string={result[1]}\r\n                                highlightClass={styles.highlight}\r\n                                searchTerm={searchValue}\r\n                            />\r\n                        </div>\r\n                    )}\r\n                </div>\r\n            </CellMeasurer>\r\n        );\r\n    };\r\n\r\n    if (!results) return null;\r\n    return (\r\n        <>\r\n            <AutoSizer>\r\n                {({ height, width }) => (\r\n                    <List\r\n                        ref={listRef}\r\n                        height={height}\r\n                        rowCount={results?.length}\r\n                        rowHeight={cache.current.rowHeight}\r\n                        deferredMeasurementCache={cache.current}\r\n                        rowRenderer={rowRenderer}\r\n                        width={width}\r\n                        overscanRowCount={1}\r\n                    ></List>\r\n                )}\r\n            </AutoSizer>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default SearchList;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"highlight\":\"SearchStyle---highlight\",\"searchListItem\":\"SearchStyle---searchListItem\"};","import React, { useEffect, useState } from \"react\";\r\nimport WrenchIcon from \"images/wrench.svg\";\r\nimport Slider from \"../../UI/Slider\";\r\nimport useLocalStorage from \"components/utility/useLocalStorage\";\r\n\r\nimport CheckIcon from \"@mui/icons-material/Check\";\r\nimport {\r\n    IconButton,\r\n    MenuList,\r\n    MenuItem,\r\n    Divider,\r\n    Grow,\r\n    Box,\r\n    ClickAwayListener,\r\n} from \"@mui/material\";\r\nimport { FONT_LIST } from \"app_constants\";\r\n\r\nfunction Settings(props) {\r\n    let [showOption, setShowOption] = useState(false);\r\n    let [fontSelect, setFontSelect] = useLocalStorage(\r\n        \"WindowTwoFont\",\r\n        \"Tibetan\"\r\n    );\r\n    useEffect(() => {\r\n        document.body.style.setProperty(\"--tibetan-fonts2\", fontSelect);\r\n    }, []);\r\n    const handleClick = () => {\r\n        setShowOption((prev) => !prev);\r\n    };\r\n    const handlefont = (value) => {\r\n        setFontSelect(value);\r\n        document.body.style.setProperty(\"--tibetan-fonts2\", `${value}`);\r\n        let update = document.getElementById(\"updateList2\");\r\n        let times = 1;\r\n        let timer = setInterval(() => {\r\n            update.click();\r\n            times++;\r\n            console.log(\"ran\");\r\n            if (times > 4) {\r\n                clearInterval(timer);\r\n            }\r\n        }, 800);\r\n        setShowOption(false);\r\n    };\r\n    return (\r\n        <ClickAwayListener onClickAway={() => setShowOption(false)}>\r\n            <Box position=\"relative\">\r\n                <IconButton onClick={handleClick} size=\"small\" variant=\"text\">\r\n                    <WrenchIcon height={20} width={20} fill=\"currentColor\" />\r\n                </IconButton>\r\n                <Grow in={showOption}>\r\n                    <MenuList\r\n                        dense\r\n                        sx={{\r\n                            position: \"absolute\",\r\n                            right: 0,\r\n                            zIndex: 2,\r\n                            top: 40,\r\n                            bgcolor: \"heading.main\",\r\n                        }}\r\n                    >\r\n                        <Slider\r\n                            max={20}\r\n                            min={7}\r\n                            initialvalue={props.textFontSize}\r\n                            changeSize={props.onChangedFontSize}\r\n                        />\r\n                        <Divider />\r\n                        <FontSelection\r\n                            selectFont={handlefont}\r\n                            selectedfont={fontSelect}\r\n                        />\r\n                        <MenuItem onClick={() => props.onExport()}>\r\n                            Export Document\r\n                            {props.exportingWitness && <CheckIcon />}\r\n                        </MenuItem>\r\n                    </MenuList>\r\n                </Grow>\r\n            </Box>\r\n        </ClickAwayListener>\r\n    );\r\n}\r\n\r\nexport default Settings;\r\n\r\nconst FontSelection = ({ selectFont, selectedfont }) => {\r\n    let fontAvailable = FONT_LIST || [];\r\n\r\n    return (\r\n        <Box textAlign={\"center\"}>\r\n            <span>Font:</span>{\" \"}\r\n            <select\r\n                onChange={(e) => selectFont(e.target.value)}\r\n                value={selectedfont}\r\n            >\r\n                {fontAvailable.map((font, index) => {\r\n                    return (\r\n                        <option key={index + \"-fontselect\"} value={font}>\r\n                            {font}\r\n                        </option>\r\n                    );\r\n                })}\r\n            </select>\r\n        </Box>\r\n    );\r\n};\r\n","import React from \"react\";\r\nimport { IconButton } from \"@mui/material\";\r\nimport MenuIcon from \"@mui/icons-material/Menu\";\r\nimport ClearIcon from \"@mui/icons-material/Clear\";\r\n\r\nfunction TableOfContent(props) {\r\n    const handleClick = () => {\r\n        props.changeShowTableContent(!props.showTableContent);\r\n    };\r\n    return (\r\n        <React.Fragment key=\"right\">\r\n            <IconButton onClick={handleClick}>\r\n                {props.showTableContent ? <ClearIcon /> : <MenuIcon />}\r\n            </IconButton>\r\n        </React.Fragment>\r\n    );\r\n}\r\n\r\nexport default TableOfContent;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"selectVersion\":\"SelectVersion---selectVersion\",\"selectEmpty\":\"SelectVersion---selectEmpty\",\"selectOptions\":\"SelectVersion---selectOptions\",\"styled-select\":\"SelectVersion---styled-select\"};","// @flow\r\nimport React, { useState, useEffect, memo, useLayoutEffect } from \"react\";\r\nimport _ from \"lodash\";\r\nimport { FormattedMessage, injectIntl } from \"react-intl\";\r\nimport styles from \"./SelectVersion.css\";\r\nimport Witness from \"lib/Witness\";\r\nimport { NativeSelect } from \"@mui/material\";\r\n\r\nexport type Props = {\r\n    witnesses: Witness[],\r\n    activeWitness: Witness | null,\r\n    onSelectedWitness: (witness: Witness) => void,\r\n    user: {},\r\n};\r\n\r\nconst SelectVersion = (props: Props) => {\r\n    let witnesses = [];\r\n    let tabName = \"\";\r\n    let r = \"\";\r\n    let classes = [];\r\n    if (props.witnesses) {\r\n        witnesses = props.witnesses.map((witness) => witness);\r\n        if (props.activeWitness)\r\n            r = props.witnesses.findIndex(\r\n                (l) => l.id === props.activeWitness.id\r\n            );\r\n        witnesses.sort((a, b) => {\r\n            if (a.isWorking) {\r\n                return -1;\r\n            }\r\n            if (b.isWorking) {\r\n                return 1;\r\n            }\r\n            if (a.isBase) {\r\n                return -1;\r\n            }\r\n            if (b.isBase) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n        witnesses = witnesses.sort((a, b) => a.id - b.id);\r\n    }\r\n\r\n    const handleChangeWitness = (e) => {\r\n        if (!_.isEmpty(witnesses)) {\r\n            props.onSelectedWitness(witnesses[e.target.value]);\r\n        }\r\n    };\r\n\r\n    if (_.isEmpty(witnesses) && !props.activeWitness) return null;\r\n\r\n    return (\r\n        <NativeSelect\r\n            onChange={handleChangeWitness}\r\n            className={styles.selectVersion}\r\n            value={r}\r\n            label=\"Version2\"\r\n            classes={{\r\n                root: styles.selectEmpty,\r\n                select: styles.selectOptions,\r\n            }}\r\n        >\r\n            {witnesses.map((witness, key) => {\r\n                if (witness.id === props.activeWitness?.id)\r\n                    classes.push(styles.selected);\r\n                tabName = witness.source.name;\r\n\r\n                if (witness.isWorking) {\r\n                    tabName =\r\n                        props.intl.locale === \"en\"\r\n                            ? props.user.name === \"User\"\r\n                                ? \"Working\"\r\n                                : \"My Edition\"\r\n                            : \"མཉམ་འབྲེལ་པར་མ།\";\r\n                }\r\n\r\n                return (\r\n                    <option\r\n                        key={`versionSelect2-${key}`}\r\n                        value={key}\r\n                        className={styles.selectOptions}\r\n                    >\r\n                        {tabName}\r\n                    </option>\r\n                );\r\n            })}\r\n        </NativeSelect>\r\n    );\r\n};\r\n\r\nexport default memo(injectIntl(SelectVersion));\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"inlineWidth\":\"280px\",\"annotationControls\":\"SplitText---annotationControls\",\"annotationContent\":\"SplitText---annotationContent\",\"subTitle\":\"SplitText---subTitle\",\"title\":\"SplitText---title\",\"sectionHeading\":\"SplitText---sectionHeading\",\"text\":\"SplitText---text\",\"padding\":\"SplitText---padding\",\"arrowTop\":\"SplitText---arrowTop\",\"arrowLeft\":\"SplitText---arrowLeft\",\"arrowRight\":\"SplitText---arrowRight\",\"inline\":\"SplitText---inline\",\"arrow\":\"SplitText---arrow\",\"arrowDs\":\"SplitText---arrowDs\",\"nothingSelected\":\"SplitText---nothingSelected\",\"anonymousMessage\":\"SplitText---anonymousMessage\",\"noNotes\":\"SplitText---noNotes\",\"breakButtons\":\"SplitText---breakButtons\",\"splitText2\":\"SplitText---splitText2\",\"splitTextRowContent\":\"SplitText---splitTextRowContent\",\"splitTextRow\":\"SplitText---splitTextRow\",\"pechaImage\":\"SplitText---pechaImage\",\"controlsPlaceholder\":\"SplitText---controlsPlaceholder\",\"pageNumber\":\"SplitText---pageNumber\"};","// @flow\r\nimport * as React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { AutoSizer } from \"react-virtualized/dist/es/AutoSizer\";\r\nimport { List } from \"react-virtualized\";\r\nimport {\r\n    CellMeasurer,\r\n    CellMeasurerCache,\r\n} from \"react-virtualized/dist/es/CellMeasurer\";\r\nimport \"react-virtualized/styles.css\";\r\nimport Text2 from \"./Text2\";\r\nimport SplitText from \"lib/SplitText\";\r\nimport styles from \"./SplitText.css\";\r\nimport _, { split } from \"lodash\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport Witness from \"lib/Witness\";\r\nimport GraphemeSplitter from \"grapheme-splitter\";\r\nimport { Box } from \"@mui/material\";\r\n\r\nlet _searchResultsCache: {\r\n    [splitTextUniqueId: string]: {\r\n        [searchTerm: string]: {\r\n            [index: number]: { [position: number]: [number, number] },\r\n        },\r\n    },\r\n} = {};\r\n\r\nexport type Props = {\r\n    splitText: SplitText,\r\n    didSelectSegmentIds: (segmentIds: string[]) => void,\r\n    limitWidth: boolean,\r\n    // selectedAnnotatedSegments: Array<TextSegment | number>,\r\n    selectedSegmentId: (segmentId: string) => void,\r\n    selectedWitness: Witness | null,\r\n    // selectedSearchResult: {\r\n    //     textId: number,\r\n    //     start: number,\r\n    //     length: number\r\n    // } | null,\r\n    // searchValue: string | null,\r\n    fontSize: number,\r\n    isPanelLinked: Boolean,\r\n    textAlignment: {},\r\n    textAlignmentById: {},\r\n    changeScrollToId: () => void,\r\n    selectedWindow: Boolean,\r\n    selectedTargetRange: [],\r\n    selectedSourceRange: [],\r\n    syncIdOnSearch: String,\r\n    changeSyncIdOnClick: () => void,\r\n};\r\n\r\nexport default class SplitTextComponent extends React.PureComponent<Props> {\r\n    list: List | null;\r\n    splitText: HTMLDivElement | null;\r\n    didSelectSegmentIds;\r\n    cache: CellMeasurerCache;\r\n    rowRenderer: (params: {\r\n        key: string,\r\n        index: number,\r\n        parent: {},\r\n        style: {},\r\n    }) => React.Element<CellMeasurer>;\r\n    resizeHandler: () => void;\r\n    selectionHandler: (e: Event) => void;\r\n    textListVisible: boolean;\r\n    editMenuVisible: Boolean;\r\n    activeSelection: Selection | null;\r\n    selectedNodes: Node[] | null;\r\n    // Whether the mouse button is down\r\n    textAlignmentById;\r\n    changeScrollToId: () => void;\r\n\r\n    selectedTextIndex: number | null;\r\n    splitTextRect: ClientRect | null;\r\n    firstSelectedSegment: TextSegment | null;\r\n    selectedElementId: string | null;\r\n    selectedElementIds: string[] | null;\r\n    selectedWindow: Boolean;\r\n    scrollEvent: () => void;\r\n    mouseEnter: () => void;\r\n    mouseLeft: () => void;\r\n    scrollTop;\r\n    debouncedScroll;\r\n    constructor(props: Props) {\r\n        super(props);\r\n        this.textAlignmentById = [];\r\n        this.changeScrollToId = props.changeScrollToId;\r\n        this.condition = props.condition;\r\n        this.list = null;\r\n        this.splitText = null;\r\n        this.cache = new CellMeasurerCache({\r\n            fixedWidth: true,\r\n        });\r\n        this.rowRenderer = this.rowRenderer.bind(this);\r\n        this.activeSelection = null;\r\n        this.selectedNodes = null;\r\n        this._mouseDown = false;\r\n        this._activeWitness = null;\r\n        this._didSetInitialScrollPosition = false;\r\n        this._modifyingSelection = false;\r\n        this.imageHeight = null;\r\n        this.imageWidth = null;\r\n        this.calculatedImageHeight = null;\r\n        this.selectedWindow = this.props.selectedWindow;\r\n        this.scrollEvent = this.scrollEvent.bind(this);\r\n        // this.processProps(props);\r\n        this.scrollTop = 0;\r\n    }\r\n    scrollEvent(e) {\r\n        if (this.selectedWindow === 1) return null;\r\n        if (this.selectedWindow === 2) {\r\n            let list = [];\r\n            this.textAlignmentById.map((l) => {\r\n                let number = document.getElementById(\"s2_\" + l.TStart);\r\n                if (number) {\r\n                    let position = number.getBoundingClientRect();\r\n                    if (position.top > 90) {\r\n                        list.push({\r\n                            id: l.id,\r\n                            start: l.start,\r\n                            TStart: l.TStart,\r\n                            end: l.end,\r\n                            TEnd: l.TEnd,\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n            if (!_.isEmpty(list)) {\r\n                if (this.selectedWindow === 2) {\r\n                    this.debouncedScroll(list);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    selectedListRow(props: Props): number | null {\r\n        let row = null;\r\n        if (props.activeAnnotation) {\r\n            row = props.splitText.getTextIndexOfPosition(\r\n                props.activeAnnotation.start\r\n            );\r\n        }\r\n        return row;\r\n    }\r\n    handleSelection(e: Event) {\r\n        if (!this._modifyingSelection) {\r\n            this.activeSelection = document.getSelection();\r\n            if (!this._mouseDown) {\r\n                // sometimes, this gets called after the mouseDown event handler\r\n                this.mouseUp();\r\n            }\r\n        } else {\r\n            e.stopPropagation();\r\n            // Need to set this here. If set at callsite, the event will not\r\n            // have time to propagate.\r\n            this._modifyingSelection = false;\r\n        }\r\n    }\r\n    mouseDown() {\r\n        this._mouseDown = true;\r\n    }\r\n\r\n    mouseUp() {\r\n        this._mouseDown = false;\r\n        if (this.activeSelection) {\r\n            // let segmentIds = this.processSelection(this.activeSelection);\r\n            // if (!segmentIds) {\r\n            //     segmentIds = [];\r\n            // }\r\n            // this.props.didSelectSegmentIds(segmentIds);\r\n            this.activeSelection = null;\r\n        }\r\n    }\r\n\r\n    // processSelection(selection: Selection): string[] | null {\r\n    //     if (\r\n    //         selection.rangeCount === 0 ||\r\n    //         selection.isCollapsed ||\r\n    //         selection.type === \"Caret\"\r\n    //     ) {\r\n    //         this.selectedNodes = null;\r\n    //         return null;\r\n    //     }\r\n\r\n    //     const range = selection.getRangeAt(0);\r\n    //     const start = range.startContainer;\r\n    //     const startSpan = this.getNodeSegmentSpan(start);\r\n    //     if (!(startSpan && startSpan.parentNode)) {\r\n    //         If the selection is not a text segment, ignore.\r\n    //         Assuming if the first node is a non-segment, they\r\n    //         all are.\r\n    //         return null;\r\n    //     }\r\n\r\n    //     let nodes = this.getRangeNodes(range, startSpan.parentNode);\r\n    //     Check if the selection starts after the end of a node, and\r\n    //     if so remove that node.\r\n    //     if (nodes.length > 0) {\r\n    //         let firstNode = nodes[0];\r\n    //         if (range.startOffset === firstNode.textContent.length) {\r\n    //             nodes.shift();\r\n    //         }\r\n    //     }\r\n\r\n    //     const end = range.endContainer;\r\n    //     const endSpan = this.getNodeSegmentSpan(end);\r\n    //     if (!(endSpan && endSpan.parentNode)) {\r\n    //         return null;\r\n    //     }\r\n    //     if (endSpan && startSpan.parentNode !== endSpan.parentNode) {\r\n    //         Selection is spanning Texts.\r\n    //         We assume a selection can only run across a maximum\r\n    //         of two Texts.\r\n    //         nodes = nodes.concat(this.getRangeNodes(range, endSpan.parentNode));\r\n    //     } else {\r\n    //         Check if the selection ends before the start of a node, and\r\n    //         if so remove that node.\r\n    //         if (range.endOffset === 0) {\r\n    //             nodes.pop();\r\n    //         }\r\n    //     }\r\n    //     this.selectedNodes = nodes;\r\n    //     let nodeIds = [];\r\n    //     nodes.reduce((accumulator: string[], current: Node) => {\r\n    //         if (current instanceof Element) {\r\n    //             accumulator.push(current.id);\r\n    //         }\r\n    //         return accumulator;\r\n    //     }, nodeIds);\r\n\r\n    //     return nodeIds;\r\n    // }\r\n    // getRangeNodes(range: Range, parentNode: Node): Node[] {\r\n    //     let rangeSpans = [];\r\n    //     for (let i = 0, len = parentNode.childNodes.length; i < len; i++) {\r\n    //         const node = parentNode.childNodes[i];\r\n    //         // TODO: add polyfill for i.e.?\r\n    //         // e.g. https://gist.github.com/jonathansampson/6d09bd6d2e8c22c53868aec42e66b0f9\r\n    //         if (range.intersectsNode(node)) {\r\n    //             rangeSpans.push(node);\r\n    //         }\r\n    //     }\r\n    //     return rangeSpans;\r\n    // }\r\n    getNodeSegmentSpan(node: Node): Element | null {\r\n        let currentNode = node;\r\n        let span = null;\r\n        const test = /^(i|s|ds)_/;\r\n        while (!span && currentNode.parentNode) {\r\n            if (currentNode instanceof Element && test.test(currentNode.id)) {\r\n                span = currentNode;\r\n            }\r\n            currentNode = currentNode.parentNode;\r\n        }\r\n\r\n        return span;\r\n    }\r\n\r\n    updateList(\r\n        resetCache: boolean = true,\r\n        resetRows: number | number[] | null = null\r\n    ) {\r\n        if (\r\n            this.props.showImages &&\r\n            !this.calculatedImageHeight &&\r\n            this.imageHeight &&\r\n            this.imageWidth\r\n        ) {\r\n            this.calculatedImageHeight = this.calculateImageHeight();\r\n        }\r\n        if (this.list) {\r\n            const list = this.list;\r\n            if (resetCache) {\r\n                if (resetRows !== null) {\r\n                    if (!Array.isArray(resetRows)) {\r\n                        this.cache.clear(resetRows);\r\n                    } else if (Array.isArray(resetRows)) {\r\n                        for (let i = 0; i < resetRows.length; i++) {\r\n                            let resetRow = resetRows[i];\r\n                            this.cache.clear(resetRow);\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.cache.clearAll();\r\n                    list.measureAllRows();\r\n                    list.recomputeRowHeights(0);\r\n                }\r\n            }\r\n            list.forceUpdateGrid();\r\n        }\r\n    }\r\n\r\n    processProps(props: Props) {\r\n        let changedWitness = false;\r\n        if (\r\n            !this.props.selectedWitness ||\r\n            (props.selectedWitness &&\r\n                props.selectedWitness.id !== this.props.selectedWitness.id)\r\n        ) {\r\n            changedWitness = true;\r\n            this._didSetInitialScrollPosition = false;\r\n        }\r\n\r\n        if (\r\n            props.selectedSearchResult &&\r\n            (!this.props.selectedSearchResult ||\r\n                props.selectedSearchResult.start !==\r\n                    this.props.selectedSearchResult.start ||\r\n                props.selectedSearchResult.textId !==\r\n                    this.props.selectedSearchResult.textId)\r\n        ) {\r\n            console.log(\"resetting scroll position from search result\");\r\n            this._didSetInitialScrollPosition = false;\r\n        }\r\n\r\n        // TODO: check if new selectedSearchResult and if so\r\n        // set this._didSetInitialScrollPosition = false\r\n\r\n        // make sure there's no numbers in selectedAnnotatedSegments\r\n        // as we want to pass it to Text which only expects TextSegments\r\n        // this._filteredSelectedAnnotatedSegments = props.selectedAnnotatedSegments.reduce(\r\n        //     (acc, current: TextSegment | number) => {\r\n        //         if (current instanceof TextSegment) acc.push(current);\r\n        //         return acc;\r\n        //     },\r\n        //     []\r\n        // );\r\n\r\n        const controlsMeasurements = this.getControlsMeasurements(props);\r\n        if (controlsMeasurements) {\r\n            this.selectedTextIndex = controlsMeasurements.selectedTextIndex;\r\n            this.firstSelectedSegment =\r\n                controlsMeasurements.firstSelectedSegment;\r\n            this.splitTextRect = controlsMeasurements.splitTextRect;\r\n            this.selectedElementId = controlsMeasurements.selectedElementId;\r\n            this.selectedElementIds = controlsMeasurements.selectedElementIds;\r\n        }\r\n\r\n        if (\r\n            props.textListVisible !== this.textListVisible ||\r\n            props.editMenuVisible !== this.editMenuVisible\r\n        ) {\r\n            setTimeout(() => {\r\n                this.textListVisible = props.textListVisible;\r\n                this.editMenuVisible = props.editMenuVisible;\r\n                this.updateList(true);\r\n            }, 500);\r\n        } else {\r\n            if (changedWitness) {\r\n                this.updateList(true);\r\n            } else if (this.pageBreaksChanged(this.props, props)) {\r\n                let selectedRows = null;\r\n                let currentSelectedRow = this.selectedListRow(this.props);\r\n                let newSelectedRow = this.selectedListRow(props);\r\n                if (currentSelectedRow && newSelectedRow) {\r\n                    let firstChangedRow =\r\n                        currentSelectedRow > newSelectedRow\r\n                            ? newSelectedRow\r\n                            : currentSelectedRow;\r\n\r\n                    let splitRowTexts = this.props.splitText.texts;\r\n                    selectedRows = [];\r\n                    for (\r\n                        let i = firstChangedRow, len = splitRowTexts.length;\r\n                        i < len;\r\n                        i++\r\n                    ) {\r\n                        selectedRows.push(i);\r\n                    }\r\n                }\r\n                this.updateList(true, selectedRows);\r\n            } else if (this.lineBreaksChanges(this.props, props)) {\r\n                let selectedRow = this.selectedListRow(props);\r\n                if (!selectedRow)\r\n                    selectedRow = this.selectedListRow(this.props);\r\n                let splitRowTexts = this.props.splitText.texts;\r\n                let selectedRows = [];\r\n                if (selectedRow !== null) {\r\n                    for (\r\n                        let i = selectedRow, len = splitRowTexts.length;\r\n                        i < len;\r\n                        i++\r\n                    ) {\r\n                        selectedRows.push(i);\r\n                    }\r\n                    this.updateList(true, selectedRows);\r\n                }\r\n            } else if (this.props.fontSize !== props.fontSize) {\r\n                this.updateList(true);\r\n            } else if (\r\n                this.props.activeAnnotation &&\r\n                props.activeAnnotation &&\r\n                this.annotationsInSameLocation(\r\n                    this.props.activeAnnotation,\r\n                    props.activeAnnotation\r\n                )\r\n            ) {\r\n                this.updateList(true, this.selectedListRow(props));\r\n            } else {\r\n                this.updateList(this.shouldResetListCache(this.props, props));\r\n            }\r\n        }\r\n    }\r\n\r\n    pageBreaksChanged(oldProps: Props, newProps: Props) {\r\n        const oldTextBreaks = oldProps.splitText.getTextsFinalPositions();\r\n        const newTextBreaks = newProps.splitText.getTextsFinalPositions();\r\n\r\n        if (oldTextBreaks.length !== newTextBreaks.length) return true;\r\n\r\n        return JSON.stringify(oldTextBreaks) !== JSON.stringify(newTextBreaks);\r\n    }\r\n\r\n    lineBreaksChanges(oldProps: Props, newProps: Props) {\r\n        let oldActiveAnnotation = oldProps.activeAnnotation;\r\n        let newActiveAnnotation = newProps.activeAnnotation;\r\n        let hasChanged = false;\r\n\r\n        if (\r\n            oldActiveAnnotation &&\r\n            oldActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) &&\r\n            newProps.activeAnnotations &&\r\n            !newProps.activeAnnotations.hasOwnProperty(\r\n                oldActiveAnnotation.uniqueId\r\n            )\r\n        ) {\r\n            hasChanged = true;\r\n        }\r\n\r\n        if (\r\n            newActiveAnnotation &&\r\n            newActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) &&\r\n            oldProps.activeAnnotations &&\r\n            !oldProps.activeAnnotations.hasOwnProperty(\r\n                newActiveAnnotation.uniqueId\r\n            )\r\n        ) {\r\n            hasChanged = true;\r\n        }\r\n\r\n        return hasChanged;\r\n    }\r\n    shouldResetListCache(oldProps: Props, newProps: Props) {\r\n        let shouldReset = false;\r\n        if (\r\n            oldProps.showImages !== newProps.showImages ||\r\n            this.pageBreaksChanged(oldProps, newProps)\r\n        ) {\r\n            shouldReset = true;\r\n        }\r\n\r\n        return shouldReset;\r\n    }\r\n\r\n    UNSAFE_componentWillReceiveProps(props: Props) {\r\n        this.processProps(props);\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.resizeHandler = _.throttle(() => {\r\n            this.calculatedImageHeight = null;\r\n            this.updateList();\r\n        }, 500).bind(this);\r\n        window.addEventListener(\"resize\", this.resizeHandler);\r\n\r\n        this.debouncedScroll = _.debounce((list) => {\r\n            this.changeScrollToId({ id: list[0].TStart, from: 2 });\r\n        }, 1000);\r\n        this.selectionHandler = _.debounce((e) => {\r\n            this.handleSelection(e);\r\n        }, 200).bind(this);\r\n\r\n        document.addEventListener(\"selectionchange\", this.selectionHandler);\r\n\r\n        document.addEventListener(\"mousedown\", this.mouseDown.bind(this), true);\r\n        document.addEventListener(\"mouseup\", this.mouseUp.bind(this), true);\r\n\r\n        this.processProps(this.props);\r\n        this.componentDidUpdate();\r\n        this.splitText.style.scrollBehavior = \"smooth\";\r\n        this.timer = setTimeout(() => {\r\n            this.resizeHandler();\r\n        }, 2000);\r\n    }\r\n    scrollToIndex(selectedTextIndex) {\r\n        let list = this.list;\r\n\r\n        setTimeout(() => {\r\n            list.scrollToRow(selectedTextIndex);\r\n            setTimeout(() => {\r\n                list.scrollToPosition(list.props.scrollTop - 300);\r\n            }, 0);\r\n        }, 100);\r\n    }\r\n    componentDidUpdate(prevProps, prevState) {\r\n        let scrollToId = this.props.scrollToId;\r\n        this.targetId2 = this.props.syncIdOnClick;\r\n        this.selectedWindow = this.props.selectedWindow;\r\n        let SearchSyncId = this.props.syncIdOnSearch || null;\r\n        let list = this.list;\r\n        let result = this.props.searchResults;\r\n        let Alignment = this.props.textAlignment;\r\n        this.condition = this.props.condition;\r\n        let con =\r\n            prevProps?.searchResults !== this.props?.searchResults ||\r\n            prevProps?.syncIdOnSearch !== this.props?.syncIdOnSearch;\r\n\r\n        // for scrolling for search results;\r\n\r\n        if (con && result) {\r\n            if (SearchSyncId) {\r\n                let selectedTextIndex =\r\n                    this.props.splitText.getTextIndexOfPosition(SearchSyncId);\r\n                this.scrollToIndex(selectedTextIndex);\r\n            }\r\n        }\r\n\r\n        // scroll dom with respect to window 1 scrolling\r\n\r\n        if (\r\n            this.selectedWindow === 1 &&\r\n            scrollToId.from === 1 &&\r\n            this.condition &&\r\n            scrollToId.id !== null\r\n        ) {\r\n            this.textAlignmentById = this.props.textAlignmentById || [];\r\n\r\n            if (Alignment) {\r\n                let req = this.textAlignmentById.find(\r\n                    (l) => l.start === scrollToId.id\r\n                );\r\n                let TStart = req?.TStart;\r\n                if (TStart !== null) {\r\n                    let selectedTextIndex =\r\n                        this.props.splitText.getTextIndexOfPosition(TStart);\r\n                    this.scrollToIndex(selectedTextIndex);\r\n                }\r\n            }\r\n        }\r\n        // scroll dom with respect to window 1 click\r\n        //for scrolling to the highlighted alignment if its outside visible DOM\r\n\r\n        if (\r\n            this.targetId2 &&\r\n            scrollToId.from === null &&\r\n            this.selectedWindow === 1 &&\r\n            scrollToId.id === null &&\r\n            this.condition\r\n        ) {\r\n            let clickIdObj = Alignment.alignment.find(\r\n                (l) =>\r\n                    this.targetId2 >= l.source_segment.start &&\r\n                    this.targetId2 < l.source_segment.end\r\n            );\r\n            let syncClickTargetId = clickIdObj?.target_segment?.start;\r\n            let selectedTextIndex =\r\n                this.props.splitText.getTextIndexOfPosition(syncClickTargetId);\r\n\r\n            this.scrollToIndex(selectedTextIndex);\r\n        }\r\n\r\n        // if (this.selectedNodes && this.selectedNodes.length > 0) {\r\n        //     const selectedNodes = this.selectedNodes;\r\n        //     const selectedSegments = this.props.selectedAnnotatedSegments;\r\n        //     setTimeout(() => {\r\n        //         let selRange = document.createRange();\r\n        //         let startNode = selectedNodes[0];\r\n        //         let endNode = selectedNodes[selectedNodes.length - 1];\r\n        //         // let lastSegment = selectedSegments[selectedSegments.length - 1];\r\n        //         if (lastSegment instanceof TextSegment) {\r\n        //             let lastElement = document.getElementById(\r\n        //                 idForSegment(lastSegment)\r\n        //             );\r\n        //             if (lastElement) endNode = lastElement;\r\n        //         }\r\n        //         if (\r\n        //             startNode instanceof Element &&\r\n        //             endNode instanceof Element\r\n        //         ) {\r\n        //             startNode = document.getElementById(startNode.id);\r\n        //             endNode = document.getElementById(endNode.id);\r\n        //             if (startNode && endNode) {\r\n        //                 selRange.setStart(startNode, 0);\r\n        //                 selRange.setEnd(endNode, endNode.childNodes.length);\r\n        //                 let sel = document.getSelection();\r\n        //                 if (sel) {\r\n        //                     this._modifyingSelection = true;\r\n        //                     sel.removeAllRanges();\r\n        //                     sel.addRange(selRange);\r\n        //                     this.selectedNodes = null;\r\n        //                 }\r\n        //             }\r\n        //         }\r\n        //     }, 0);\r\n        // }\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        document.removeEventListener(\"mousedown\", this);\r\n        document.removeEventListener(\"mouseup\", this);\r\n        window.removeEventListener(\"resize\", this.resizeHandler);\r\n\r\n        document.removeEventListener(\"selectionchange\", this.selectionHandler);\r\n        clearTimeout(this.timer);\r\n    }\r\n\r\n    getSelectedTextIndex(): number {\r\n        let selectedTextIndex = 0;\r\n        let startPos = null;\r\n        if (this.props.activeAnnotation) {\r\n            [startPos] =\r\n                this.props.splitText.annotatedText.getPositionOfAnnotation(\r\n                    this.props.activeAnnotation\r\n                );\r\n        } else if (this.props.selectedSearchResult) {\r\n            let segment =\r\n                this.props.splitText.annotatedText.segmentAtOriginalPosition(\r\n                    this.props.selectedSearchResult.start\r\n                );\r\n            if (segment instanceof TextSegment) {\r\n                startPos = segment.start;\r\n            } else if (typeof segment === \"number\") {\r\n                startPos = segment;\r\n            }\r\n        }\r\n        if (startPos) {\r\n            selectedTextIndex =\r\n                this.props.splitText.getTextIndexOfPosition(startPos);\r\n        }\r\n        return selectedTextIndex;\r\n    }\r\n    getControlsMeasurements(props: Props): {\r\n        selectedTextIndex: number,\r\n        firstSelectedSegment: TextSegment,\r\n        selectedElementId: string,\r\n        splitTextRect: ClientRect,\r\n        selectedElementIds: string[],\r\n    } | null {\r\n        if (!this.splitText) {\r\n            return null;\r\n        }\r\n        let splitTextComponent = this.splitText;\r\n        let selectedTextIndex = null;\r\n        let firstSelectedSegment = null;\r\n        let selectedElementId = null;\r\n        let splitTextRect = null;\r\n        let segmentIdFunction: null | ((segment: TextSegment) => string) = null;\r\n        let selectedElementIds = [];\r\n        let startPos = 0;\r\n        if (props.activeAnnotation) {\r\n            let activeAnnotation = props.activeAnnotation;\r\n            [startPos] =\r\n                props.splitText.annotatedText.getPositionOfAnnotation(\r\n                    activeAnnotation\r\n                );\r\n            if (startPos === null) {\r\n                console.warn(\"No startPos in getControlsMeasurements\");\r\n                return null;\r\n            }\r\n            if (activeAnnotation.type === ANNOTATION_TYPES.pageBreak) {\r\n                startPos -= 1;\r\n            }\r\n            if (activeAnnotation.type === ANNOTATION_TYPES.lineBreak) {\r\n                startPos -= 1;\r\n            }\r\n\r\n            // Index of text containing end of annotation\r\n            let positionEnd = startPos + activeAnnotation.length;\r\n            if (activeAnnotation.length > 0) positionEnd -= 1;\r\n            selectedTextIndex =\r\n                props.splitText.getTextIndexOfPosition(positionEnd);\r\n            splitTextRect = splitTextComponent.getBoundingClientRect();\r\n        }\r\n        let selectedAnnotatedSegments = [];\r\n        if (\r\n            props.selectedAnnotatedSegments &&\r\n            props.selectedAnnotatedSegments.length > 0\r\n        ) {\r\n            selectedAnnotatedSegments = props.selectedAnnotatedSegments;\r\n            for (let i = 0; i < selectedAnnotatedSegments.length; i++) {\r\n                let segment = selectedAnnotatedSegments[i];\r\n                if (\r\n                    firstSelectedSegment === null &&\r\n                    segment instanceof TextSegment\r\n                ) {\r\n                    firstSelectedSegment = segment;\r\n                    break;\r\n                }\r\n            }\r\n            if (firstSelectedSegment) {\r\n                if (\r\n                    firstSelectedSegment.length === 0 &&\r\n                    props.activeAnnotation &&\r\n                    props.activeAnnotation.isInsertion\r\n                ) {\r\n                    selectedElementId = idForInsertion(firstSelectedSegment);\r\n                    segmentIdFunction = idForInsertion;\r\n                } else {\r\n                    selectedElementId = idForSegment(firstSelectedSegment);\r\n                    segmentIdFunction = idForSegment;\r\n                }\r\n            }\r\n        } else if (props.activeAnnotation) {\r\n            if (props.activeAnnotation.isDeletion) {\r\n                let segment = new TextSegment(startPos, \"\");\r\n                selectedElementId = idForDeletedSegment(segment);\r\n                segmentIdFunction = idForDeletedSegment;\r\n                firstSelectedSegment = segment;\r\n                selectedAnnotatedSegments = [firstSelectedSegment];\r\n            } else if (props.activeAnnotation.isInsertion) {\r\n                const [start] =\r\n                    props.splitText.annotatedText.getPositionOfAnnotation(\r\n                        props.activeAnnotation\r\n                    );\r\n                if (start) {\r\n                    let segment = new TextSegment(start, \"\");\r\n                    selectedElementId = idForInsertion(segment);\r\n                    segmentIdFunction = idForInsertion;\r\n                    firstSelectedSegment = segment;\r\n                    selectedAnnotatedSegments = [firstSelectedSegment];\r\n                }\r\n            } else if (\r\n                props.activeAnnotation.type === ANNOTATION_TYPES.pageBreak\r\n            ) {\r\n                let segment = new TextSegment(startPos + 1, \"\");\r\n                let prevSegment = new TextSegment(startPos, \"\");\r\n                selectedElementId = idForPageBreak(prevSegment);\r\n                firstSelectedSegment = segment;\r\n                selectedAnnotatedSegments = [segment];\r\n                selectedElementIds = [selectedElementId];\r\n            } else if (\r\n                props.activeAnnotation.type === ANNOTATION_TYPES.lineBreak\r\n            ) {\r\n                let segment = new TextSegment(startPos + 1, \"\");\r\n                let prevSegment = new TextSegment(startPos, \"\");\r\n                selectedElementId = idForLineBreak(prevSegment);\r\n                firstSelectedSegment = segment;\r\n                selectedAnnotatedSegments = [segment];\r\n                selectedElementIds = [selectedElementId];\r\n            }\r\n        }\r\n        if (segmentIdFunction) {\r\n            for (let i = 0; i < selectedAnnotatedSegments.length; i++) {\r\n                let segment = selectedAnnotatedSegments[i];\r\n                if (segment instanceof TextSegment) {\r\n                    const segmentId = segmentIdFunction(segment);\r\n                    selectedElementIds.push(segmentId);\r\n                }\r\n            }\r\n        }\r\n        if (\r\n            selectedTextIndex != null &&\r\n            firstSelectedSegment &&\r\n            selectedElementId &&\r\n            splitTextRect\r\n        ) {\r\n            return {\r\n                selectedTextIndex: selectedTextIndex,\r\n                firstSelectedSegment: firstSelectedSegment,\r\n                selectedElementId: selectedElementId,\r\n                splitTextRect: splitTextRect,\r\n                selectedElementIds: selectedElementIds,\r\n            };\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const props = this.props;\r\n        const rowRenderer = this.rowRenderer;\r\n        const cache = this.cache;\r\n        const key = props.selectedWitness ? props.selectedWitness.id : 0;\r\n\r\n        return (\r\n            <div\r\n                className={styles.splitText2}\r\n                ref={(div) => (this.splitText = div)}\r\n                key={key}\r\n                style={{\r\n                    cursor: \"pointer\",\r\n                }}\r\n            >\r\n                <button\r\n                    id=\"updateList2\"\r\n                    style={{ display: \"none\" }}\r\n                    onClick={() => this.updateList(true)}\r\n                ></button>\r\n                <AutoSizer disableWidth>\r\n                    {({ height }) => (\r\n                        <List\r\n                            ref={(list) => (this.list = list)}\r\n                            height={height}\r\n                            rowCount={props.splitText.texts.length}\r\n                            rowHeight={cache.rowHeight}\r\n                            rowRenderer={rowRenderer}\r\n                            width={1}\r\n                            overscanRowCount={1}\r\n                            deferredMeasurementCache={cache}\r\n                            onScroll={this.scrollEvent}\r\n                            scrollToAlignment=\"start\"\r\n                            containerStyle={{\r\n                                width: \"100%\",\r\n                                maxWidth: \"100%\",\r\n                            }}\r\n                            style={{\r\n                                width: \"100%\",\r\n                            }}\r\n                        ></List>\r\n                    )}\r\n                </AutoSizer>\r\n            </div>\r\n        );\r\n    }\r\n    getStringPositions(\r\n        text: SegmentedText,\r\n        string: string,\r\n        index: number\r\n    ): { [position: number]: [number, number] } {\r\n        const uniqueId = this.props.splitText.annotatedText.getUniqueId();\r\n\r\n        if (!_searchResultsCache.hasOwnProperty(uniqueId)) {\r\n            _searchResultsCache = {\r\n                [uniqueId]: {},\r\n            };\r\n        }\r\n\r\n        if (!_searchResultsCache[uniqueId].hasOwnProperty(string)) {\r\n            _searchResultsCache[uniqueId] = {\r\n                [string]: {},\r\n            };\r\n        }\r\n\r\n        if (_searchResultsCache[uniqueId][string].hasOwnProperty(index)) {\r\n            return _searchResultsCache[uniqueId][string][index];\r\n        }\r\n\r\n        const splitter = new GraphemeSplitter();\r\n        const content = text.getText();\r\n        const firstSegment = text.segments[0];\r\n        const startingPosition = firstSegment.start;\r\n        let positions = [];\r\n        let position = content.indexOf(string);\r\n        while (position !== -1) {\r\n            positions.push(position);\r\n            position = content.indexOf(string, position + 1);\r\n        }\r\n\r\n        // Position needs to be position in complete text\r\n        let verifiedPositions: { [position: number]: [number, number] } = {};\r\n        if (positions.length > 0) {\r\n            const graphemes = splitter.splitGraphemes(content);\r\n            let position = 0;\r\n            let activePosition = null;\r\n            for (let i = 0; i < graphemes.length; i++) {\r\n                const grapheme = graphemes[i];\r\n                const graphemeEnd = position + (grapheme.length - 1);\r\n                if (activePosition !== null) {\r\n                    let expectedEnd = activePosition + (string.length - 1);\r\n                    if (graphemeEnd >= expectedEnd) {\r\n                        verifiedPositions[activePosition + startingPosition] = [\r\n                            activePosition + startingPosition,\r\n                            graphemeEnd + startingPosition,\r\n                        ];\r\n                        activePosition = null;\r\n                    }\r\n                } else if (positions.indexOf(position) !== -1) {\r\n                    if (string.length === grapheme.length) {\r\n                        verifiedPositions[position + startingPosition] = [\r\n                            position + startingPosition,\r\n                            graphemeEnd + startingPosition,\r\n                        ];\r\n                    } else if (string.length > grapheme.length) {\r\n                        activePosition = position;\r\n                    }\r\n                } else {\r\n                    activePosition = null;\r\n                }\r\n\r\n                position += grapheme.length;\r\n            }\r\n        }\r\n\r\n        _searchResultsCache[uniqueId][string][index] = verifiedPositions;\r\n\r\n        return verifiedPositions;\r\n    }\r\n\r\n    rowRenderer({\r\n        key,\r\n        index,\r\n        parent,\r\n        style,\r\n    }: {\r\n        key: string,\r\n        index: number,\r\n        parent: {},\r\n        style: {},\r\n    }): React.Element<CellMeasurer> {\r\n        const props = this.props;\r\n        const cache = this.cache;\r\n\r\n        let searchStringPositions = {};\r\n        let searchValue = this.props.searchValue;\r\n        if (searchValue && searchValue.length > 0 && props.splitText) {\r\n            searchStringPositions = this.getStringPositions(\r\n                props.splitText.texts[index],\r\n                searchValue,\r\n                index\r\n            );\r\n        }\r\n\r\n        let newStyle = { ...style, height: style.height + 10 };\r\n        return (\r\n            <CellMeasurer\r\n                columnIndex={0}\r\n                key={key}\r\n                parent={parent}\r\n                rowIndex={index}\r\n                cache={cache}\r\n            >\r\n                <div\r\n                    key={key}\r\n                    style={newStyle}\r\n                    ref={this.splitTextRef}\r\n                    id={`index2_${index}`}\r\n                    className={styles.splitTextRow}\r\n                >\r\n                    <div className={styles.splitTextRowContent}>\r\n                        <Text2\r\n                            segmentedText={props.splitText.texts[index]}\r\n                            row={index}\r\n                            selectedSegmentId={props.selectedSegmentId}\r\n                            // searchValue={searchValue}\r\n                            // selectedSearchResult={\r\n                            //     this.props.selectedSearchResult\r\n                            // }\r\n                            searchStringPositions={searchStringPositions}\r\n                            textAlignmentById={props.textAlignmentById}\r\n                            fontSize={props.fontSize}\r\n                            isPanelLinked={this.props.isPanelLinked}\r\n                            selectedSourceRange={props.selectedSourceRange}\r\n                            selectedTargetRange={props.selectedTargetRange}\r\n                            changeSelectedRange={props.changeSelectedRange}\r\n                            changeSyncIdOnClick={this.props.changeSyncIdOnClick}\r\n                            changeScrollToId={this.props.changeScrollToId}\r\n                            condition={this.condition}\r\n                        />\r\n                    </div>\r\n                </div>\r\n            </CellMeasurer>\r\n        );\r\n    }\r\n}\r\n","import React from \"react\";\r\nimport { Box, Typography } from \"@mui/material\";\r\nimport Loader from \"react-loader\";\r\n\r\nimport { styled, alpha } from \"@mui/material/styles\";\r\nimport SearchIcon from \"@mui/icons-material/Search\";\r\nimport InputBase from \"@mui/material/InputBase\";\r\nimport Toolbar from \"@mui/material/Toolbar\";\r\n\r\nconst Search = styled(\"div\")(({ theme }) => ({\r\n    position: \"relative\",\r\n    borderRadius: theme.shape.borderRadius,\r\n    backgroundColor: alpha(theme.palette.common.white, 0.15),\r\n    \"&:hover\": {\r\n        backgroundColor: alpha(theme.palette.common.white, 0.25),\r\n    },\r\n    marginLeft: 0,\r\n    width: \"100%\",\r\n    [theme.breakpoints.up(\"sm\")]: {\r\n        marginLeft: theme.spacing(1),\r\n        width: \"auto\",\r\n    },\r\n}));\r\n\r\nconst SearchIconWrapper = styled(\"div\")(({ theme }) => ({\r\n    padding: theme.spacing(0, 2),\r\n    height: \"100%\",\r\n    position: \"absolute\",\r\n    pointerEvents: \"none\",\r\n    display: \"flex\",\r\n    alignItems: \"center\",\r\n    justifyContent: \"center\",\r\n}));\r\n\r\nconst StyledInputBase = styled(InputBase)(({ theme }) => ({\r\n    color: \"inherit\",\r\n    \"& .MuiInputBase-input\": {\r\n        padding: theme.spacing(1, 1, 1, 0),\r\n        // vertical padding + font size from searchIcon\r\n        paddingLeft: `calc(1em + ${theme.spacing(4)})`,\r\n        transition: theme.transitions.create(\"width\"),\r\n        width: \"100%\",\r\n        [theme.breakpoints.up(\"sm\")]: {\r\n            width: \"0\",\r\n            cursor: \"pointer\",\r\n            \"&:focus\": {\r\n                width: \"20ch\",\r\n            },\r\n        },\r\n    },\r\n}));\r\n\r\nfunction TableOfContent() {\r\n    let data = [\r\n        { Id: 1, Title: \"chapter 1\", segment_id: 0 },\r\n        { Id: 2, Title: \"chapter 2\", segment_id: 400 },\r\n    ];\r\n    let loaded = data.length > 0 ? true : false;\r\n\r\n    return (\r\n        <Box\r\n            sx={{\r\n                bgcolor: \"heading.main\",\r\n                color: \"text.primary\",\r\n                width: \"100%\",\r\n                height: \"100%\",\r\n                paddingInline: 2,\r\n            }}\r\n        >\r\n            <Toolbar\r\n                sx={{\r\n                    justifyContent: \"space-between\",\r\n                    paddingLeft: \"0 !important\",\r\n                    margin: 0,\r\n                }}\r\n            >\r\n                <Typography textTransform={\"uppercase\"} component=\"h6\">\r\n                    Table Of Content\r\n                </Typography>\r\n                <Search>\r\n                    <SearchIconWrapper>\r\n                        <SearchIcon />\r\n                    </SearchIconWrapper>\r\n                    <StyledInputBase\r\n                        placeholder=\"Search…\"\r\n                        inputProps={{ \"aria-label\": \"search\" }}\r\n                    />\r\n                </Search>\r\n            </Toolbar>\r\n            {/* <Loader loaded={loaded} /> */}\r\n            <Box>\r\n                {data.map((list, index) => {\r\n                    return (\r\n                        <Box\r\n                            key={\"TableContent-\" + index}\r\n                            sx={{\r\n                                cursor: \"pointer\",\r\n                                width: \"fit-content\",\r\n                                \"&:hover\": {\r\n                                    fontWeight: \"bold\",\r\n                                },\r\n                            }}\r\n                        >\r\n                            {list.Title}\r\n                        </Box>\r\n                    );\r\n                })}\r\n            </Box>\r\n        </Box>\r\n    );\r\n}\r\n\r\nexport default TableOfContent;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"paddingSide\":\"20px\",\"maxWidth\":\"600px\",\"text\":\"Text2---text\",\"textFirstRow\":\"Text2---textFirstRow\",\"textLine\":\"Text2---textLine\",\"textline\":\"Text2---textline\",\"limitWidth\":\"Text2---limitWidth\",\"textContainer\":\"Text2---textContainer\",\"annotation\":\"Text2---annotation\",\"removedByAnnotation\":\"Text2---removedByAnnotation\",\"insertion\":\"Text2---insertion\",\"highlight\":\"Text2---highlight\",\"activeHighlight\":\"Text2---activeHighlight\",\"lineBreak\":\"Text2---lineBreak\",\"pageBreak\":\"Text2---pageBreak\",\"syncIdClass\":\"Text2---syncIdClass\",\"selectedRangelight\":\"Text2---selectedRangelight\",\"selectedRangeDark\":\"Text2---selectedRangeDark\"};","// @flow\r\nimport React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport styles from \"./Text2.css\";\r\nimport TextSegment from \"lib/TextSegment\";\r\nimport {\r\n    INSERTION_KEY,\r\n    DELETION_KEY,\r\n    PAGE_BREAK_KEY,\r\n    LINE_BREAK_KEY,\r\n} from \"lib/AnnotatedText\";\r\nimport _ from \"lodash\";\r\nimport SegmentedText from \"lib/SegmentedText\";\r\nimport Annotation from \"lib/Annotation\";\r\nimport Witness from \"lib/Witness\";\r\nimport { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport GraphemeSplitter from \"grapheme-splitter\";\r\nimport { withTheme } from \"@mui/styles\";\r\n\r\nexport function idForSegment(segment: TextSegment): string {\r\n    return \"s2_\" + segment.start;\r\n}\r\n\r\nexport function idForDeletedSegment(segment: TextSegment): string {\r\n    return \"ds_\" + segment.start;\r\n}\r\n\r\n// export function idForInsertion(segment: TextSegment): string {\r\n//     return \"i_\" + segment.start;\r\n// }\r\n\r\n// export function idForPageBreak(segment: TextSegment): string {\r\n//     return \"p_\" + (segment.end + 1);\r\n// }\r\n\r\n// export function idForLineBreak(segment: TextSegment): string {\r\n//     return \"l_\" + (segment.end + 1);\r\n// }\r\n\r\nexport type Props = {\r\n    segmentedText: SegmentedText,\r\n    annotationPositions: { [string]: Annotation[] },\r\n    selectedSegmentId: (id: string) => void,\r\n    activeAnnotations: { [AnnotationUniqueId]: Annotation } | null,\r\n    getBaseAnnotation: (annotation: Annotation) => Annotation,\r\n    selectedAnnotatedSegments: TextSegment[],\r\n    row: number,\r\n    activeAnnotation: Annotation | null,\r\n    searchValue: string | null,\r\n    selectedSearchResult: {\r\n        textId: number,\r\n        start: number,\r\n        length: number,\r\n    } | null,\r\n    searchStringPositions: { [position: number]: [number, number] },\r\n    fontSize?: number,\r\n    activeWitness: Witness,\r\n    textAlignmentById: {},\r\n    selectedSourceRange: [],\r\n    selectedTargetRange: [],\r\n    changeSyncIdOnClick: () => void,\r\n};\r\n\r\nexport type State = {\r\n    segmentedText: SegmentedText,\r\n};\r\n\r\n// import ReactDOMServer from \"react-dom/server\";\r\n// import PageBreakIcon from \"images/page_break_icon.svg\";\r\n// const PARA_SYMBOL = String.fromCharCode(182);\r\n// const pageBreakIconString = ReactDOMServer.renderToStaticMarkup(\r\n//     <PageBreakIcon />\r\n// );\r\n\r\nclass Text2 extends React.Component<Props, State> {\r\n    _renderedSegments: TextSegment[] | null;\r\n    _renderedHtml: { __html: string } | null;\r\n    textAlignmentById;\r\n\r\n    constructor(props: Props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            segmentedText: props.segmentedText,\r\n        };\r\n        this.textAlignmentById = this.props.textAlignmentById;\r\n        this._renderedSegments = null;\r\n        this._renderedHtml = null;\r\n    }\r\n\r\n    UNSAFE_componentWillReceiveProps(nextProps: Props) {\r\n        this.setState((prevState: State, props: Props) => {\r\n            return {\r\n                ...prevState,\r\n                segmentedText: nextProps.segmentedText,\r\n            };\r\n        });\r\n    }\r\n\r\n    // annotationsForSegment(segment: TextSegment): Annotation[] {\r\n    //     let annotations: Annotation[] = [];\r\n    //     const foundAnnotations = this.props.annotationPositions[\r\n    //         String(segment.start)\r\n    //     ];\r\n    //     if (foundAnnotations) {\r\n    //         annotations = foundAnnotations;\r\n    //     }\r\n    //     const insertions =\r\n    //         this.props.annotationPositions[INSERTION_KEY + segment.start] || [];\r\n    //     const deletions =\r\n    //         this.props.annotationPositions[DELETION_KEY + segment.start] || [];\r\n    //     const pageBreaks =\r\n    //         this.props.annotationPositions[\r\n    //             PAGE_BREAK_KEY + (segment.end + 1)\r\n    //         ] || [];\r\n    //     const lineBreaks =\r\n    //         this.props.annotationPositions[\r\n    //             LINE_BREAK_KEY + (segment.end + 1)\r\n    //         ] || [];\r\n\r\n    //     return annotations.concat(\r\n    //         insertions,\r\n    //         deletions,\r\n    //         pageBreaks,\r\n    //         lineBreaks\r\n    //     );\r\n    // }\r\n\r\n    // segmentsContainSegment(segments: TextSegment[], segment: TextSegment) {\r\n    //     for (let i = 0; i < segments.length; i++) {\r\n    //         let listSegment = segments[i];\r\n    //         if (\r\n    //             listSegment.start === segment.start &&\r\n    //             listSegment.text === segment.text\r\n    //         ) {\r\n    //             return true;\r\n    //         }\r\n    //     }\r\n    //     return false;\r\n    // }\r\n\r\n    selectedElement(element: Element) {\r\n        let sourceRangeSelection = [];\r\n        let targetRangeSelection = [];\r\n        const selection = document.getSelection();\r\n        if (element?.id.includes(\"s2_\") && this.props.condition) {\r\n            var clickId = parseInt(element.id.replace(\"s2_\", \"\"));\r\n\r\n            this.props.changeSyncIdOnClick(clickId);\r\n            this.props.changeScrollToId({ id: \"ua\", from: \"ua\" });\r\n\r\n            let id = parseInt(element.id.replace(\"s2_\", \"\"));\r\n            let rangeUnique = this.textAlignmentById.find(\r\n                (l) => id >= l.TStart && id < l.TEnd\r\n            );\r\n            if (rangeUnique) {\r\n                for (let i = rangeUnique.start; i < rangeUnique.end; i++) {\r\n                    sourceRangeSelection.push(i);\r\n                }\r\n                for (let i = rangeUnique.TStart; i < rangeUnique.TEnd; i++) {\r\n                    targetRangeSelection.push(i);\r\n                }\r\n                this.props.changeSelectedRange({\r\n                    source: sourceRangeSelection,\r\n                    target: targetRangeSelection,\r\n                });\r\n            }\r\n        }\r\n\r\n        if (selection && selection.type === \"Range\") {\r\n            return;\r\n        }\r\n        this.props.selectedSegmentId(element.id);\r\n        if (!element.id) {\r\n            this.props.changeSelectedRange({ source: [], target: [] });\r\n        }\r\n    }\r\n\r\n    generateHtml(renderProps: Props, renderState: State): { __html: string } {\r\n        let segments = renderState.segmentedText.segments;\r\n\r\n        let textLineClass = styles.textLine;\r\n        let segmentHTML = '<p class=\"' + textLineClass + '\">';\r\n        if (segments.length === 0) return { __html: segmentHTML };\r\n\r\n        const endPosition = segments[segments.length - 1].end + 1;\r\n\r\n        let highlightClass = styles.highlight;\r\n        let activeHighlightClass = styles.activeHighlight;\r\n        let activeSearchResultEnd = null;\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let segment = segments[i];\r\n            let classAttribute = \"\";\r\n            let classes = [];\r\n            let selectedCurrentDeletion = false;\r\n            let selectedCurrentPageBreak = false;\r\n            let selectedCurrentLineBreak = false;\r\n            let lineBreakAnnotation = false;\r\n            let pageBreakAnnotation = null;\r\n\r\n            // It's an insertion at the end of the text, which should have just been added to the html.\r\n            // So break as we don't want anymore segment html adding.\r\n            if (segment.start === endPosition) {\r\n                break;\r\n            }\r\n            let id = null;\r\n            if (segment.length === 0) {\r\n                // id = idForDeletedSegment(segment);\r\n                // classes.push(styles.removedByAnnotation);\r\n                // if (deletionText) {\r\n                //     segment = new TextSegment(segment.start, deletionText);\r\n                // }\r\n            } else {\r\n                id = idForSegment(segment);\r\n            }\r\n\r\n            // if (\r\n            //     this.segmentsContainSegment(\r\n            //         renderProps.selectedAnnotatedSegments,\r\n            //         segment\r\n            //     ) ||\r\n            //     selectedCurrentDeletion\r\n            // ) {\r\n            //     classes.push(styles.selectedAnnotation);\r\n            // }\r\n            if (\r\n                renderProps.selectedTargetRange?.includes(segment.start) &&\r\n                renderProps.condition\r\n            ) {\r\n                let newClass =\r\n                    renderProps.theme.palette.mode === \"light\"\r\n                        ? styles.selectedRangelight\r\n                        : styles.selectedRangeDark;\r\n                classes.push(newClass);\r\n            }\r\n\r\n            if (classes.length > 0) {\r\n                let className = classnames(...classes);\r\n                classAttribute = 'class=\"' + className + '\"';\r\n            }\r\n\r\n            let segmentContent = segment.text;\r\n            // Add search result highlight if required.\r\n            if (renderProps.searchStringPositions) {\r\n                let segmentStart = segment.start;\r\n                let position = segmentStart;\r\n                segmentContent = \"\";\r\n\r\n                let highlight = highlightClass;\r\n                if (\r\n                    renderProps.selectedSearchResult &&\r\n                    renderProps.selectedSearchResult.start <= position &&\r\n                    renderProps.selectedSearchResult.start +\r\n                        renderProps.selectedSearchResult.length >\r\n                        position\r\n                ) {\r\n                    highlight = activeHighlightClass;\r\n                }\r\n\r\n                for (let j = 0; j < segment.text.length; j++) {\r\n                    let char = segment.text.charAt(j);\r\n                    position = segmentStart + j;\r\n                    if (activeSearchResultEnd) {\r\n                        let [start, end] = activeSearchResultEnd;\r\n                        if (j === 0) {\r\n                            segmentContent +=\r\n                                '<span class=\"' + highlight + '\">';\r\n                        }\r\n                        if (position === end) {\r\n                            segmentContent += char + \"</span>\";\r\n                            activeSearchResultEnd = null;\r\n                        } else if (j === segment.text.length - 1) {\r\n                            segmentContent += char + \"</span>\";\r\n                        } else {\r\n                            segmentContent += char;\r\n                        }\r\n                    } else if (position in renderProps.searchStringPositions) {\r\n                        let [start, end] =\r\n                            renderProps.searchStringPositions[position];\r\n                        segmentContent +=\r\n                            '<span class=\"' + highlight + '\">' + char;\r\n                        if (j === segment.text.length - 1 || position === end) {\r\n                            segmentContent += \"</span>\";\r\n                        }\r\n                        if (position < end) {\r\n                            activeSearchResultEnd = [start, end];\r\n                        }\r\n                    } else {\r\n                        segmentContent += char;\r\n                    }\r\n                }\r\n            }\r\n            // if (\r\n            //     this.props.textAlignmentById !== null\r\n            //     // && selectedTextId === TargetId\r\n            // ) {\r\n            //     let r = this.props.textAlignmentById.find(\r\n            //         (d) => d.TStart === segment.start\r\n            //     );\r\n            //     if (r) {\r\n            //         segmentHTML +=\r\n            //             \"<span id='alignment2_\" +\r\n            //             segment.start +\r\n            //             \"'>\" +\r\n            //             `<sup class=` +\r\n            //             styles.syncIdClass +\r\n            //             `>${r.id}</sup>` +\r\n            //             \"</span>\";\r\n            //     }\r\n            // }\r\n\r\n            segmentHTML +=\r\n                \"<span id=\" +\r\n                id +\r\n                \" key=\" +\r\n                id +\r\n                \" \" +\r\n                classAttribute +\r\n                \">\" +\r\n                segmentContent +\r\n                \"</span>\";\r\n        }\r\n\r\n        this._renderedSegments = segments;\r\n        segmentHTML += \"</p>\";\r\n\r\n        const html = {\r\n            __html: segmentHTML,\r\n        };\r\n        return html;\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps: Props, nextState: State) {\r\n        const renderedHtml = this.generateHtml(nextProps, nextState);\r\n        if (this.props.fontSize !== nextProps.fontSize) {\r\n            return true;\r\n        } else if (\r\n            this._renderedHtml &&\r\n            renderedHtml.__html === this._renderedHtml.__html\r\n        ) {\r\n            return false;\r\n        } else if (this._renderedHtml !== renderedHtml) {\r\n            this._renderedHtml = renderedHtml;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    componentDidUpdate() {\r\n        this.textAlignmentById = this.props.textAlignmentById;\r\n    }\r\n    render() {\r\n        let classes = [styles.text];\r\n        if (this.props.row === 0) {\r\n            classes.push(styles.textFirstRow);\r\n        }\r\n\r\n        // Generate HTML manually as it is much faster when\r\n        // creating large numbers of elements, such as these spans.\r\n        const html = this._renderedHtml\r\n            ? this._renderedHtml\r\n            : this.generateHtml(this.props, this.state);\r\n        if (!this._renderedHtml) {\r\n            this._renderedHtml = html;\r\n        }\r\n\r\n        return (\r\n            <div className={styles.textContainer}>\r\n                <div\r\n                    className={classnames(...classes)}\r\n                    dangerouslySetInnerHTML={html}\r\n                    onClick={(e) => this.selectedElement(e.target)}\r\n                    style={{\r\n                        fontSize: this.props.fontSize,\r\n                        fontFamily: \"var(--tibetan-fonts2)\",\r\n                    }}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\nexport default withTheme(Text2);\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"textDetail2\":\"TextDetail---textDetail2\",\"textContainer2\":\"TextDetail---textContainer2\"};","import React, { useEffect, useRef } from \"react\";\r\nimport TextDetailHeading from \"./TextDetailHeadingContainer\";\r\nimport SplitText from \"lib/SplitText\";\r\nimport Loader from \"react-loader\";\r\nimport lengthSplitter from \"lib/text_splitters/lengthSplitter\";\r\nimport styles from \"./TextDetail.css\";\r\nimport { Box, Divider, Slide } from \"@mui/material\";\r\nimport TableOfContent from \"./TableOfContent/TableOfContent\";\r\nimport utilStyles from \"css/util.css\";\r\nimport classnames from \"classnames\";\r\n\r\nimport imageStyle from \"components/MediaComponent/Image.css\";\r\nimport SplitTextComponent from \"./SplitText\";\r\n\r\nfunction TextDetail(props) {\r\n    const ref = useRef();\r\n    let text = {\r\n        name: \"\",\r\n    };\r\n    if (props.text) {\r\n        text = props.text;\r\n    }\r\n    useEffect(() => {\r\n        let element = ref.current;\r\n        element.addEventListener(\"mouseenter\", mouseEnter);\r\n        return () => {\r\n            element.removeEventListener(\"mouseenter\", mouseEnter);\r\n        };\r\n    }, []);\r\n\r\n    function mouseEnter() {\r\n        props.changeSelectedWindow(2);\r\n    }\r\n\r\n    let inlineControls = false;\r\n    let textComponent = null;\r\n    let splitText = null;\r\n    const selectedWindow = props.selectedWindow;\r\n    if (!props.annotatedText || !props.text || props.loading) {\r\n        textComponent = <div key={`key-${Math.random()}`} />;\r\n    } else {\r\n        let limitWidth = false;\r\n        let splitter;\r\n        if (props.paginated) {\r\n            splitter = positionSplitter(props.pageBreaks);\r\n        } else {\r\n            splitter = lengthSplitter(800, /^།[\\s]+(?!།[\\s]+)/, 2, 5);\r\n        }\r\n\r\n        let key = 12;\r\n        splitText = new SplitText(props.annotatedText, splitter);\r\n        inlineControls = true;\r\n        textComponent = (\r\n            <SplitTextComponent\r\n                splitText={splitText}\r\n                // annotations={this.props.annotations}\r\n                // activeAnnotations={this.props.activeAnnotations}\r\n                // activeAnnotation={this.props.activeAnnotation}\r\n                limitWidth={limitWidth}\r\n                // didSelectSegmentIds={props.didSelectSegmentIds}\r\n                selectedSegmentId={props.selectedSegmentId}\r\n                annotationPositions={props.annotationPositions}\r\n                selectedAnnotatedSegments={props?.selectedAnnotatedSegments}\r\n                // textListVisible={this.props.textListVisible}\r\n                // showImages={this.props.pageImagesVisible}\r\n                // imagesBaseUrl={this.props.imagesBaseUrl}\r\n                selectedWitness={props.selectedWitness}\r\n                key={key}\r\n                // selectedSearchResult={this.props.selectedSearchResult}\r\n                // searchValue={this.props.searchValue}\r\n                fontSize={props.textFontSize}\r\n                scrollToId={props.scrollToId}\r\n                syncIdOnClick={props.syncIdOnClick}\r\n                textAlignment={props.textAlignment}\r\n                textAlignmentById={props.textAlignmentById}\r\n                isPanelLinked={props.isPanelLinked}\r\n                changeScrollToId={props.changeScrollToId}\r\n                changeSyncIdOnClick={props.changeSyncIdOnClick}\r\n                selectedWindow={selectedWindow}\r\n                selectedSourceRange={props.selectedSourceRange}\r\n                selectedTargetRange={props.selectedTargetRange}\r\n                changeSelectedRange={props.changeSelectedRange}\r\n                searchResults={props.searchResults}\r\n                searchValue={props.searchValue}\r\n                selectedText={props.text}\r\n                syncIdOnSearch={props.syncIdOnSearch}\r\n                condition={props.condition}\r\n            ></SplitTextComponent>\r\n        );\r\n    }\r\n\r\n    let textComponents = [textComponent];\r\n    let thirdWindowHeight = imageStyle.ThirdWindowHeight;\r\n    let bodyHeight = \"calc(100% - \" + thirdWindowHeight + \")\";\r\n    // let condition = props.isPanelVisible;\r\n    return (\r\n        <Box\r\n            ref={ref}\r\n            className={styles.textDetail2}\r\n            sx={{\r\n                height: \"100%\",\r\n                flex: 1,\r\n                bgcolor: \"navbar.main\",\r\n                color: \"texts.main\",\r\n            }}\r\n        >\r\n            <TextDetailHeading />\r\n            <Divider />\r\n            <Loader loaded={!props.loading} />\r\n            <Box\r\n                style={{\r\n                    display: \"flex\",\r\n                    height: \"100%\",\r\n                    width: \"100%\",\r\n                    position: \"relative\",\r\n                }}\r\n            >\r\n                <Box\r\n                    style={{ flex: 1 }}\r\n                    className={classnames(\r\n                        styles.textContainer2,\r\n                        utilStyles.flex\r\n                    )}\r\n                >\r\n                    {!props.loading ? textComponents : <div></div>}\r\n                </Box>\r\n\r\n                <Slide\r\n                    direction=\"left\"\r\n                    in={props.showTableContent}\r\n                    container={ref.current}\r\n                    unmountOnExit\r\n                    mountOnEnter\r\n                >\r\n                    <Box\r\n                        sx={{\r\n                            position: \"absolute\",\r\n                            height: \"100%\",\r\n                            minWidth: \"50%\",\r\n                            right: 0,\r\n                        }}\r\n                    >\r\n                        <TableOfContent />\r\n                    </Box>\r\n                </Slide>\r\n            </Box>\r\n        </Box>\r\n    );\r\n}\r\n\r\nexport default TextDetail;\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport TextDetail from \"./TextDetail\";\r\nimport * as actions from \"actions\";\r\nimport * as reducers from \"reducers\";\r\nimport AnnotatedText from \"lib/AnnotatedText\";\r\nimport _ from \"lodash\";\r\nimport * as TextStore2 from \"state_helpers/TextStore2\";\r\nimport {\r\n    showPageImages,\r\n    getAnnotationsForWitnessId,\r\n    getActiveAnnotationsForWitnessId,\r\n    getActiveAnnotation,\r\n    getActiveTextAnnotation,\r\n    getBaseWitness,\r\n    getWorkingWitness,\r\n    getSelectedText,\r\n    annotationFromData,\r\n    getAnnotationData,\r\n    getUser,\r\n    getTextListVisible,\r\n    getSelectedTextWitnessId,\r\n    getTextWitnesses,\r\n    getWitness,\r\n    hasLoadedWitnessAnnotations,\r\n    getRemovedDefaultAnnotationsForWitnessId,\r\n    hasLoadedWitnessAppliedAnnotations,\r\n    getScrollPosition,\r\n    getSelectedSearchResult,\r\n    getTextFontSize,\r\n    isSecondWindowOpen,\r\n    getImageData,\r\n    getSelectedImage,\r\n    isImagePortrait,\r\n    isPanelVisible,\r\n    getSelectedTargetRange,\r\n    getSelectedSourceRange,\r\n    getSearchResults2,\r\n} from \"reducers\";\r\n\r\nconst DISMISS_CONTROLS_ON_CLICK = true;\r\n\r\nfunction getInsertionKey(annotation) {\r\n    return [annotation.start, annotation.length].join(\"-\");\r\n}\r\n\r\nlet _posAnnotatedText;\r\nlet _posAnnotations;\r\nlet _positions;\r\nlet _posVersion;\r\nconst getAnnotationPositions = (\r\n    annotatedText: AnnotatedText,\r\n    annotations: Annotation[]\r\n): { [string]: Annotation[] } => {\r\n    if (\r\n        annotatedText === _posAnnotatedText &&\r\n        annotations === _posAnnotations &&\r\n        annotatedText.version === _posVersion\r\n    ) {\r\n        return _positions;\r\n    }\r\n\r\n    let positions = {};\r\n    let activeInsertions = {};\r\n\r\n    for (let i = 0; i < annotations.length; i++) {\r\n        let annotation = annotations[i];\r\n        let [startPos, length] =\r\n            annotatedText.getPositionOfAnnotation(annotation);\r\n        if (startPos == null) {\r\n            continue;\r\n        }\r\n        if (length === 0) {\r\n            if (annotation.isInsertion) {\r\n                // group with any active insertions at the same position\r\n                const activeKey = getInsertionKey(annotation);\r\n                const activeInsertionPositions = activeInsertions[activeKey];\r\n                if (activeInsertionPositions) {\r\n                    activeInsertionPositions.map((pos) =>\r\n                        positions[pos].push(annotation)\r\n                    );\r\n                    continue;\r\n                }\r\n                startPos = INSERTION_KEY + startPos;\r\n            }\r\n            if (annotation.isDeletion && annotation.length > 0) {\r\n                // active deletion\r\n                startPos = DELETION_KEY + startPos;\r\n            }\r\n            if (annotation.type === ANNOTATION_TYPES.pageBreak) {\r\n                startPos = PAGE_BREAK_KEY + startPos;\r\n            }\r\n            if (annotation.type === ANNOTATION_TYPES.lineBreak) {\r\n                startPos = LINE_BREAK_KEY + startPos;\r\n            }\r\n            if (positions[startPos] === undefined) {\r\n                positions[startPos] = [];\r\n            }\r\n            if (positions[startPos].indexOf(annotation) === -1) {\r\n                positions[startPos].push(annotation);\r\n            }\r\n        } else {\r\n            let annotationPositions = [];\r\n            for (let j = startPos; j < startPos + length; j++) {\r\n                if (positions[j] === undefined) {\r\n                    positions[j] = [];\r\n                }\r\n                if (positions[j].indexOf(annotation) === -1) {\r\n                    positions[j].push(annotation);\r\n                }\r\n                annotationPositions.push(j);\r\n            }\r\n            // Store the positions this annotation is displayed at.\r\n            // This can then be used later to group with inactive insertions\r\n            if (annotation.isInsertion) {\r\n                const key = getInsertionKey(annotation);\r\n                activeInsertions[key] = annotationPositions;\r\n            }\r\n        }\r\n    }\r\n\r\n    _posAnnotatedText = annotatedText;\r\n    _posAnnotations = annotations;\r\n    _positions = positions;\r\n    _posVersion = annotatedText.version;\r\n    return positions;\r\n};\r\n\r\nconst mapStateToProps = (state: AppState): {} => {\r\n    let selectedWitness = {};\r\n    let annotatedText = null;\r\n    let workingWitness;\r\n    let textFontSize = reducers.getTextFontSize2(state);\r\n    let selectedText = reducers.getSelectedText2(state);\r\n    let annotationPositions = {};\r\n    let annotations = [];\r\n    if (selectedText) {\r\n        workingWitness =\r\n            reducers.getWorkingWitness2(state, selectedText.id) || {};\r\n        let selectedWitnessId = reducers.getSelectedTextWitnessId2(\r\n            state,\r\n            selectedText.id\r\n        );\r\n        if (selectedWitnessId) {\r\n            selectedWitness = reducers.getWitness2(state, selectedWitnessId);\r\n        }\r\n        if (_.isEmpty(selectedWitness) && !_.isEmpty(workingWitness));\r\n        {\r\n            selectedWitness = workingWitness;\r\n        }\r\n    }\r\n\r\n    annotatedText = TextStore2.getWitnessText(state, selectedWitness?.id);\r\n\r\n    const loading = state.data2.loadingWitnesses;\r\n\r\n    if (annotatedText) {\r\n        annotationPositions = getAnnotationPositions(\r\n            annotatedText,\r\n            (Object.values(annotations): any)\r\n        );\r\n    }\r\n    const isPanelLinked = reducers.isPanelLinked(state);\r\n    const scrollToId = reducers.getScrollToId(state);\r\n    const syncIdOnClick = reducers.getSyncIdOnClick(state);\r\n    const textAlignment = reducers.getTextAlignment(state);\r\n    const selectedWindow = reducers.getSelectedWindow(state);\r\n    const searchValue = reducers.getSearchValue2(state);\r\n    // let condition =\r\n    //     textAlignment?.source?.witness === selectedWitness?.id &&\r\n    //     isSecondWindowOpen &&\r\n    //     textAlignment?.target?.witness === selectedWitness2?.id &&\r\n    //     isPanelLinked;\r\n    const condition = reducers.getConditionForAlignment(state);\r\n\r\n    return {\r\n        text: selectedText,\r\n        textFontSize,\r\n        annotatedText,\r\n        selectedWitness,\r\n        loading,\r\n        annotationPositions,\r\n        isSecondWindowOpen: isSecondWindowOpen(state),\r\n        imageData: getImageData(state),\r\n        selectedImage: getSelectedImage(state),\r\n        isImagePortrait: isImagePortrait(state),\r\n        isPanelVisible: isPanelVisible(state),\r\n        scrollToId,\r\n        syncIdOnClick,\r\n        textAlignment,\r\n        textAlignmentById: reducers.getTextAlignmentById(state),\r\n        selectedWindow,\r\n        selectedSourceRange: getSelectedSourceRange(state),\r\n        selectedTargetRange: getSelectedTargetRange(state),\r\n        showTableContent: reducers.getShowTableContent2(state),\r\n        searchResults: getSearchResults2(state, searchValue),\r\n        searchValue,\r\n        syncIdOnSearch: reducers.getSyncIdOnSearch2(state),\r\n        condition,\r\n    };\r\n};\r\n\r\nconst mergeProps = (stateProps, dispatchProps, ownProps) => {\r\n    const { annotatedText, annotationPositions } = stateProps;\r\n    const { dispatch } = dispatchProps;\r\n\r\n    const isDeletion = (id) => {\r\n        return id.indexOf(\"ds2_\") !== -1;\r\n    };\r\n    const isInsertion = (id) => {\r\n        return id.indexOf(\"i2_\") !== -1;\r\n    };\r\n    const isPageBreak = (id) => {\r\n        return id.indexOf(\"p2_\") !== -1;\r\n    };\r\n\r\n    const isLineBreak = (id) => {\r\n        return id.indexOf(\"l2_\") !== -1;\r\n    };\r\n\r\n    const idFromSegmentId = (id) => {\r\n        let start = 0;\r\n        if (isInsertion(id)) {\r\n            start = id.substr(2);\r\n        } else if (isDeletion(id)) {\r\n            start = id.substr(3);\r\n        } else {\r\n            start = id.substr(2);\r\n        }\r\n\r\n        return start;\r\n    };\r\n\r\n    const didSelectSegmentPosition = (segmentPosition, start, length) => {\r\n        let segmentAnnotations = annotationPositions[segmentPosition];\r\n        let segmentVariants = [];\r\n        let segmentPageBreaks = [];\r\n        let segmentLineBreaks = [];\r\n        if (segmentAnnotations) {\r\n            segmentVariants = segmentAnnotations.filter(\r\n                (annotation: Annotation) =>\r\n                    annotation.type === ANNOTATION_TYPES.variant\r\n            );\r\n            segmentPageBreaks = segmentAnnotations.filter(\r\n                (annotation: Annotation) =>\r\n                    annotation.type === ANNOTATION_TYPES.pageBreak\r\n            );\r\n            segmentLineBreaks = segmentAnnotations.filter(\r\n                (annotation: Annotation) =>\r\n                    annotation.type === ANNOTATION_TYPES.lineBreak\r\n            );\r\n        }\r\n        let activeAnnotations = _.intersectionWith(\r\n            segmentVariants.concat(segmentPageBreaks, segmentLineBreaks),\r\n            annotatedText.annotations,\r\n            (a, b) => a.toString() == b.toString()\r\n        );\r\n        let activeAnnotation = null;\r\n        if (activeAnnotations.length > 0) {\r\n            // get any active annotations\r\n            activeAnnotation = activeAnnotations[0];\r\n        } else if (segmentVariants && segmentVariants.length > 0) {\r\n            // get base text annotation for longest annotation highlighted in text\r\n            let longestAvailable = getLongestAnnotation(segmentVariants);\r\n            let [start, textLength] =\r\n                annotatedText.getPositionOfAnnotation(longestAvailable);\r\n            if (longestAvailable && longestAvailable.isInsertion) {\r\n                textLength = 0;\r\n            }\r\n            activeAnnotation = annotatedText.getBaseAnnotation(\r\n                start,\r\n                textLength\r\n            );\r\n        } else {\r\n            // get base annotation of just the segment\r\n            activeAnnotation = annotatedText.getBaseAnnotation(start, length);\r\n        }\r\n\r\n        // dispatch(actions.changedActiveTextAnnotation(activeAnnotation));\r\n    };\r\n\r\n    return {\r\n        ...ownProps,\r\n        ...stateProps,\r\n        onChangedFontSize: (fontSize: number) => {\r\n            dispatch(actions.changedTextFontSize(fontSize));\r\n        },\r\n\r\n        didSelectSegmentIds: (segmentIds) => {\r\n            if (segmentIds.length === 0) {\r\n                return;\r\n            }\r\n            let segmentAnnotations = [];\r\n            let segments = [];\r\n            for (let segmentId of segmentIds) {\r\n                if (isDeletion(segmentId) || isInsertion(segmentId)) {\r\n                    continue;\r\n                }\r\n\r\n                let segmentPosition = idFromSegmentId(segmentId);\r\n                let textSegment =\r\n                    annotatedText.segmentedText.segmentAtPosition(\r\n                        segmentPosition\r\n                    );\r\n                segments.push(textSegment);\r\n                const annotations = annotationPositions[textSegment.start];\r\n                if (annotations) {\r\n                    segmentAnnotations = segmentAnnotations.concat(annotations);\r\n                }\r\n            }\r\n            segmentAnnotations = _.uniqWith(\r\n                segmentAnnotations,\r\n                (a, b) => a.toString() == b.toString()\r\n            );\r\n\r\n            let activeAnnotations = _.intersectionWith(\r\n                segmentAnnotations,\r\n                annotatedText.annotations,\r\n                (a, b) => a.toString() == b.toString()\r\n            );\r\n\r\n            const range = getSegmentsRange(\r\n                segments,\r\n                activeAnnotations,\r\n                segmentAnnotations,\r\n                stateProps.annotatedText\r\n            );\r\n            if (!range) {\r\n                console.warn(\r\n                    \"No range for selected segment ids: %o\",\r\n                    segmentIds\r\n                );\r\n                return;\r\n            }\r\n            const baseAnnotation = annotatedText.getBaseAnnotation(\r\n                range.start,\r\n                range.length\r\n            );\r\n            let activeAnnotation = null;\r\n            if (range.annotation) {\r\n                activeAnnotation = range.annotation;\r\n            } else if (activeAnnotations.length > 0) {\r\n                const content = annotatedText.segmentedText\r\n                    .segmentsInRange(range.start, range.length)\r\n                    .reduce((content, segment) => content + segment.text, \"\");\r\n                // TODO: test this when editing non-working edition.\r\n                // Check if getTextWorkingWitness works as required\r\n                if (!stateProps.selectedWitness) {\r\n                    console.log(\r\n                        \"no stateProps.selectedWitness: %o\",\r\n                        stateProps.selectedWitness\r\n                    );\r\n                }\r\n                activeAnnotation = new Annotation(\r\n                    WORKING_VERSION_ANNOTATION_ID,\r\n                    getTextWorkingWitness(stateProps.text),\r\n                    baseAnnotation.start,\r\n                    baseAnnotation.length,\r\n                    content,\r\n                    ANNOTATION_TYPES.variant,\r\n                    stateProps.selectedWitness,\r\n                    stateProps.user\r\n                );\r\n            } else {\r\n                activeAnnotation = baseAnnotation;\r\n            }\r\n            // dispatch(changedActiveTextAnnotation(activeAnnotation));\r\n        },\r\n        changeScrollToId: (payload) =>\r\n            dispatch(actions.changeScrollToId(payload)),\r\n        changeSyncIdOnClick: (payload) => {\r\n            dispatch(actions.changeSyncIdOnClick(payload));\r\n        },\r\n        changeSelectedWindow: (payload) => {\r\n            dispatch(actions.changeSelectedWindow(payload));\r\n        },\r\n        changeSelectedRange: (payload) => {\r\n            dispatch(actions.changeSelectedRange(payload));\r\n        },\r\n        changeShowTableContent: (payload) => {\r\n            dispatch(actions.showTableContent2(payload));\r\n        },\r\n        selectedSegmentId: (segmentId) => {\r\n            let start = idFromSegmentId(segmentId);\r\n            let positionKey = start;\r\n            if (isInsertion(segmentId)) {\r\n                positionKey = INSERTION_KEY + start;\r\n            } else if (isDeletion(segmentId)) {\r\n                positionKey = DELETION_KEY + start;\r\n            } else if (isPageBreak(segmentId)) {\r\n                positionKey = PAGE_BREAK_KEY + start;\r\n            } else if (isLineBreak(segmentId)) {\r\n                positionKey = LINE_BREAK_KEY + start;\r\n            }\r\n\r\n            let segmentAnnotations = annotationPositions[positionKey];\r\n            if (DISMISS_CONTROLS_ON_CLICK && stateProps.activeAnnotation) {\r\n                const activeAnnotation = stateProps.activeAnnotation;\r\n                if (activeAnnotation) {\r\n                    const dismissTextAnnotation =\r\n                        actions.changedActiveTextAnnotation(null);\r\n                    dispatch(dismissTextAnnotation);\r\n                }\r\n            }\r\n            //  else {\r\n            //     if (\r\n            //         isInsertion(segmentId) ||\r\n            //         isDeletion(segmentId) ||\r\n            //         isPageBreak(segmentId) ||\r\n            //         isLineBreak(segmentId)\r\n            //     ) {\r\n            //         const length = 0;\r\n            //         didSelectSegmentPosition(positionKey, start, length);\r\n            //     } else {\r\n            //         let segmentPosition = Number(idFromSegmentId(segmentId));\r\n            //         let textSegment = annotatedText.segmentedText.segmentAtPosition(\r\n            //             segmentPosition\r\n            //         );\r\n            //         if (textSegment) {\r\n            //             didSelectSegmentPosition(\r\n            //                 textSegment.start,\r\n            //                 textSegment.start,\r\n            //                 textSegment.length\r\n            //             );\r\n            //         }\r\n            //     }\r\n            // }\r\n        },\r\n    };\r\n};\r\n\r\nconst TextDetailContainer = connect(\r\n    mapStateToProps,\r\n    null,\r\n    mergeProps\r\n)(TextDetail);\r\n\r\nexport default React.memo(TextDetailContainer);\r\n","import React, { useState, useCallback, useRef, useEffect } from \"react\";\r\nimport styles from \"./textDetailHeading.css\";\r\nimport SelectVersion from \"./SelectVersion\";\r\nimport Slider from \"../UI/Slider\";\r\nimport TextListContainer from \"./TextListContainer\";\r\nimport OptionsIcon from \"images/options.svg\";\r\nimport Settings from \"./HeaderMenu/Settings\";\r\nimport Search from \"./HeaderMenu/Search\";\r\nimport TableOfContent from \"./HeaderMenu/TableOfContent\";\r\nimport _ from \"lodash\";\r\nimport CloseIcon from \"@mui/icons-material/Close\";\r\n\r\nimport {\r\n    Stack,\r\n    Box,\r\n    TextField,\r\n    Button,\r\n    Collapse,\r\n    Divider,\r\n    ButtonGroup,\r\n    ListItem,\r\n    List,\r\n    IconButton,\r\n} from \"@mui/material\";\r\nimport Refresh from \"./HeaderMenu/Refresh\";\r\n\r\nimport SearchList from \"./HeaderMenu/SearchList\";\r\ntype HeaderProps = {\r\n    user: {},\r\n    textFontSize: Number,\r\n    onChangedFontSize: () => void,\r\n    searchResults: [],\r\n};\r\n\r\nfunction TextDetailHeading(props: HeaderProps) {\r\n    const [findvalue, setfindvalue] = useState(\"\");\r\n    let [showFind, setShowFind] = useState(false);\r\n    let [visible, setVisible] = useState(false);\r\n\r\n    const inputRef = useRef();\r\n    const headingRef = useRef();\r\n    const handleListItemClick = (id) => {\r\n        props.changeSelectSyncId(id);\r\n    };\r\n    const debouncedSearch = React.useRef(\r\n        _.debounce((s) => {\r\n            props.searchChanged(s);\r\n        }, 1000)\r\n    ).current;\r\n    const handleSearch = useCallback(\r\n        (e) => {\r\n            e.preventDefault();\r\n            debouncedSearch(findvalue);\r\n            setVisible(true);\r\n        },\r\n        [findvalue]\r\n    );\r\n\r\n    const handleWindowSearch = useCallback(() => {\r\n        setShowFind(!showFind);\r\n    }, [showFind]);\r\n\r\n    useEffect(() => {\r\n        if (showFind === true) {\r\n            inputRef.current.focus();\r\n        }\r\n\r\n        if (showFind === false) debouncedSearch(null);\r\n    }, [showFind]);\r\n\r\n    const closeSearchItemBox = () => {\r\n        setVisible(false);\r\n        debouncedSearch(null);\r\n        setfindvalue(\"\");\r\n    };\r\n\r\n    let condition =\r\n        _.isObject(props.searchResults) &&\r\n        props.searchResults.hasOwnProperty(props.selectedText.id);\r\n    let results = condition\r\n        ? props.searchResults[props.selectedText.id].results\r\n        : [];\r\n    return (\r\n        <Stack\r\n            direction=\"column\"\r\n            ref={headingRef}\r\n            spacing={1}\r\n            sx={{\r\n                paddingInline: { md: 2, xs: 0 },\r\n                paddingBlock: { md: 1, xs: 0 },\r\n                borderTop: { md: 0, xs: \"1px solid gray\" },\r\n                bgcolor: \"heading.main\",\r\n                color: \"text.primary\",\r\n            }}\r\n        >\r\n            {\" \"}\r\n            <Stack direction=\"row\" spacing={1} justifyContent=\"space-between\">\r\n                <Box\r\n                    sx={{\r\n                        display: \"flex\",\r\n                        gap: { md: 2, sx: 0 },\r\n                        flexDirection: { md: \"row\", xs: \"column\" },\r\n                    }}\r\n                >\r\n                    <TextListContainer />\r\n                    <SelectVersion\r\n                        witnesses={props.witnesses}\r\n                        activeWitness={props.selectedWitness}\r\n                        onSelectedWitness={props.onSelectedWitness}\r\n                        user={props.user}\r\n                    />\r\n                </Box>\r\n\r\n                <ButtonGroup\r\n                    size=\"small\"\r\n                    aria-label=\"small button group\"\r\n                    sx={{\r\n                        position: \"relative\",\r\n                        display: \"flex\",\r\n                        alignItems: \"center\",\r\n                        justifyContent: \"center\",\r\n                        height: \"fit-content\",\r\n                        width: \"fit-content\",\r\n                        border: (theme) => `1px solid ${theme.palette.divider}`,\r\n                        borderRadius: 1,\r\n                        bgcolor: \"background.paper\",\r\n                        color: \"text.secondary\",\r\n                        \"& svg\": {\r\n                            m: 1.5,\r\n                        },\r\n                        \"& hr\": {\r\n                            mx: 0.5,\r\n                        },\r\n                    }}\r\n                    className={styles.button_group_menu}\r\n                >\r\n                    <Refresh isSecondWindowOpen={props.isSecondWindowOpen} />\r\n\r\n                    <Search handleWindowSearch={handleWindowSearch} />\r\n                    <Settings\r\n                        textFontSize={props.textFontSize}\r\n                        onChangedFontSize={props.onChangedFontSize}\r\n                        onExport={props.onExport}\r\n                        isPanelLinked={props.isPanelLinked}\r\n                    />\r\n                    <TableOfContent\r\n                        changeShowTableContent={props.changeShowTableContent}\r\n                        showTableContent={props.showTableContent}\r\n                    />\r\n                </ButtonGroup>\r\n            </Stack>\r\n            <Collapse in={showFind} mountOnEnter unmountOnExit>\r\n                <form onSubmit={handleSearch}>\r\n                    <Stack direction=\"row\" spacing={2} position=\"relative\">\r\n                        <TextField\r\n                            hiddenLabel\r\n                            id=\"filled-hidden-label-small\"\r\n                            inputProps={{\r\n                                style: {\r\n                                    height: 25,\r\n                                    padding: \"0 14px\",\r\n                                },\r\n                            }}\r\n                            style={{ height: 25, flex: 1 }}\r\n                            fullWidth\r\n                            inputRef={inputRef}\r\n                            value={findvalue}\r\n                            onChange={(e) => setfindvalue(e.target.value)}\r\n                        />\r\n                        <Button\r\n                            variant=\"outlined\"\r\n                            size=\"small\"\r\n                            onClick={handleSearch}\r\n                            style={{ height: 25 }}\r\n                        >\r\n                            Search\r\n                        </Button>\r\n                        {props.searchResults && visible && (\r\n                            <Box\r\n                                sx={{\r\n                                    position: \"absolute\",\r\n                                    top: 35,\r\n                                    right: 0,\r\n                                    zIndex: 1,\r\n                                    bgcolor: \"heading.main\",\r\n                                    width: 350,\r\n                                    height: 350,\r\n                                    boxShadow: 3,\r\n                                    overflowX: \"hidden\",\r\n                                    boxShadow: 3,\r\n                                }}\r\n                            >\r\n                                {results.length === 0 && (\r\n                                    <p>no such word present</p>\r\n                                )}\r\n                                {condition && results.length > 0 && (\r\n                                    <SearchList\r\n                                        handleListItemClick={\r\n                                            handleListItemClick\r\n                                        }\r\n                                        searchValue={props.searchValue}\r\n                                        results={results}\r\n                                        selectedText={props.selectedText}\r\n                                    />\r\n                                )}\r\n                                <IconButton\r\n                                    aria-label=\"closeButton\"\r\n                                    onClick={closeSearchItemBox}\r\n                                    size=\"small\"\r\n                                    sx={{\r\n                                        right: 15,\r\n                                        top: 0,\r\n                                        position: \"absolute\",\r\n                                    }}\r\n                                >\r\n                                    <CloseIcon fontSize=\"inherit\" />\r\n                                </IconButton>\r\n                            </Box>\r\n                        )}\r\n                    </Stack>\r\n                </form>\r\n            </Collapse>\r\n        </Stack>\r\n    );\r\n}\r\n\r\nexport default TextDetailHeading;\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport TextDetailHeading from \"./TextDetailHeading\";\r\nimport * as actions from \"actions\";\r\nimport * as reducers from \"reducers\";\r\nimport type { AppState } from \"reducers\";\r\nimport {\r\n    getTextListVisible,\r\n    getAccountOverlayVisible,\r\n    getShowTableContent2,\r\n} from \"reducers\";\r\n\r\nconst mapStateToProps = (state: AppState): {} => {\r\n    const user = reducers.getUser(state);\r\n    const selectedText = reducers.getSelectedText2(state);\r\n    let witnesses = [];\r\n    let exportingWitness = false;\r\n    let selectedWitness;\r\n    if (selectedText) {\r\n        witnesses = reducers.getTextWitnesses2(state, selectedText.id);\r\n        const selectedWitnessId = reducers.getSelectedTextWitnessId2(\r\n            state,\r\n            selectedText.id\r\n        );\r\n        if (selectedWitnessId) {\r\n            selectedWitness = reducers.getWitness2(state, selectedWitnessId);\r\n            // exportingWitness = reducers.getExportingWitness(\r\n            //     state,\r\n            //     selectedWitnessId\r\n            // );\r\n        } else {\r\n            selectedWitness = reducers.getWorkingWitness2(\r\n                state,\r\n                selectedText.id\r\n            );\r\n        }\r\n    }\r\n    let textFontSize = reducers.getTextFontSize2(state);\r\n    let showTableContent = getShowTableContent2(state);\r\n    let searchValue = reducers.getSearchValue2(state);\r\n    return {\r\n        witnesses,\r\n        selectedText,\r\n        selectedWitness,\r\n        textListIsVisible: getTextListVisible(state),\r\n        accountOverlayVisible: getAccountOverlayVisible(state),\r\n        textFontSize,\r\n        user,\r\n        searchValue,\r\n        showTableContent,\r\n        searchResults: reducers.getSearchResults2(state, searchValue),\r\n    };\r\n};\r\n\r\nconst mergeProps = (stateProps, dispatchProps, ownProps) => {\r\n    const navigationButtonClicked = () => {\r\n        dispatchProps.dispatch(\r\n            actions.changedTextListVisible(!stateProps.textListIsVisible)\r\n        );\r\n    };\r\n\r\n    const { dispatch } = dispatchProps;\r\n    const { selectedText } = stateProps;\r\n\r\n    return {\r\n        ...ownProps,\r\n        ...stateProps,\r\n        navigationButtonClicked,\r\n        onSelectedWitness: (witness: Witness) => {\r\n            dispatch(\r\n                actions.selectedTextWitness2(selectedText?.id, witness?.id)\r\n            );\r\n        },\r\n        onChangedFontSize: (fontSize: number) => {\r\n            dispatch(actions.changedTextFontSize2(fontSize));\r\n        },\r\n        changeShowTableContent: (payload) => {\r\n            dispatch(actions.showTableContent2(payload));\r\n        },\r\n        searchChanged: (searchTerm: string) => {\r\n            dispatch(actions.changedSearchValue2(searchTerm));\r\n        },\r\n        changeSelectSyncId: (payload) => {\r\n            dispatch(actions.changeSyncIdOnSearch2(payload));\r\n        },\r\n    };\r\n};\r\n\r\nconst TextDetailHeadingContainer = connect(\r\n    mapStateToProps,\r\n    null,\r\n    mergeProps\r\n)(TextDetailHeading);\r\n\r\nexport default TextDetailHeadingContainer;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"textlist\":\"TextList---textlist\",\"open\":\"TextList---open\"};","import React, { useState, useRef, useEffect } from \"react\";\r\nimport {\r\n    List,\r\n    AutoSizer,\r\n    CellMeasurer,\r\n    CellMeasurerCache,\r\n} from \"react-virtualized\";\r\nimport classname from \"classnames\";\r\nimport styles from \"./TextList.css\";\r\nimport addShay from \"lib/addTibetanShay\";\r\n\r\nimport {\r\n    TextField,\r\n    ClickAwayListener,\r\n    Box,\r\n    Typography,\r\n    Button,\r\n    Grow,\r\n} from \"@mui/material\";\r\nimport { useMemo } from \"react\";\r\nfunction TextList(props) {\r\n    const temptext = useRef(props.texts);\r\n    const [textslist, setTextList] = useState(temptext.current);\r\n    const [filterValue, setFilterValue] = useState(null);\r\n\r\n    const onSelectedText = props.onSelectedText;\r\n    const selectedText = props.selectedText;\r\n    const [isOpen, setIsOpen] = useState(false);\r\n    let selected = useMemo(() => {\r\n        return selectedText ? selectedText.name : textslist[0].name;\r\n    }, [selectedText, textslist]);\r\n    useEffect(() => {\r\n        let temp = [];\r\n        if (filterValue === \"\") {\r\n            setTextList([...temptext.current]);\r\n        }\r\n        if (filterValue !== null && filterValue !== \"\") {\r\n            temp = temptext.current.filter((val) => {\r\n                return val.name.includes(filterValue);\r\n            });\r\n            setTextList([...temp]);\r\n        }\r\n    }, [filterValue]);\r\n\r\n    const cache = useRef(\r\n        new CellMeasurerCache({\r\n            fixedHeight: true,\r\n            defaultHeight: 40,\r\n        })\r\n    );\r\n\r\n    let classes = [styles.textlist];\r\n\r\n    const handleClick = () => {\r\n        setIsOpen((prev) => !prev);\r\n        if (isOpen === false) classes.push(styles.open);\r\n    };\r\n    const handleChange = (e) => {\r\n        let value = e.target.value;\r\n        setFilterValue(value);\r\n    };\r\n    const rowRenderer = React.useCallback(\r\n        ({ key, index, style, parent }) => {\r\n            let data = textslist[index];\r\n            return (\r\n                <CellMeasurer\r\n                    key={`optionvalues-${key}`}\r\n                    cache={cache.current}\r\n                    parent={parent}\r\n                    columnIndex={0}\r\n                    rowIndex={index}\r\n                >\r\n                    <div\r\n                        style={style}\r\n                        onClick={() => {\r\n                            setIsOpen(false);\r\n                            onSelectedText(data);\r\n                        }}\r\n                    >\r\n                        <Box\r\n                            sx={{\r\n                                overflow: \"hidden\",\r\n                                textOverflow: \"ellipsis\",\r\n                                width: \"13rem\",\r\n                                paddingLeft: 2,\r\n                                fontSize: {\r\n                                    lg: 12,\r\n                                    md: 11,\r\n                                    sm: 10,\r\n                                    xs: 10,\r\n                                },\r\n                                color: \"text.primary\",\r\n                            }}\r\n                            component=\"div\"\r\n                        >\r\n                            <Typography noWrap={true}>\r\n                                {addShay(data.name)}\r\n                            </Typography>\r\n                        </Box>\r\n                    </div>\r\n                </CellMeasurer>\r\n            );\r\n        },\r\n        [textslist]\r\n    );\r\n    return (\r\n        <ClickAwayListener onClickAway={() => setIsOpen(false)}>\r\n            <div style={{ position: \"relative\", marginLeft: 10 }}>\r\n                <Button\r\n                    onClick={handleClick}\r\n                    component=\"div\"\r\n                    variant=\"outlined\"\r\n                    sx={{\r\n                        overflow: \"hidden\",\r\n                        textOverflow: \"ellipsis\",\r\n                        width: \"10rem\",\r\n                        height: \"100%\",\r\n                        color: \"text.primary\",\r\n                    }}\r\n                >\r\n                    <Typography noWrap={true}>{selected}</Typography>\r\n                </Button>\r\n                <Grow in={isOpen}>\r\n                    <Box\r\n                        className={classname(classes)}\r\n                        sx={{\r\n                            position: \"absolute\",\r\n                            bgcolor: \"heading.main\",\r\n                            zIndex: 1,\r\n                        }}\r\n                    >\r\n                        <TextField\r\n                            onChange={handleChange}\r\n                            id=\"standard-basic\"\r\n                            label=\"filter\"\r\n                            variant=\"standard\"\r\n                            style={{ width: \"100%\" }}\r\n                        />\r\n                        <AutoSizer>\r\n                            {({ width, height }) => (\r\n                                <List\r\n                                    width={width}\r\n                                    height={height}\r\n                                    rowHeight={40}\r\n                                    deferredMeasurementCache={cache.current}\r\n                                    rowCount={textslist.length}\r\n                                    rowRenderer={rowRenderer}\r\n                                />\r\n                            )}\r\n                        </AutoSizer>\r\n                    </Box>\r\n                </Grow>\r\n            </div>\r\n        </ClickAwayListener>\r\n    );\r\n}\r\n\r\nexport default React.memo(TextList);\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport TextList from \"./TextList\";\r\nimport * as actions from \"actions\";\r\nimport { getSelectedText2 } from \"reducers\";\r\nimport type { AppState } from \"reducers\";\r\nimport * as api from \"api\";\r\nimport * as reducers from \"reducers\";\r\nimport { batchActions } from \"redux-batched-actions\";\r\n\r\nconst mapStateToProps = (state: AppState) => {\r\n    const searchValue = reducers.getSearchValue(state);\r\n    const searchResults = reducers.getSearchResults(state, searchValue);\r\n    const selectedSearchResult = reducers.getSelectedSearchResult(state);\r\n    // TODO: display search results or spinner depending on when anything\r\n    // returned\r\n\r\n    let searching = false;\r\n    let texts = state.data.texts;\r\n    if (searchValue.length > 0) {\r\n        if (searchResults === null) {\r\n            searching = true;\r\n            texts = [];\r\n        } else {\r\n            texts = texts.filter((text) =>\r\n                searchResults.hasOwnProperty(text.id)\r\n            );\r\n        }\r\n    }\r\n\r\n    return {\r\n        texts: texts,\r\n        selectedText: getSelectedText2(state),\r\n        searchTerm: searchValue,\r\n        searchResults,\r\n        selectedSearchResult,\r\n        searching,\r\n    };\r\n};\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        onSelectedText: (text: api.TextData) => {\r\n            dispatch(actions.selectedText2(text));\r\n        },\r\n    };\r\n};\r\n\r\nconst TextListContainer = connect(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(TextList);\r\n\r\nexport default TextListContainer;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"button_group_menu\":\"textDetailHeading---button_group_menu\"};","// @flow\r\nimport * as React from \"react\";\r\nimport GraphemeSplitter from \"grapheme-splitter\";\r\nimport reactStringReplace from \"react-string-replace\";\r\n\r\ntype Props = {\r\n    string: string,\r\n    highlightClass: string,\r\n    stringClass?: string,\r\n    searchTerm?: string\r\n};\r\n\r\nexport default class HighlightedString extends React.Component<Props> {\r\n    constructor(props: Props) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        const string = this.props.string;\r\n        let nameHtml = string;\r\n        let stringClass = this.props.stringClass || \"\";\r\n        if (this.props.searchTerm) {\r\n            const searchTerm = this.props.searchTerm;\r\n            const splitter = new GraphemeSplitter();\r\n            const graphemes = splitter.splitGraphemes(string);\r\n            const start = string.indexOf(searchTerm);\r\n            const end = start + searchTerm.length;\r\n            let position = 0;\r\n            let foundGraphemes = \"\";\r\n            if (start > -1) {\r\n                for (let i = 0; i < graphemes.length; i++) {\r\n                    let grapheme = graphemes[i];\r\n                    if (position >= start && position < end) {\r\n                        foundGraphemes += grapheme;\r\n                    }\r\n                    position += grapheme.length;\r\n                }\r\n            }\r\n            if (foundGraphemes.length > 0) {\r\n                nameHtml = reactStringReplace(\r\n                    string,\r\n                    foundGraphemes,\r\n                    (match, i) => (\r\n                        <span className={this.props.highlightClass} key={`highlight-${i}`}>\r\n                            {match}\r\n                        </span>\r\n                    )\r\n                );\r\n            }\r\n        }\r\n        return <span className={stringClass}>{nameHtml}</span>;\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"LoadMore---container\"};","// @flow\r\nimport React from \"react\";\r\nimport { FormattedMessage, injectIntl } from \"react-intl\";\r\nimport styles from \"./LoadMore.css\";\r\n\r\ntype Props = {\r\n    loading?: boolean\r\n};\r\n\r\nexport default function LoadMore(props: Props) {\r\n    let content;\r\n    if (props.loading) {\r\n        content = (\r\n            <span>\r\n                <FormattedMessage id=\"leftbar.loading\" />\r\n            </span>\r\n        );\r\n    } else {\r\n        content = (\r\n            <span>\r\n                <FormattedMessage id=\"leftbar.loadMore\" />\r\n            </span>\r\n        );\r\n    }\r\n    return <div className={styles.container}>{content}</div>;\r\n}\r\n","// @flow\r\nimport * as React from \"react\";\r\nimport styles from \"./TextList.css\";\r\n\r\ntype Props = {\r\n    count: number,\r\n    extra: boolean\r\n};\r\n\r\nexport default class ResultCount extends React.Component<Props> {\r\n    constructor(props: Props) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        let countDisplay = this.props.count;\r\n        if (this.props.extra) countDisplay += \"+\";\r\n        return <span className={styles.searchTotal}>{countDisplay}</span>;\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"textList\":\"TextList---textList\",\"textListRow\":\"TextList---textListRow\",\"selectedRow\":\"TextList---selectedRow\",\"textNameRow\":\"TextList---textNameRow\",\"textName\":\"TextList---textName\",\"highlight\":\"TextList---highlight\",\"searchResults\":\"TextList---searchResults\",\"searchResult\":\"TextList---searchResult\",\"selectedSearchResult\":\"TextList---selectedSearchResult\",\"searchTotal\":\"TextList---searchTotal\",\"textListLoader\":\"TextList---textListLoader\",\"searching\":\"TextList---searching\",\"loadMore\":\"TextList---loadMore\"};","// @flow\r\nimport React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport { AutoSizer } from \"react-virtualized/dist/es/AutoSizer\";\r\nimport {\r\n    CellMeasurer,\r\n    CellMeasurerCache,\r\n} from \"react-virtualized/dist/es/CellMeasurer\";\r\nimport \"react-virtualized/styles.css\"; // only needs to be imported once\r\nimport { List } from \"react-virtualized/dist/es/List\";\r\nimport * as api from \"api\";\r\nimport addTibetanShay from \"lib/addTibetanShay\";\r\nimport styles from \"./TextList.css\";\r\nimport Loader from \"react-loader\";\r\nimport HighlightedString from \"./HighlightedString\";\r\nimport ResultCount from \"./ResultCount\";\r\nimport LoadMore from \"./LoadMore\";\r\n\r\ntype Props = {\r\n    selectedText: api.TextData,\r\n    texts: api.TextData[],\r\n    onSelectedText: (text: api.TextData) => void,\r\n    onSelectedSearchResult: (\r\n        text: api.TextData,\r\n        start: number,\r\n        length: number,\r\n        selectedText: api.TextData\r\n    ) => void,\r\n    onSearchText: (text: api.TextData, searchTerm: string) => void,\r\n    searchTerm: string,\r\n    searchResults: { [number]: api.TextSearchResultData },\r\n    selectedSearchResult: null | {\r\n        textId: number,\r\n        start: number,\r\n        length: number,\r\n    },\r\n    searching: boolean,\r\n};\r\n\r\nconst DEFAULT_ROW_HEIGHT = 60;\r\n\r\nclass TextList extends React.Component<Props> {\r\n    list: List | null;\r\n    cache: CellMeasurerCache;\r\n    rowRenderer: (params: {\r\n        key: string,\r\n        index: number,\r\n        parent: {},\r\n        style: {},\r\n    }) => React.Element<CellMeasurer>;\r\n\r\n    constructor(props: Props) {\r\n        super(props);\r\n        this.cache = new CellMeasurerCache({\r\n            fixedWidth: true,\r\n            defaultHeight: DEFAULT_ROW_HEIGHT,\r\n            minHeight: DEFAULT_ROW_HEIGHT,\r\n        });\r\n        this.rowRenderer = this.rowRenderer.bind(this);\r\n    }\r\n\r\n    componentDidUpdate(prevProps: Props): void {\r\n        this.cache.clearAll();\r\n        if (this.list) this.list.forceUpdateGrid();\r\n    }\r\n    componentDidMount() {}\r\n\r\n    rowRenderer({\r\n        key,\r\n        index,\r\n        parent,\r\n        style,\r\n    }: {\r\n        key: string,\r\n        index: number,\r\n        parent: {},\r\n        style: {},\r\n    }): React.Element<CellMeasurer> {\r\n        const selectedText = this.props.selectedText;\r\n        const selectedTextId = selectedText ? selectedText.id : -1;\r\n        const selectedSearchResult = this.props.selectedSearchResult;\r\n        const texts = this.props.texts;\r\n        const onSelectedText = this.props.onSelectedText;\r\n        const onSelectedSearchResult = this.props.onSelectedSearchResult;\r\n        const searchTerm = this.props.searchTerm;\r\n        const searchResults = this.props.searchResults;\r\n        let className = styles.textListRow;\r\n\r\n        const text = texts[index];\r\n        if (text.id === selectedTextId) {\r\n            className = classnames(className, styles.selectedRow);\r\n        }\r\n        let name = addTibetanShay(text.name);\r\n        let nameHtml = <span className={styles.textName}>{name}</span>;\r\n        let textSearchResults = [];\r\n        let resultsCount = null;\r\n        let extraRemaining = false;\r\n        let loadingResults = false;\r\n\r\n        if (searchTerm.length > 0) {\r\n            nameHtml = (\r\n                <HighlightedString\r\n                    string={name}\r\n                    stringClass={styles.textName}\r\n                    highlightClass={styles.highlight}\r\n                    searchTerm={searchTerm}\r\n                />\r\n            );\r\n            if (searchResults.hasOwnProperty(text.id)) {\r\n                textSearchResults = searchResults[text.id].results;\r\n                extraRemaining = searchResults[text.id].extra;\r\n                loadingResults = searchResults[text.id].loading;\r\n                resultsCount = (\r\n                    <ResultCount\r\n                        count={searchResults[text.id].total}\r\n                        extra={extraRemaining}\r\n                    />\r\n                );\r\n            }\r\n        }\r\n\r\n        const cache = this.cache;\r\n\r\n        let textSearchResultRows = [];\r\n        if (textSearchResults.length > 0) {\r\n            textSearchResultRows = textSearchResults.map((result) => {\r\n                const isSelected =\r\n                    selectedSearchResult &&\r\n                    selectedSearchResult.textId === text.id &&\r\n                    selectedSearchResult.start === result[0];\r\n                const className = isSelected\r\n                    ? styles.selectedSearchResult\r\n                    : styles.searchResult;\r\n                if (isSelected) {\r\n                    // TODO: keeps getting rendered when selecting a syllable\r\n                    // console.log(\"got selected result: %o\", result);\r\n                }\r\n                return (\r\n                    <div\r\n                        key={text.id + \"_\" + result[0]}\r\n                        onClick={() => {\r\n                            onSelectedSearchResult(\r\n                                text,\r\n                                result[0],\r\n                                searchTerm.length,\r\n                                selectedText\r\n                            );\r\n                        }}\r\n                        className={className}\r\n                    >\r\n                        <HighlightedString\r\n                            string={result[1]}\r\n                            highlightClass={styles.highlight}\r\n                            searchTerm={searchTerm}\r\n                        />\r\n                    </div>\r\n                );\r\n            });\r\n        }\r\n\r\n        const searchText = () => {\r\n            this.props.onSearchText(text, searchTerm);\r\n        };\r\n        if (searchResults !== null)\r\n            return (\r\n                <CellMeasurer\r\n                    columnIndex={0}\r\n                    key={key}\r\n                    parent={parent}\r\n                    rowIndex={index}\r\n                    cache={cache}\r\n                >\r\n                    <div\r\n                        key={`listkeys-${key}`}\r\n                        style={style}\r\n                        className={className}\r\n                    >\r\n                        {searchTerm && (\r\n                            <div\r\n                                className={styles.textNameRow}\r\n                                onClick={() => {\r\n                                    onSelectedText(texts[index]);\r\n                                }}\r\n                            >\r\n                                {nameHtml} {resultsCount}\r\n                            </div>\r\n                        )}\r\n                        {textSearchResults.length > 0 && (\r\n                            <div className={styles.searchResults}>\r\n                                {textSearchResultRows}\r\n                            </div>\r\n                        )}\r\n                        {extraRemaining && (\r\n                            <div\r\n                                className={styles.loadMore}\r\n                                onClick={searchText}\r\n                            >\r\n                                <LoadMore loading={loadingResults} />\r\n                            </div>\r\n                        )}\r\n                    </div>\r\n                </CellMeasurer>\r\n            );\r\n        else return null;\r\n    }\r\n    findRowHeight({ searchTerm }) {\r\n        return searchTerm ? null : 40;\r\n    }\r\n    render() {\r\n        const texts = this.props.texts;\r\n        let rowCount = texts.length;\r\n        return (\r\n            <div className={styles.textList}>\r\n                {this.props.texts && this.props.texts.length > 0 ? (\r\n                    <AutoSizer>\r\n                        {({ height, width }) => (\r\n                            <List\r\n                                ref={(list) => (this.list = list)}\r\n                                height={height}\r\n                                rowCount={rowCount}\r\n                                rowHeight={\r\n                                    this.findRowHeight(this.props) ||\r\n                                    this.cache.rowHeight\r\n                                }\r\n                                rowRenderer={this.rowRenderer}\r\n                                width={width}\r\n                                overscanRowCount={1}\r\n                                deferredMeasurementCache={this.cache}\r\n                            ></List>\r\n                        )}\r\n                    </AutoSizer>\r\n                ) : this.props.searching ? (\r\n                    <div className={styles.textListLoader}>\r\n                        <Loader loaded={!this.props.searching} scale={0.5} />\r\n                        <p className={styles.searching}>Searching…</p>\r\n                    </div>\r\n                ) : (\r\n                    <ul className=\"textList\" />\r\n                )}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default TextList;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"tab\":\"TextListTab---tab\",\"showTab\":\"TextListTab---showTab\",\"hideTab\":\"TextListTab---hideTab\"};","// @flow\r\nimport React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport styles from \"components/TextList/TextListTab.css\";\r\n\r\ntype Props = {\r\n    textListIsVisible: boolean,\r\n    tabClicked: (e: SyntheticEvent<>) => void\r\n};\r\n\r\nconst TextListTab = (props: Props) => {\r\n    let tabClassnames = [styles.tab];\r\n    if (props.textListIsVisible) {\r\n        tabClassnames.push(styles.hideTab);\r\n    } else {\r\n        tabClassnames.push(styles.showTab);\r\n    }\r\n    return (\r\n        <div\r\n            className={classnames(...tabClassnames)}\r\n            onClick={props.tabClicked}\r\n        >\r\n            Text List\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default TextListTab;\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { batchActions } from \"redux-batched-actions\";\r\n\r\nimport { getTextListVisible } from \"reducers\";\r\nimport { changedTextListVisible, changedActiveAnnotation } from \"actions\";\r\n\r\nimport TextListTab from \"components/TextList/TextListTab\";\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        textListIsVisible: getTextListVisible(state)\r\n    };\r\n};\r\n\r\nconst mapStateToDispatch = dispatch => {\r\n    return {\r\n        tabClicked: () => {\r\n            const textListIsVisible = true;\r\n            dispatch(changedTextListVisible(textListIsVisible));\r\n        }\r\n    };\r\n};\r\n\r\nconst TextListTabContainer = connect(mapStateToProps, mapStateToDispatch)(\r\n    TextListTab\r\n);\r\n\r\nexport default TextListTabContainer;\r\n","export { default } from \"./TextList\";\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"textsSearchContainer\":\"TextsSearch---textsSearchContainer\",\"textsSearch\":\"TextsSearch---textsSearch\",\"minify\":\"TextsSearch---minify\"};","// @flow\r\nimport React, { useTransition } from \"react\";\r\nimport styles from \"./TextsSearch.css\";\r\nimport * as constants from \"app_constants\";\r\n\r\nimport { injectIntl } from \"react-intl\";\r\nimport Button from \"components/UI/Button\";\r\nimport SearchIcon from \"images/search.svg\";\r\n\r\ntype Props = {\r\n    searchValue: string,\r\n    searchChanged: (searchTerm: string) => void,\r\n    selectedSearchOption?: (e: SyntheticEvent<HTMLSelectElement>) => void,\r\n    minimiseButtonClicked: () => void,\r\n    intl: { formatMessage: ({ [id: string]: string }) => string },\r\n    searchTerm: string,\r\n    textListWidth: number,\r\n};\r\n\r\nconst TextsSearch = (props: Props) => {\r\n    let textInput: { current: null | HTMLInputElement } = React.createRef();\r\n    const [ispending, startTransition] = useTransition();\r\n\r\n    const initiateSearch = (e: SyntheticEvent<HTMLElement>) => {\r\n        e.preventDefault();\r\n        if (textInput.current instanceof HTMLInputElement) {\r\n            const searchTerm = textInput.current.value;\r\n            startTransition(() => {\r\n                props.searchChanged(searchTerm);\r\n            });\r\n        }\r\n    };\r\n\r\n    const handleChange = (e) => {\r\n        startTransition(() => {\r\n            if (e.target.value === \"\") {\r\n                props.searchChanged(null);\r\n                return;\r\n            }\r\n            props.searchChanged(e.target.value);\r\n        });\r\n    };\r\n    console.log(props.textListWidth);\r\n    return (\r\n        <div\r\n            className={styles.textsSearchContainer}\r\n            style={{ maxWidth: props.textListWidth }}\r\n        >\r\n            <div className={styles.textsSearch}>\r\n                <form onSubmit={initiateSearch}>\r\n                    <input\r\n                        onChange={handleChange}\r\n                        style={{ outline: \"none\", width: 150 }}\r\n                        type=\"text\"\r\n                        id=\"textSearchInput\"\r\n                        placeholder={props.intl.formatMessage({\r\n                            id: \"leftbar.search\",\r\n                        })}\r\n                        ref={textInput}\r\n                    />\r\n                    <Button\r\n                        backgroundColor=\"#35BF5C\"\r\n                        onClick={initiateSearch}\r\n                        // title={props.intl.formatMessage({\r\n                        //     id: \"leftbar.search\",\r\n                        // })}\r\n                        noBezel={true}\r\n                        icon={<SearchIcon />}\r\n                    />\r\n                </form>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default injectIntl(TextsSearch);\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport TextsSearch from \"./TextsSearch\";\r\nimport { changedSearchValue } from \"actions\";\r\nimport type { AppState } from \"reducers\";\r\nimport * as reducers from \"reducers\";\r\nconst mapStateToProps = (state: AppState) => {\r\n    return {\r\n        searchTerm: reducers.getSearchValue(state),\r\n        searchValue: state.ui.searchValue,\r\n        textListWidth: reducers.getTextListWidth(state),\r\n    };\r\n};\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n    // const { dispatch } = dispatchProps;\r\n    // const { selectedText } = stateProps;\r\n    return {\r\n        searchChanged: (searchTerm: string) => {\r\n            dispatch(changedSearchValue(searchTerm));\r\n        },\r\n    };\r\n};\r\n\r\nconst TextsSearchContainer = connect(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(TextsSearch);\r\n\r\nexport default TextsSearchContainer;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"accessory\":\"Accessory---accessory\"};","import React from \"react\";\r\nimport styles from \"./Accessory.css\";\r\nimport colours from \"css/colour.css\";\r\n\r\nexport const accessoryTypes = {\r\n    ADD: \"+\",\r\n    DELETE: \"\\u00d7\"\r\n};\r\nexport type AccessoryType = $Keys<typeof accessoryTypes>;\r\n\r\ntype Props = {\r\n    type: AccessoryType,\r\n    title?: string,\r\n    onClick?: () => void,\r\n    backgroundColor?: string,\r\n    color?: string\r\n};\r\n\r\nconst Accessory = (props: Props) => {\r\n    let style = {};\r\n    style.backgroundColor = props.backgroundColor || \"\";\r\n    style.color = props.color || \"#fff\";\r\n\r\n    return (\r\n        <div\r\n            className={styles.accessory}\r\n            title={props.title}\r\n            onClick={props.onClick}\r\n            style={style}\r\n        >\r\n            {accessoryTypes[props.type]}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Accessory;\r\n","import React from \"react\";\r\nimport { FormattedMessage, injectIntl } from \"react-intl\";\r\nimport { Tooltip, Tootip } from \"@mui/material\";\r\nfunction ApplyTooltip({\r\n    children,\r\n    tooltipName,\r\n    format = null,\r\n    className = \"\",\r\n    shortcut = \"\",\r\n    on = false,\r\n}) {\r\n    return (\r\n        <>\r\n            <div\r\n                data-tip\r\n                data-for={tooltipName}\r\n                className={className}\r\n                style={{ width: \"100%\" }}\r\n            >\r\n                {!on ? (\r\n                    <Tooltip\r\n                        placement=\"top\"\r\n                        followCursor\r\n                        title={\r\n                            format ? (\r\n                                <FormattedMessage id={format} />\r\n                            ) : (\r\n                                <span>\r\n                                    {tooltipName}\r\n                                    {` [${shortcut}]`}\r\n                                </span>\r\n                            )\r\n                        }\r\n                    >\r\n                        {children}\r\n                    </Tooltip>\r\n                ) : (\r\n                    children\r\n                )}\r\n            </div>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default ApplyTooltip;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"button\":\"Button---button\",\"buttonNoBezel\":\"Button---buttonNoBezel\",\"active\":\"Button---active\",\"leftAlign\":\"Button---leftAlign\",\"title\":\"Button---title\",\"icon\":\"Button---icon\"};","import React from \"react\";\r\nimport classnames from \"classnames\";\r\nimport colours from \"css/colour.css\";\r\nimport styles from \"./Button.css\";\r\nimport Accessory from \"./Accessory\";\r\nimport ApplyTooltip from \"./ApplyTooltip\";\r\nexport type Alignment = \"left\" | \"center\" | \"right\";\r\n\r\ntype Props = {\r\n    title: string,\r\n    color?: string,\r\n    backgroundColor?: string,\r\n    icon?: any,\r\n    align?: Alignment,\r\n    isActive?: boolean,\r\n    accessoryType?: AccessoryType,\r\n    onClick?: () => void,\r\n    noBezel?: boolean,\r\n    disabled?: boolean,\r\n    tooltipTitle: String,\r\n    shortcut?: String,\r\n};\r\n\r\nexport default class Button extends React.Component<Props> {\r\n    render() {\r\n        let color = this.props.color || \"#ffffff\";\r\n        let bgColour = this.props.backgroundColor || colours.mainTint;\r\n        let fontSize = this.props.fontSize || \"14px\";\r\n        let classNames = this.props.noBezel\r\n            ? [styles.buttonNoBezel]\r\n            : [styles.button];\r\n        let tooltipTitle = this.props.tooltipTitle || \"\";\r\n        if (this.props.isActive) classNames.push(styles.active);\r\n        const className = classnames(...classNames);\r\n        let shortcut = this.props.shortcut || \"\";\r\n        let style = {\r\n            fontSize,\r\n            color: color,\r\n            backgroundColor: bgColour,\r\n        };\r\n        if (this.props.align) style.textAlign = this.props.align;\r\n\r\n        return (\r\n            <ApplyTooltip\r\n                tooltipName={tooltipTitle}\r\n                shortcut={shortcut}\r\n                on={this.props.disabled}\r\n            >\r\n                <button\r\n                    style={style}\r\n                    className={className}\r\n                    onClick={this.props.onClick}\r\n                    disabled={this.props.disabled}\r\n                >\r\n                    {this.props.icon && (\r\n                        <div className={styles.icon}>{this.props.icon}</div>\r\n                    )}\r\n                    {this.props.title && (\r\n                        <span className={styles.title}>{this.props.title}</span>\r\n                    )}\r\n                    {this.props.accessoryType && (\r\n                        <Accessory type={this.props.accessoryType} />\r\n                    )}\r\n                </button>\r\n            </ApplyTooltip>\r\n        );\r\n    }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"inputRanges\":\"Slider---inputRanges\",\"inputRange\":\"Slider---inputRange\"};","import React, { useEffect, useState } from \"react\";\r\nimport styles from \"./Slider.css\";\r\nimport _ from \"lodash\";\r\nfunction Slider({\r\n    max,\r\n    min,\r\n    initialvalue,\r\n    changeSize = (r) => console.log(r),\r\n}) {\r\n    let initialPercent = (initialvalue / max) * 100;\r\n    const [tempValue, setTempValue] = useState(initialPercent);\r\n    const submitValue = _.debounce((e) => {\r\n        let currentPercent = (tempValue / 100) * max;\r\n        changeSize(Math.floor(parseInt(currentPercent)));\r\n    }, 500);\r\n\r\n    return (\r\n        <div className={styles.inputRanges}>\r\n            <span\r\n                style={{ fontSize: 13, top: \"-5px\" }}\r\n                onClick={() => changeSize(initialvalue - 2)}\r\n            >\r\n                ཀ\r\n            </span>\r\n            <input\r\n                type=\"range\"\r\n                style={{ width: \"70%\" }}\r\n                className={styles.inputRange}\r\n                min={40}\r\n                max={100}\r\n                smooth=\"yes\"\r\n                step={1}\r\n                value={tempValue}\r\n                onChange={(e) => setTempValue(e.target.value)}\r\n                onMouseUp={submitValue}\r\n                onTouchEnd={submitValue}\r\n            />\r\n            <span\r\n                style={{ fontSize: 18, top: \"-10px\" }}\r\n                onClick={() => changeSize(initialvalue + 2)}\r\n            >\r\n                ཀ\r\n            </span>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Slider;\r\n","// @flow\r\nimport React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport TextList from \"components/TextList\";\r\nimport * as actions from \"actions\";\r\nimport { getSelectedText } from \"reducers\";\r\nimport type { AppState } from \"reducers\";\r\nimport * as api from \"api\";\r\nimport * as reducers from \"reducers\";\r\nimport { batchActions } from \"redux-batched-actions\";\r\n\r\nconst mapStateToProps = (state: AppState) => {\r\n    const searchValue = reducers.getSearchValue(state);\r\n    const searchResults = reducers.getSearchResults(state, searchValue);\r\n    const selectedSearchResult = reducers.getSelectedSearchResult(state);\r\n    // TODO: display search results or spinner depending on when anything\r\n    // returned\r\n\r\n    let searching = false;\r\n    let texts = state.data.texts;\r\n    if (searchValue.length > 0) {\r\n        if (searchResults === null) {\r\n            searching = true;\r\n            texts = [];\r\n        } else {\r\n            texts = texts.filter((text) =>\r\n                searchResults.hasOwnProperty(text.id)\r\n            );\r\n        }\r\n    }\r\n\r\n    return {\r\n        texts: texts,\r\n        selectedText: getSelectedText(state),\r\n        searchTerm: searchValue,\r\n        searchResults,\r\n        selectedSearchResult,\r\n        searching,\r\n    };\r\n};\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        onSelectedText: (text: api.TextData) => {\r\n            dispatch(actions.selectedText(text));\r\n        },\r\n        onSelectedSearchResult: (\r\n            text: api.TextData,\r\n            start: number,\r\n            length: number,\r\n            selectedText: api.TextData | null\r\n        ) => {\r\n            if (!selectedText || selectedText.id !== text.id) {\r\n                dispatch(\r\n                    batchActions([\r\n                        actions.selectedSearchResult(text.id, start, length),\r\n                        actions.selectedText(text),\r\n                    ])\r\n                );\r\n            } else {\r\n                dispatch(actions.selectedSearchResult(text.id, start, length));\r\n            }\r\n        },\r\n        onSearchText: (text: api.TextData, searchTerm: string) => {\r\n            dispatch(actions.searchedText(text.id, searchTerm));\r\n        },\r\n    };\r\n};\r\n\r\nconst TextListContainer = connect(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(TextList);\r\n\r\nexport default TextListContainer;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\"};","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\n\nvar _ref =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3 0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9 0l60.1 60.1c18.8 18.7 18.8 49.1 0 67.9zM284.2 99.8L21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3 0-17l-111-111c-4.8-4.7-12.4-4.7-17.1 0zM124.1 339.9c-5.5-5.5-5.5-14.3 0-19.8l154-154c5.5-5.5 14.3-5.5 19.8 0s5.5 14.3 0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8 0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z\"\n});\n\nvar SvgPencilAltIcon = function SvgPencilAltIcon(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 512 512\"\n  }, props), _ref);\n};\n\nexport default SvgPencilAltIcon;","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\n\nvar _ref =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M0 0h24v24H0z\",\n  fill: \"none\"\n});\n\nvar _ref2 =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"\n});\n\nvar SvgCheckCircle = function SvgCheckCircle(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 24 24\"\n  }, props), _ref, _ref2);\n};\n\nexport default SvgCheckCircle;","export default __webpack_public_path__ + \"8967124136190c7842d863e4a862a528.png\";","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\n\nvar _ref =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M3 18h12v-2H3v2zM3 6v2h18V6H3zm0 7h18v-2H3v2z\"\n});\n\nvar _ref2 =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  fill: \"none\",\n  d: \"M0 0h24v24H0V0z\"\n});\n\nvar SvgNote = function SvgNote(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 24 24\"\n  }, props), _ref, _ref2);\n};\n\nexport default SvgNote;","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\n\nvar _ref =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"g\", {\n  fill: \"#010002\"\n}, /*#__PURE__*/React.createElement(\"circle\", {\n  cx: 26.465,\n  cy: 25.59,\n  r: 4.462\n}), /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M52.791 32.256c-.187-1.034-1.345-2.119-2.327-2.492l-2.645-1.004c-.982-.373-1.699-1.237-1.651-1.935.029-.417.046-.838.046-1.263 0-.284-.008-.566-.021-.846-.023-.467.719-1.193 1.677-1.624l2.39-1.074c.958-.432 2.121-1.565 2.194-2.613.064-.929-.047-2.196-.648-3.765a8.336 8.336 0 00-2.779-3.718c-.839-.633-2.423-.595-3.381-.163l-2.08.936c-.958.431-2.274.119-3.025-.616a17.282 17.282 0 00-.54-.509c-.778-.705-1.17-2-.796-2.983l.819-2.162c.373-.982.368-2.594-.322-3.385-.635-.728-1.643-1.579-3.215-2.281-1.764-.788-3.346-.811-4.483-.639-1.039.158-2.121 1.331-2.494 2.312l-.946 2.491c-.373.982-.798 1.775-.949 1.771a6.289 6.289 0 00-.274-.005c-.622 0-1.238.03-1.846.09-1.016.1-2.176-.507-2.607-1.465l-1.124-2.5c-.431-.959-1.538-2.21-2.589-2.227-.916-.016-2.207.209-3.936 1.028-1.874.889-2.971 1.742-3.611 2.437-.712.771-.554 2.416-.122 3.374l1.481 3.296c.431.958.256 2.266-.324 2.979-.579.714-1.786 1.033-2.768.661l-3.598-1.365c-.982-.373-2.65-.476-3.406.256-.658.637-1.412 1.709-2.056 3.51-.696 1.954-.867 3.332-.83 4.276.042 1.05 1.317 2.101 2.3 2.474l4.392 1.667c.982.373 1.782 1.244 1.839 1.941.055.699-.635 1.61-1.593 2.042l-4.382 1.97c-.958.431-2.211 1.539-2.227 2.589-.015.916.21 2.208 1.028 3.935.89 1.874 1.742 2.971 2.437 3.611.773.713 2.417.554 3.375.123l4.698-2.112c.958-.432 2.076-.412 2.525.013s.535 1.541.162 2.524L12.743 46.6c-.373.982-.476 2.65.256 3.404.638.659 1.709 1.414 3.51 2.057 1.954.697 3.333.868 4.277.831 1.05-.042 2.1-1.318 2.473-2.3l1.693-4.46c.373-.982 1.058-1.742 1.531-1.719a17.414 17.414 0 001.255.016c.219-.007.747.762 1.178 1.721l1.963 4.364c.431.958 1.605 1.986 2.653 2.038 1.121.056 2.669-.062 4.43-.734 1.685-.645 2.659-1.604 3.219-2.442.584-.873.388-2.517-.044-3.475l-1.606-3.573c-.431-.958-.169-2.191.527-2.824.693-.633 2-.9 2.981-.526l3.432 1.303c.982.373 2.64.489 3.478-.145.738-.56 1.591-1.49 2.281-3.034.827-1.854.785-3.605.561-4.846zM26.465 39.79c-7.844 0-14.201-6.357-14.201-14.2s6.357-14.2 14.201-14.2c7.842 0 14.2 6.357 14.2 14.2.001 7.843-6.358 14.2-14.2 14.2z\"\n}));\n\nvar SvgOptions = function SvgOptions(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 52.93 52.93\"\n  }, props), _ref);\n};\n\nexport default SvgOptions;","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\n\nvar _ref =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M3 0h24v15H3z\"\n});\n\nvar _ref2 =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  stroke: \"currentColor\",\n  strokeWidth: 3,\n  d: \"M0 20h8M11 20h8M22 20h8\"\n});\n\nvar _ref3 =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M3 25h24v15H3z\"\n});\n\nvar SvgPageBreakIcon = function SvgPageBreakIcon(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 30 40\",\n    fill: \"currentColor\"\n  }, props), _ref, _ref2, _ref3);\n};\n\nexport default SvgPageBreakIcon;","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\n\nvar _ref =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M0 0h24v24H0z\",\n  fill: \"none\"\n});\n\nvar _ref2 =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z\"\n});\n\nvar SvgQuestionAnswer = function SvgQuestionAnswer(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 24 24\",\n    fill: \"currentColor\"\n  }, props), _ref, _ref2);\n};\n\nexport default SvgQuestionAnswer;","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\n\nvar _ref =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M9 2C5.146 2 2 5.146 2 9s3.146 7 7 7a6.959 6.959 0 004.574-1.719l.426.426V16l6 6 2-2-6-6h-1.293l-.426-.426A6.959 6.959 0 0016 9c0-3.854-3.146-7-7-7zm0 2c2.773 0 5 2.227 5 5s-2.227 5-5 5-5-2.227-5-5 2.227-5 5-5z\"\n});\n\nvar SvgSearch = function SvgSearch(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    width: 24,\n    height: 24\n  }, props), _ref);\n};\n\nexport default SvgSearch;","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\n\nvar _ref =\n/*#__PURE__*/\n\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M507.73 109.1c-2.24-9.03-13.54-12.09-20.12-5.51l-74.36 74.36-67.88-11.31-11.31-67.88 74.36-74.36c6.62-6.62 3.43-17.9-5.66-20.16-47.38-11.74-99.55.91-136.58 37.93-39.64 39.64-50.55 97.1-34.05 147.2L18.74 402.76c-24.99 24.99-24.99 65.51 0 90.5 24.99 24.99 65.51 24.99 90.5 0l213.21-213.21c50.12 16.71 107.47 5.68 147.37-34.22 37.07-37.07 49.7-89.32 37.91-136.73zM64 472c-13.25 0-24-10.75-24-24 0-13.26 10.75-24 24-24s24 10.74 24 24c0 13.25-10.75 24-24 24z\"\n});\n\nvar SvgWrench = function SvgWrench(props) {\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 512 512\"\n  }, props), _ref);\n};\n\nexport default SvgWrench;","// @flow\r\nimport SegmentedText from \"./SegmentedText\";\r\nimport AnnotatedText from \"./AnnotatedText\";\r\n\r\nexport type Splitter = (string) => number[];\r\n\r\nexport default class SplitText {\r\n    annotatedText: AnnotatedText;\r\n    splitter: Splitter;\r\n    _texts: SegmentedText[] | null;\r\n    _textsId: string | null;\r\n    _textsFinalPositions: number[];\r\n\r\n    constructor(annotatedText: AnnotatedText, splitter: Splitter) {\r\n        this.annotatedText = annotatedText;\r\n        this.splitter = splitter;\r\n        this._texts = null;\r\n        this._textsId = null;\r\n        this._textsFinalPositions = [];\r\n    }\r\n\r\n    get texts(): SegmentedText[] {\r\n        if (!this.annotatedText) {\r\n            return [];\r\n        }\r\n        if (\r\n            !this._texts ||\r\n            this._textsId !== this.annotatedText.getUniqueId()\r\n        ) {\r\n            this._textsFinalPositions = [];\r\n            const segmentedText = this.annotatedText.segmentedText;\r\n            const textString = segmentedText.getText();\r\n            let splitPositions = this.splitter(textString).filter(\r\n                (l) => l !== 0\r\n            );\r\n            if (splitPositions.length === 0) {\r\n                this._textsFinalPositions.push(textString.length);\r\n                return [segmentedText];\r\n            }\r\n            let lastPosition = splitPositions[splitPositions.length - 1];\r\n            if (lastPosition + 1 < textString.length) {\r\n                splitPositions.push(textString.length - 1);\r\n            }\r\n            const segments = segmentedText.segments;\r\n            let startIndex = 0;\r\n            let texts = [];\r\n            for (let i = 0; i < splitPositions.length; i++) {\r\n                const position = splitPositions[i];\r\n                const endIndex = segmentedText.indexOfSegmentAtPosition(\r\n                    position - 1\r\n                );\r\n                let textSegments;\r\n                if (i == splitPositions.length - 1) {\r\n                    // final position\r\n                    textSegments = segments.slice(startIndex);\r\n                } else {\r\n                    textSegments = segments.slice(startIndex, endIndex + 1);\r\n                }\r\n\r\n                const text = new SegmentedText(textSegments);\r\n                texts.push(text);\r\n                startIndex = endIndex + 1;\r\n                if (endIndex >= 0) {\r\n                    const finalSegment = segments[endIndex];\r\n                    this._textsFinalPositions.push(finalSegment.end);\r\n                }\r\n            }\r\n\r\n            this._texts = texts.filter((l) => l.segments.length > 0);\r\n            this._textsId = this.annotatedText.getUniqueId();\r\n        }\r\n        return this._texts || [];\r\n    }\r\n\r\n    getTextsFinalPositions(): number[] {\r\n        this.texts;\r\n        return this._textsFinalPositions;\r\n    }\r\n\r\n    /**\r\n     * Return the index of the text portion that contains the given position.\r\n     *\r\n     * @param position\r\n     * @returns number\r\n     */\r\n    getTextIndexOfPosition(position: number): number {\r\n        const textsFinalPositions = this.getTextsFinalPositions();\r\n        let lastPosition = 0;\r\n        let textIndex = null;\r\n        for (let i = 0; i < textsFinalPositions.length; i++) {\r\n            let endPosition = textsFinalPositions[i];\r\n            if (position >= lastPosition && position <= endPosition) {\r\n                textIndex = i;\r\n                break;\r\n            }\r\n            lastPosition = endPosition;\r\n        }\r\n        if (textIndex === null) {\r\n            // Likely an insertion at the end of a text\r\n            console.warn(\"no index for position %d\", position);\r\n            textIndex = textsFinalPositions.length - 1;\r\n        }\r\n        return textIndex;\r\n    }\r\n}\r\n","export default function shallowEqual(objA, objB) {\r\n    if (objA === objB) {\r\n        return true;\r\n    }\r\n\r\n    let aKeys = Object.keys(objA);\r\n    let bKeys = Object.keys(objB);\r\n    let len = aKeys.length;\r\n\r\n    if (bKeys.length !== len) {\r\n        return false;\r\n    }\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        let key = aKeys[i];\r\n\r\n        if (objA[key] !== objB[key]) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n","// @flow\r\nimport type { Splitter } from \"lib/SplitText\";\r\n\r\n/**\r\n * Returns a function that accepts a string but simply\r\n * returns the initial array of positions passed to it.\r\n *\r\n * @param positions - The positions where a string should be split\r\n */\r\nexport default function positionSplitter(positions: number[]): Splitter {\r\n    const newPositions = [...positions];\r\n    if (newPositions[0] === 0) {\r\n        newPositions.shift();\r\n    }\r\n    return string => newPositions;\r\n}\r\n","// @flow\r\nimport * as reducers from \"reducers\";\r\nimport type { AppState } from \"reducers\";\r\nimport AnnotatedText from \"lib/AnnotatedText\";\r\nimport Witness from \"lib/Witness\";\r\nimport Annotation, { ANNOTATION_TYPES } from \"lib/Annotation\";\r\nimport type { AnnotationUniqueId } from \"lib/Annotation\";\r\nimport type { AnnotationData, TextData } from \"api\";\r\nimport segmentTibetanText from \"lib/segmentTibetanText\";\r\nimport SegmentedText from \"lib/SegmentedText\";\r\nimport _ from \"lodash\";\r\n\r\nlet store: { [witnessId: number]: AnnotatedText } = {};\r\n\r\nexport const getWitnessText = (\r\n    state: AppState,\r\n    witnessId: number\r\n): AnnotatedText | null => {\r\n    let text: AnnotatedText | null = null;\r\n\r\n    if (witnessId) {\r\n        text = generateAnnotatedText(state, witnessId);\r\n        if (text) {\r\n            store[witnessId] = text;\r\n        }\r\n    }\r\n\r\n    return text;\r\n};\r\n\r\nexport const addTextAnnotation = (\r\n    state: AppState,\r\n    witnessId: number,\r\n    annotation: Annotation\r\n) => {\r\n    const text = getWitnessText(state, witnessId);\r\n    if (text) {\r\n        text.addAnnotation(annotation);\r\n    }\r\n    // If witnessId is present, assume that getWitnessAnnotations\r\n    // has already been called.\r\n    if (annotationStore.hasOwnProperty(witnessId)) {\r\n        if (\r\n            !annotationStore[witnessId].appliedAnnotations.hasOwnProperty(\r\n                annotation.uniqueId\r\n            )\r\n        ) {\r\n            annotationStore[witnessId].appliedAnnotations[annotation.uniqueId] =\r\n                annotation;\r\n        }\r\n        if (\r\n            !annotationStore[witnessId].allAnnotations.hasOwnProperty(\r\n                annotation.uniqueId\r\n            )\r\n        ) {\r\n            annotationStore[witnessId].allAnnotations[annotation.uniqueId] =\r\n                annotation;\r\n        }\r\n    }\r\n};\r\n\r\nexport const removeTextAnnotation = (\r\n    state: AppState,\r\n    witnessId: number,\r\n    annotationId: AnnotationUniqueId\r\n) => {\r\n    const text = getWitnessText(state, witnessId);\r\n    if (text) {\r\n        text.removeAnnotation(annotationId);\r\n    }\r\n    if (annotationStore.hasOwnProperty(witnessId)) {\r\n        if (\r\n            annotationStore[witnessId].appliedAnnotations.hasOwnProperty(\r\n                annotationId\r\n            )\r\n        ) {\r\n            delete annotationStore[witnessId].appliedAnnotations[annotationId];\r\n        }\r\n    }\r\n};\r\n\r\nexport const deleteTextAnnotation = (\r\n    state: AppState,\r\n    witnessId: number,\r\n    annotationId: AnnotationUniqueId\r\n) => {\r\n    const text = getWitnessText(state, witnessId);\r\n    if (text) {\r\n        text.removeAnnotation(annotationId);\r\n    }\r\n    if (annotationStore.hasOwnProperty(witnessId)) {\r\n        if (\r\n            annotationStore[witnessId].allAnnotations.hasOwnProperty(\r\n                annotationId\r\n            )\r\n        ) {\r\n            delete annotationStore[witnessId].allAnnotations[annotationId];\r\n        }\r\n        if (\r\n            annotationStore[witnessId].appliedAnnotations.hasOwnProperty(\r\n                annotationId\r\n            )\r\n        ) {\r\n            delete annotationStore[witnessId].appliedAnnotations[annotationId];\r\n        }\r\n    }\r\n};\r\n\r\nlet annotationStore: {\r\n    [witnessId: number]: {\r\n        appliedAnnotations: { [AnnotationUniqueId]: Annotation },\r\n        allAnnotations: { [AnnotationUniqueId]: Annotation },\r\n    },\r\n} = {};\r\n\r\nexport const getWitnessAnnotations = (\r\n    state: AppState,\r\n    witness: Witness,\r\n    workingWitness: Witness\r\n): [\r\n    { [AnnotationUniqueId]: Annotation },\r\n    { [AnnotationUniqueId]: Annotation }\r\n] => {\r\n    if (annotationStore.hasOwnProperty(witness.id)) {\r\n        return [\r\n            annotationStore[witness.id].appliedAnnotations,\r\n            annotationStore[witness.id].allAnnotations,\r\n        ];\r\n    }\r\n\r\n    const text = witness.text;\r\n\r\n    let workingAnnotationList = reducers.getAnnotationsForWitnessId(\r\n        state,\r\n        workingWitness.id\r\n    );\r\n\r\n    let appliedAnnotations = getActiveAnnotations(\r\n        state,\r\n        witness.id,\r\n        workingWitness.id\r\n    );\r\n\r\n    let removedDefaultAnnotations = null;\r\n    // Default annotations removed by the user.\r\n    // Usually these are available when viewing\r\n    // a non-working edition.\r\n    let nonActiveAnnotations = {};\r\n\r\n    if (witness.id !== workingWitness.id) {\r\n        // If we are not viewing the working version,\r\n        // get all the annotations created by the selected witness\r\n        // BUT NOT BY A USER to apply to the base text.\r\n        // User-created annotations need to be in appliedAnnotations.\r\n\r\n        removedDefaultAnnotations =\r\n            reducers.getRemovedDefaultAnnotationsForWitnessId(\r\n                state,\r\n                witness.id\r\n            );\r\n\r\n        let selectedWitnessAnnotations = {};\r\n\r\n        for (let key in workingAnnotationList) {\r\n            if (workingAnnotationList.hasOwnProperty(key)) {\r\n                let annotationData = workingAnnotationList[key];\r\n                if (\r\n                    annotationData.creator_witness === witness.id &&\r\n                    !removedDefaultAnnotations.hasOwnProperty(\r\n                        annotationData.unique_id\r\n                    )\r\n                ) {\r\n                    selectedWitnessAnnotations[annotationData.unique_id] =\r\n                        annotationData;\r\n                } else if (annotationData.creator_witness === witness.id) {\r\n                    nonActiveAnnotations[annotationData.unique_id] =\r\n                        annotationData;\r\n                }\r\n            }\r\n        }\r\n\r\n        let selectedWitnessAnnotationsList = annotationsMapFromData(\r\n            state,\r\n            selectedWitnessAnnotations\r\n        );\r\n\r\n        appliedAnnotations = {\r\n            ...selectedWitnessAnnotationsList,\r\n            ...appliedAnnotations,\r\n        };\r\n\r\n        workingAnnotationList = selectedWitnessAnnotations;\r\n    }\r\n\r\n    let annotations = annotationsMapFromData(state, workingAnnotationList);\r\n    nonActiveAnnotations = annotationsMapFromData(state, nonActiveAnnotations);\r\n    if (Object.keys(nonActiveAnnotations).length > 0) {\r\n        annotations = {\r\n            ...annotations,\r\n            ...nonActiveAnnotations,\r\n        };\r\n    }\r\n\r\n    annotations = {\r\n        ...appliedAnnotations,\r\n        ...annotations,\r\n    };\r\n\r\n    annotations = _.pickBy(\r\n        annotations,\r\n        (annotation: Annotation, key: AnnotationUniqueId) => {\r\n            return !(\r\n                witness &&\r\n                annotation.type === ANNOTATION_TYPES.lineBreak &&\r\n                annotation.creatorWitness.id !== witness.id\r\n            );\r\n        }\r\n    );\r\n\r\n    // Only cache if annotations have been loaded\r\n    if (\r\n        reducers.hasLoadedWitnessAnnotations2(state, witness.id) &&\r\n        reducers.hasLoadedWitnessAppliedAnnotations(state, witness.id)\r\n    ) {\r\n        annotationStore[witness.id] = {\r\n            appliedAnnotations: appliedAnnotations,\r\n            allAnnotations: annotations,\r\n        };\r\n    }\r\n\r\n    return [appliedAnnotations, annotations];\r\n};\r\n\r\nconst generateAnnotatedText = (\r\n    state: AppState,\r\n    witnessId: number\r\n): AnnotatedText | null => {\r\n    const witness = reducers.getWitness2(state, witnessId);\r\n    if (!witness) {\r\n        console.warn(\"no witness\");\r\n        return null;\r\n    }\r\n    const text = witness.text;\r\n    const workingWitness = reducers.getWorkingWitness2(state, text.id);\r\n    const baseWitness = reducers.getBaseWitness2(state, text.id);\r\n\r\n    if (!workingWitness || !baseWitness) {\r\n        return null;\r\n    }\r\n\r\n    let [appliedAnnotations, availableAnnotations] = getWitnessAnnotations(\r\n        state,\r\n        witness,\r\n        workingWitness\r\n    );\r\n    let segmentedWorkingWitness = getSegmentedWitness(workingWitness);\r\n    let annotatedText = new AnnotatedText(\r\n        segmentedWorkingWitness,\r\n        (Object.values(appliedAnnotations): any),\r\n        (text) => segmentTibetanText(text).segments,\r\n        workingWitness,\r\n        witness\r\n    );\r\n\r\n    return annotatedText;\r\n};\r\n\r\nconst getActiveAnnotations = (\r\n    state: AppState,\r\n    witnessId,\r\n    baseWitnessId\r\n): { [AnnotationUniqueId]: Annotation } => {\r\n    const loadedAppliedAnnotations =\r\n        reducers.hasLoadedWitnessAppliedAnnotations(state, witnessId);\r\n    if (!loadedAppliedAnnotations) {\r\n        return {};\r\n    }\r\n    const activeAnnotationList = reducers.getActiveAnnotationsForWitnessId(\r\n        state,\r\n        witnessId\r\n    );\r\n    if (!activeAnnotationList) {\r\n        return {};\r\n    }\r\n\r\n    let activeAnnotationDataList = {};\r\n    for (let activeAnnotationId in activeAnnotationList) {\r\n        if (activeAnnotationList.hasOwnProperty(activeAnnotationId)) {\r\n            let activeAnnotationData = reducers.getAnnotationData(\r\n                state,\r\n                baseWitnessId,\r\n                activeAnnotationId\r\n            );\r\n            if (activeAnnotationData) {\r\n                activeAnnotationDataList[activeAnnotationData.unique_id] =\r\n                    activeAnnotationData;\r\n            }\r\n        }\r\n    }\r\n\r\n    return annotationsMapFromData(state, activeAnnotationDataList);\r\n};\r\n\r\nconst annotationsMapFromData = (\r\n    state: AppState,\r\n    annotationList: { [AnnotationUniqueId]: AnnotationData }\r\n): { [AnnotationUniqueId]: Annotation } => {\r\n    let annotations = {};\r\n    for (let key in annotationList) {\r\n        if (annotationList.hasOwnProperty(key)) {\r\n            let annotationData = annotationList[key];\r\n            let annotation = reducers.annotationFromData(state, annotationData);\r\n            if (annotation) {\r\n                annotations[key] = annotation;\r\n            }\r\n        }\r\n    }\r\n    return annotations;\r\n};\r\n\r\n// TODO: clear cache when changing texts\r\nlet _segmentedWitnesses: { [number]: SegmentedText } = {};\r\nfunction getSegmentedWitness(witness: Witness): SegmentedText {\r\n    if (!_segmentedWitnesses[witness.id]) {\r\n        _segmentedWitnesses[witness.id] = segmentTibetanText(\r\n            witness.content || \"\"\r\n        );\r\n    }\r\n\r\n    return _segmentedWitnesses[witness.id];\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAOA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAOA;AACA;AACA;AAHA;AAMA;AAEA;AADA;AAIA;AACA;AACA;AAAA;AAAA;AARA;AAWA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AANA;AASA;AAAA;AAAA;AACA;AACA;AACA;AACA;AALA;AASA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAHA;AAKA;AAEA;AACA;AACA;AACA;AACA;AALA;AADA;AAUA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;AC1LA;AACA;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AAuBA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAFA;AAsBA;AACA;AACA;AAKA;AACA;AACA;AAVA;AA2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAAA;AAMA;;;;;;;;;;;;AC5GA;AAAA;AAAA;AAAA;;;;;;;;;;;;ACAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAAA;AAAA;AAFA;AAGA;AACA;;;AAMA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAjBA;AACA;AACA;AAAA;AAAA;AACA;;;;AATA;AACA;AAyBA;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAWA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAFA;AAMA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AATA;AAaA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAOA;AAAA;AAAA;AAGA;AAAA;AAAA;AAOA;AACA;AACA;;;;;;;;;;;ACxEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AAEA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AAEA;AACA;AAHA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AASA;AACA;AACA;AACA;AAFA;AAFA;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAFA;AANA;AAYA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAQA;AAKA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAHA;AAQA;AAAA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAMA;AAAA;AAKA;AACA;AACA;AACA;AACA;AALA;AAUA;AAAA;AAAA;AAAA;AACA;AAAA;AAKA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAPA;AASA;AAAA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAHA;AASA;AAAA;AAOA;AACA;AACA;;;;;;;;;;;;ACzPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAiBA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAMA;AACA;AAMA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAVA;AAaA;AACA;AACA;AAKA;;;;;;;;;;;ACzFA;AACA;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAFA;AASA;AACA;AAAA;AAAA;AAAA;AAFA;AAUA;AACA;AAAA;AAAA;AAFA;AAQA;AACA;AACA;AACA;AACA;AAJA;AADA;AAiBA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxDA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AADA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAbA;AAiBA;AACA;AACA;;;;;;;;;;;;ACrIA;AAAA;AAAA;AAAA;;;;;;;;;;;;ACAA;AACA;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;;;;;;;;;;;AChBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AA8CA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;;;;;AAKA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AACA;AALA;AAMA;AACA;;;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAEA;AACA;;;AAEA;AACA;AACA;AAAA;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAOA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAAA;AAOA;AACA;AACA;AACA;AACA;;;AAEA;AAWA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AAjBA;AAoBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAtBA;AACA;AAwBA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAUA;AACA;AACA;AAEA;AAAA;AAHA;AAFA;AAYA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAKA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AARA;AAYA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAOA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AAKA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AANA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAFA;AAQA;AAGA;AAGA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAsBA;AAAA;AAeA;AACA;AAAA;AAAA;AAFA;AAMA;;;;AA1lBA;AACA;AA4lBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1qBA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AASA;AAMA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAFA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAAA;AAEA;AACA;AAAA;AAIA;AACA;AACA;AACA;AA3CA;AACA;AACA;AAAA;AA0CA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AAQA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AASA;AAMA;AACA;AAAA;AAEA;AACA;AAKA;AAOA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAQA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AAGA;AAAA;AAIA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAUA;AAIA;AAEA;AACA;AACA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAYA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AAKA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAAA;AACA;AAMA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAMA;AACA;AACA;AAIA;AAMA;AAGA;AAMA;AACA;AACA;AAIA;AAMA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAMA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AAGA;AACA;AACA;AAWA;AAGA;AACA;AACA;AACA;AACA;AACA;AAWA;AAGA;AACA;AAKA;AAAA;AAAA;AAAA;AACA;AAEA;AAGA;AAEA;AACA;AAKA;AACA;AArQA;AAuQA;AACA;AACA;AAMA;;;;;;;;;;;ACh0BA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AACA;AAAA;;;;;AACA;AACA;AAAA;AACA;AADA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AADA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAMA;AATA;AAWA;AACA;AACA;AACA;AACA;AAfA;AAkBA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAHA;AAUA;AACA;AACA;AACA;AACA;AACA;AAfA;AAkBA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AAXA;AAcA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAHA;AAUA;AACA;AACA;AACA;AACA;AACA;AAfA;AAmBA;AADA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAMA;AACA;AAbA;AAwBA;;;;AA3HA;AACA;AA6HA;;;;;;;;;;;ACjJA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AAQA;;;;;;;;;;;;;AACA;AACA;AACA;AAAA;AACA;AAEA;AADA;AAIA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAGA;;;;AArBA;AACA;AAuBA;;;;;;;;;;;ACrCA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAUA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AAHA;AAUA;AAAA;AAAA;AACA;AACA;AACA;AAJA;AAcA;AACA;AACA;;;;;;;;;;;;AC7GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAMA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AAAA;AAGA;AACA;AAFA;AAIA;AAAA;AAMA;AACA;AACA;;;;;;;;;;;AC3DA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;;;;;;;;;;;;;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AADA;AAFA;AAMA;AAAA;AACA;AAAA;AAEA;AAAA;AAIA;;;;AAjBA;AACA;;;;;;;;;;;;ACdA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AAQA;;;;;AACA;AAAA;AACA;AADA;AAEA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AAAA;AADA;AAMA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;;;AAvCA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAJA;AASA;AACA;AACA;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAFA;AACA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAOA;AAAA;AAGA;AACA;AAAA;AAAA;AAFA;AAKA;AACA;AACA;AAHA;AAUA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AADA;AAeA;AACA;AACA;;;;;;;;;;;ACpEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAFA;AAWA;AACA;AACA;AACA;AAJA;AAQA;AACA;AAFA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AASA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAGA;AAAA;AAAA;AACA;AAFA;AAKA;AACA;AAAA;AAAA;AAIA;AAIA;;;;;;;;;;;;ACrGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAKA;AACA;AACA;;;;;;;;;;;ACjBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAKA;AACA;AAFA;AAIA;AAAA;AAAA;AACA;AAAA;AAKA;AAAA;AAAA;AAKA;;;;AArCA;AACA;;;;;;;;;;;;ACbA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AAWA;;;;;AAGA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AADA;AAHA;AAMA;AACA;;;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AADA;AAGA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AANA;AAQA;AAAA;AAEA;AACA;AAFA;AAIA;AAAA;AAGA;AACA;AAFA;AAIA;AAAA;AAKA;;;;AAzDA;AACA;;;;;;;;;;;;AClBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AAiBA;;;;;AAGA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AADA;AAHA;AAMA;AACA;;;AACA;AACA;AAEA;AAKA;;;AAEA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AADA;AAGA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AAGA;AACA;AANA;AAQA;AAAA;AAEA;AACA;AAFA;AAIA;AAAA;AAGA;AACA;AAFA;AAIA;AAAA;AAKA;;;;AA/DA;AACA;;;;;;;;;;;;ACvBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAKA;AAEA;AACA;AAAA;AAAA;AAFA;AAKA;AADA;AAMA;AAAA;AAAA;AACA;AAAA;AAIA;AACA;AACA;AADA;AAFA;AAMA;AAAA;AAEA;AAAA;AAKA;;;;AA7CA;AACA;;;;;;;;;;;;ACjBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAcA;;;;AAlBA;AACA;;;;;;;;;;;;ACTA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AALA;AAWA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAHA;AAQA;AAGA;AACA;AACA;;;;;;;;;;;ACxFA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AAAA;AACA;AACA;AACA;AACA;AA6CA;;;;;AAiBA;AAgCA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnCA;AAoCA;AACA;;;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAGA;AAAA;AACA;AAAA;AAMA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AAOA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AACA;AADA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAEA;AAEA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAKA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AAEA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AAIA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAHA;AAMA;AACA;AAAA;AAAA;AACA;AAHA;AAKA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AADA;AAfA;AADA;AAwBA;;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAEA;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAEA;AAUA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAHA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAOA;AAAA;AAGA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AAEA;AAMA;AACA;AA1BA;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5BA;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAiBA;;;;AAxnCA;AACA;;;;;;;;;;;;ACpGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AARA;AAUA;AACA;AAFA;AATA;AAeA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAAA;AAUA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AADA;AAHA;AARA;AAAA;AACA;AAiBA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAFA;AAWA;AACA;AACA;AACA;AAHA;AADA;AAOA;AAAA;AAAA;AAQA;AACA;AAAA;AAAA;AAFA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AAHA;AAFA;AAaA;AAIA;AACA;AACA;;;;;;;;;;;AChHA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AA+BA;AACA;AACA;AACA;AACA;AAEA;;;;;AAMA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AAVA;AAWA;AACA;;;AAAA;AACA;AACA;AAEA;AAFA;AAIA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAIA;AAKA;AAMA;;;AAEA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AASA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AASA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AAGA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAVA;AAcA;;;;AA1dA;AACA;AA4dA;;;;;;;;;;;ACziBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAmDA;AACA;AACA;;;;;AAIA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AAJA;AAKA;AACA;;;AACA;AACA;AACA;;;AACA;AACA;AAIA;;;AACA;AACA;AACA;;;AAEA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAKA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAdA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/CA;AAkDA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAKA;AACA;AAbA;AAiBA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAJA;AADA;AASA;AAAA;AAAA;AACA;AAFA;AAWA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AAJA;AADA;AAcA;;;;AAnKA;AACA;AAqKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjPA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAOA;AACA;AAKA;AAmCA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAjEA;AACA;AAWA;AAAA;AACA;AADA;AAsDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAKA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApBA;AACA;AADA;AACA;AAoBA;AAAA;AACA;AAKA;AACA;AAIA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AAIA;AAIA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAIA;AACA;AAAA;AACA;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzCA;AA2CA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AANA;AAAA;AACA;AADA;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AArBA;AAAA;AAAA;AAAA;AAAA;AACA;AAqBA;AAEA;AAAA;AACA;AAEA;AAGA;AAAA;AACA;AAEA;AACA;AAKA;AACA;AAIA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AAIA;AACA;AAAA;AAUA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA5JA;AA8JA;AACA;AACA;AAIA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AADA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAQA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAHA;AACA;AADA;AACA;AAIA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9tBA;AAOA;AACA;AAEA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AAuBA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAKA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAJA;AAJA;AAWA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAHA;AADA;AASA;AACA;AACA;AACA;AAJA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AADA;AAdA;AAkBA;AApBA;AAsBA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AAFA;AAOA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AADA;AAMA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAbA;AAiBA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AADA;AAmBA;AAGA;AACA;AACA;AANA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAJA;AAUA;AAAA;AASA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AClPA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAnBA;AAqBA;AAGA;AAGA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAMA;;;;;;;;;;;ACnIA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AAOA;AAMA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAXA;AAaA;AAdA;AAgBA;AAAA;AAOA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAJA;AAYA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAFA;AASA;AACA;AACA;AACA;AACA;AAAA;AAAA;AALA;AAQA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AADA;AAgBA;AACA;AACA;;;;;;;;;;;;AC9JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAKA;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;;;;;;;;;;;;ACAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AAQA;;;;;AACA;AAAA;AACA;AADA;AAEA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AAAA;AADA;AAMA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;;;AAvCA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAFA;AACA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAOA;AAAA;AAGA;AACA;AAAA;AAAA;AAFA;AAKA;AACA;AACA;AAHA;AAUA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AADA;AAeA;AACA;AACA;;;;;;;;;;;ACpEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AAEA;AACA;AASA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAFA;AAWA;AACA;AACA;AACA;AAJA;AAQA;AACA;AAFA;AAIA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAGA;AAAA;AAAA;AACA;AAFA;AAKA;AACA;AAAA;AAAA;AAIA;AAIA;;;;;;;;;;;;ACzGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAKA;AACA;AACA;;;;;;;;;;;AClBA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACAA;AAEA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AALA;AAUA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAHA;AAQA;AAGA;AACA;AACA;;;;;;;;;;;AC3FA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAgCA;;;;;AAiBA;AAeA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvBA;AAwBA;AACA;;;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AACA;;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;;;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AAEA;AAGA;AAAA;AACA;AAAA;AAMA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAEA;AAEA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAMA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;;;AACA;AAOA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AACA;AADA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AADA;AAJA;AASA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAHA;AAKA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AADA;AAfA;AADA;AAwBA;;;AACA;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAEA;AAUA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAOA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAPA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AAuBA;;;;AAr4BA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AARA;AAUA;AACA;AAFA;AATA;AAeA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAAA;AAUA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AADA;AAHA;AARA;AAAA;AACA;AAiBA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AADA;AAUA;AACA;AACA;AACA;AAHA;AADA;AAOA;AAAA;AAAA;AAQA;AACA;AAAA;AAAA;AAFA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AAHA;AAFA;AAaA;AAIA;AACA;AACA;;;;;;;;;;;AChHA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AA6BA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AADA;AAGA;AACA;AACA;AARA;AASA;AACA;;;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAUA;AACA;AACA;AACA;AAEA;AACA;AADA;AAGA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AACA;AACA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAFA;AAJA;AAWA;;;;AAhTA;AACA;AAiTA;;;;;;;;;;;AC7XA;AACA;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAJA;AAKA;AALA;AAOA;AACA;AACA;AAEA;AACA;AAZA;AAaA;AACA;AAEA;AAhBA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjCA;AAoCA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAHA;AAYA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAJA;AADA;AASA;AAAA;AAAA;AACA;AAFA;AAWA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AAJA;AADA;AAcA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAjEA;AACA;AAWA;AAAA;AACA;AADA;AAsDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvBA;AAyBA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AANA;AAAA;AACA;AADA;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AArBA;AAAA;AAAA;AAAA;AAAA;AACA;AAqBA;AAEA;AAAA;AACA;AAEA;AAGA;AAAA;AACA;AAEA;AACA;AAKA;AACA;AAIA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AAIA;AACA;AAAA;AAUA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAlJA;AAoJA;AACA;AACA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAYA;AAEA;AACA;AAOA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AALA;AAJA;AAaA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAHA;AADA;AASA;AACA;AACA;AACA;AAJA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AADA;AAdA;AAkBA;AArBA;AAuBA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AAFA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AADA;AAMA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAbA;AAgBA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AADA;AAmBA;AAGA;AACA;AACA;AANA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAJA;AAUA;AAAA;AASA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACjOA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApBA;AAsBA;AACA;AACA;AAMA;;;;;;;;;;;AC/FA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AAMA;AACA;AACA;AAEA;AAQA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAXA;AAaA;AAdA;AAgBA;AAAA;AAOA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAJA;AAYA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAFA;AASA;AACA;AACA;AACA;AACA;AAAA;AAAA;AALA;AAQA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AADA;AAgBA;AACA;AACA;;;;;;;;;;;;AC5JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAKA;;;;;;;;;;;ACtDA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AAQA;;;;;AACA;AAAA;AACA;AADA;AAEA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AAAA;AADA;AAMA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;;;AAvCA;AACA;;;;;;;;;;;;ACbA;AACA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAGA;AACA;AAEA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AAMA;;;;;AACA;AAAA;AACA;AADA;AAEA;AACA;;;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;AATA;AACA;;;;;;;;;;;;ACVA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuBA;AACA;AACA;;;;;AAUA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAPA;AAQA;AACA;;;AACA;AACA;AACA;AACA;;;AACA;;;AAEA;AAUA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAMA;AACA;AAVA;AAaA;AACA;AACA;AAHA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AAHA;AAOA;AACA;AACA;AACA;AAJA;AAUA;AAAA;AAMA;AACA;AAFA;AAIA;AAAA;AAOA;;;AACA;AAAA;AACA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAXA;AADA;AAiBA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAIA;;;;AAxMA;AACA;AA0MA;;;;;;;;;;;ACpPA;AACA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAFA;AAOA;AACA;AACA;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAIA;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;;;;;;;;;;;;ACAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAWA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAFA;AAIA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AADA;AAGA;AARA;AAWA;AACA;AAEA;AACA;AALA;AAMA;AACA;AAPA;AAaA;AACA;AACA;;;;;;;;;;;;AC1EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAKA;;;;;;;;;;;AC9BA;AACA;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAFA;AACA;AAaA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAJA;AASA;AACA;AACA;;;;;;;;;;;;ACnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAQA;AACA;AACA;AAEA;AAAA;AALA;AAsBA;AACA;AACA;;;;;;;;;;;AC5CA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAEA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AAJA;AAOA;AAAA;AAGA;AAAA;AAGA;AAAA;AAKA;;;;AA3CA;AACA;;;;;;;;;;;;ACxBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AAKA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAOA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAXA;AAcA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAQA;AACA;AACA;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAvBA;AAyBA;AACA;AACA;AAKA;;;;;;;;;;;AC1EA;AACA;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3BA;AAAA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AAGA;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;ACvGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACdA;AAEA;AACA;AACA;AAGA;AACA;AAGA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AAKA;AAEA;AACA;AAAA;AAKA;AAEA;AACA;AACA;AAEA;AAKA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAEA;AAOA;AAQA;AACA;AAIA;AACA;AACA;AAEA;AAKA;AAMA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AAMA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AAKA;AAGA;AAKA;AACA;AAGA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AAGA;AAAA;AAKA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;A","sourceRoot":""}